import{d as ho,r as m,c as z,w as Ue,b as A,g as Y,h as l,t as R,m as ht,q as j,v as ft,z as mn,l as q,j as ae,e as E,_ as fo,o as yn,n as fe,a as xn,f as Be,A as wn,F as ve,i as be,k as ze,p as dt,u as je,x as ao,y as At,T as io}from"./index.js";import{u as Ln,Z as bn,a as Cn,i as kn,g as Mn,L as En}from"./LockerRegistrationModal.js";const $n={class:"modal-header"},An={class:"locker-number"},Dn={class:"modal-body"},Tn={class:"user-info"},Nn={class:"user-details"},Sn={class:"user-name"},_n={class:"user-phone"},On={class:"date-section"},Rn={class:"date-inputs"},Vn={class:"date-input-wrapper"},Yn=["min"],In={class:"date-input-wrapper"},Pn=["min"],Fn={class:"usage-section"},Xn={class:"usage-select-wrapper"},Kn={class:"modal-footer"},Hn={width:"16",height:"16",viewBox:"0 0 16 16",fill:"none",style:{"margin-right":"6px"}},Bn=ho({__name:"LockerAssignmentModal",props:{isOpen:{type:Boolean},lockerNumber:{},lockerData:{}},emits:["close","confirm"],setup(Dt,{emit:N}){const V=Dt,De=N,C=m("박민영"),Te=m("010-2244-8554"),ie=m("2025-07-10"),U=m("2025-08-09"),le=m("3months"),Ce=z(()=>new Date().toISOString().split("T")[0]),J=()=>{De("close")},ke=p=>{p.target===p.currentTarget&&J()},F=()=>{const p={userName:C.value,userPhone:Te.value,startDate:ie.value,endDate:U.value,usage:le.value};De("confirm",p),J()},Ne=()=>{console.log("락커 사용 종료"),J()};return Ue(()=>V.lockerData,p=>{p&&(p.userName&&(C.value=p.userName),p.userPhone&&(Te.value=p.userPhone),p.startDate&&(ie.value=p.startDate),p.endDate&&(U.value=p.endDate),p.usage&&(le.value=p.usage))}),(p,D)=>p.isOpen?(E(),A("div",{key:0,class:"modal-overlay",onClick:ke},[l("div",{class:"modal-container",onClick:D[3]||(D[3]=ae(()=>{},["stop"]))},[l("div",$n,[l("span",An,R(p.lockerNumber)+"번",1),D[5]||(D[5]=l("span",{class:"modal-title"},"락커배정",-1)),l("button",{onClick:J,class:"close-button"},D[4]||(D[4]=[l("svg",{width:"20",height:"20",viewBox:"0 0 20 20"},[l("path",{d:"M4 4L16 16M16 4L4 16",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round"})],-1)]))]),l("div",Dn,[l("div",Tn,[D[6]||(D[6]=ht('<div class="user-avatar" data-v-fc9dc67d><svg width="60" height="60" viewBox="0 0 60 60" fill="none" data-v-fc9dc67d><circle cx="30" cy="30" r="29" fill="#E5E7EB" stroke="#D1D5DB" stroke-width="2" data-v-fc9dc67d></circle><circle cx="30" cy="20" r="8" fill="#9CA3AF" data-v-fc9dc67d></circle><path d="M15 45C15 37.268 21.268 31 29 31H31C38.732 31 45 37.268 45 45V50H15V45Z" fill="#9CA3AF" data-v-fc9dc67d></path></svg></div>',1)),l("div",Nn,[l("div",Sn,R(C.value||"박민영"),1),l("div",_n,R(Te.value||"010-2244-8554"),1)])]),l("div",On,[D[8]||(D[8]=l("label",{class:"date-label"},"기간 설정",-1)),l("div",Rn,[l("div",Vn,[j(l("input",{type:"date","onUpdate:modelValue":D[0]||(D[0]=Q=>ie.value=Q),class:"date-input",min:Ce.value},null,8,Yn),[[ft,ie.value]])]),D[7]||(D[7]=l("span",{class:"date-separator"},"-",-1)),l("div",In,[j(l("input",{type:"date","onUpdate:modelValue":D[1]||(D[1]=Q=>U.value=Q),class:"date-input",min:ie.value||Ce.value},null,8,Pn),[[ft,U.value]])])])]),l("div",Fn,[D[11]||(D[11]=l("label",{class:"usage-label"},"연동할 이용권",-1)),l("div",Xn,[j(l("select",{"onUpdate:modelValue":D[2]||(D[2]=Q=>le.value=Q),class:"usage-select"},D[9]||(D[9]=[l("option",{value:"3months"},"학기 3개월   →   35번 (남자 락커)",-1),l("option",{value:"6months"},"학기 6개월   →   70번 (남자 락커)",-1),l("option",{value:"1year"},"연간 이용권   →   140번 (남자 락커)",-1)]),512),[[mn,le.value]]),D[10]||(D[10]=l("svg",{class:"select-arrow",width:"12",height:"12",viewBox:"0 0 12 12"},[l("path",{d:"M3 5L6 8L9 5",stroke:"#6B7280","stroke-width":"1.5","stroke-linecap":"round","stroke-linejoin":"round",fill:"none"})],-1))])]),D[12]||(D[12]=l("div",{class:"notice-box"},[l("div",{class:"notice-title"},"락커 배정"),l("div",{class:"notice-text"},"입력된 내용이 없어요.")],-1))]),l("div",Kn,[l("button",{onClick:Ne,class:"btn-random"},[(E(),A("svg",Hn,D[13]||(D[13]=[l("circle",{cx:"8",cy:"8",r:"7",stroke:"currentColor","stroke-width":"1.5"},null,-1),l("path",{d:"M8 4V8L10.5 10.5",stroke:"currentColor","stroke-width":"1.5","stroke-linecap":"round"},null,-1)]))),D[14]||(D[14]=q(" 락커 사용 종료 ",-1))]),l("div",{class:"action-buttons"},[l("button",{onClick:J,class:"btn-cancel"},"취소"),l("button",{onClick:F,class:"btn-confirm"},"수정 완료")])])])])):Y("",!0)}}),zn=fo(Bn,[["__scopeId","data-v-fc9dc67d"]]),jn={class:"locker-placement"},Gn={key:0,class:"loading-overlay"},Un={key:1,class:"main-content"},Wn={class:"container"},Zn={class:"canvas-area"},qn={class:"zone-tabs"},Jn={class:"zone-tab-group"},Qn=["onClick","onContextmenu"],es={key:0,class:"tab-indicator"},ts={class:"zone-controls"},os={class:"mode-toggle-inline"},ns={key:0,class:"zoom-controls"},ss={class:"canvas-wrapper"},as=["viewBox"],is=["width","height"],ls={key:1},rs=["x","y","font-size"],cs=["x","y","font-size"],ds={key:2,class:"unified-outlines"},us=["x","y","width","height"],hs={key:3},fs=["transform"],vs={key:4,class:"alignment-guides"},gs=["y1","x2","y2"],ps=["x1","x2","y2"],ms=["x","y","width","height"],ys={class:"form-group"},xs={class:"modal-buttons"},ws={class:"form-group"},Ls={style:{display:"flex","justify-content":"space-between","align-items":"flex-start"}},bs={class:"radio-group-horizontal",style:{flex:"1","margin-left":"20px"}},Cs={class:"radio-label"},ks={class:"radio-label"},Ms={class:"radio-label"},Es={class:"form-section"},$s={class:"form-options-row"},As={class:"radio-group-horizontal"},Ds={class:"radio-label"},Ts={class:"radio-label"},Ns={class:"form-section"},Ss={style:{"margin-top":"10px"}},_s={key:0,class:"progress-section"},Os={class:"progress-indicator"},Rs={class:"progress-text"},Vs={class:"modal-buttons"},Ys=["disabled"],Is=["disabled"],Ps={key:0},Fs={key:1},Xs={class:"grouping-results"},Ks={class:"modal-buttons"},Hs={class:"debug-section"},Bs={class:"debug-stats"},zs={class:"stat-item"},js={class:"value"},Gs={class:"stat-item"},Us={class:"value"},Ws={class:"stat-item"},Zs={class:"value"},qs={class:"stat-item"},Js={class:"value"},Qs={class:"debug-section"},ea={class:"locker-list"},ta={class:"locker-header"},oa={class:"locker-name"},na={class:"locker-type"},sa={class:"locker-details"},aa={class:"debug-section"},ia={class:"locker-list"},la={class:"locker-header"},ra={class:"locker-name"},ca={class:"locker-type"},da={class:"locker-details"},ua={class:"modal-buttons"},lo=1,ro=1,ge=1250,Ge=3100,ut=1440,se=1550,pe=720,co=5,uo=55,ha=ho({__name:"LockerManagement",setup(Dt){const N=Ln(),V=m(null),De=m(null),C=m(null),Te=m(!1),ie=m(null),U=m(!1),le=m(!1),Ce=m(""),J=m(null),ke=m(!1),F=m(!1),Ne=m({x:0,y:0}),p=m("floor"),D=m(!0),Q=m(!1),Tt=m([]),Nt=m({isSelecting:!1,startX:0,startY:0,endX:0,endY:0}),Se=m(!1),vt=m(""),St=m(!1),We=m({x:0,y:0}),Ze=m(!1),gt=m({x:0,y:0}),pt=m(null),_t=m(!1);m({x:0,y:0});const vo=m(null),_e=m(!1),re=m(1),qe=m(!1),Oe=m(!1),Je=m(1),G=m("all"),Me=m("horizontal"),Qe=m(!1),et=m(!1),me=m(!1),ce=m(""),de=()=>p.value==="floor"?lo:ro,ee=m(Ge),ue=m(ut);m(1550),m(700);const I=m(1),Ot=Math.max(se/Ge,pe/ut),Rt=Math.min(Ge/se,ut/pe),K=m({x:0,y:0}),Re=m(!1),tt=m({x:0,y:0}),mt=()=>{if(we.value||Ve.value)return;const t=document.querySelector(".canvas-wrapper");if(t){const e=t.getBoundingClientRect();e.width,e.height}},go=(t,e)=>{const s=de();return{x:t*s,y:e*s}},po=(t,e)=>{const s=de();return{width:t*s,height:e*s}},ye=z(()=>N.zones),xe=m([]);m(!1);const we=m(!0),Ve=m(!0),mo=m(!1),yt=m(null);m(null);const H=(()=>{if(kn()){const t=Mn();return t?`${t.baseUrl}/api`:"/api"}return"http://localhost:3333/api"})(),xt=async()=>{try{const t=await fetch(`${H}/zones`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.zones){const s=e.zones.map(o=>({id:o.LOCKR_KND_CD,name:o.LOCKR_KND_NM,x:o.X,y:o.Y,width:o.WIDTH,height:o.HEIGHT,color:o.COLOR,floor:o.FLOOR,...o}));N.zones=s}else console.warn("[API] No zones data in response:",e),N.zones=[]}catch(t){console.error("[API] Failed to load zones:",t.message),N.zones=[]}},he=async()=>{try{const t=p.value==="floor",e=`${H}/lockrs?parentOnly=false`,s=await fetch(e);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const o=await s.json();if(o.lockers&&o.lockers.forEach(n=>{const i=n.PARENT_LOCKR_CD===null?"PARENT":`CHILD of ${n.PARENT_LOCKR_CD}`}),o.success&&o.lockers){const n=o.lockers.map(a=>{const i=xe.value.find(g=>g.id===a.LOCKR_TYPE_CD),d=(i==null?void 0:i.width)||40,r=(i==null?void 0:i.height)||60,u=(i==null?void 0:i.depth)||40,c=a.PARENT_LOCKR_CD?`locker-${a.PARENT_LOCKR_CD}`:null;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X!==null&&a.X!==void 0?a.X:void 0,y:a.Y!==null&&a.Y!==void 0?a.Y:void 0,width:d,height:u,depth:u,actualHeight:r,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockerId:c,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});N.lockers=n,N.lockers.forEach(a=>{const d=!a.parentLockrCd?"PARENT":`CHILD of ${a.parentLockrCd}`}),n.forEach(a=>{a.number==="L3"||a.number==="L4"||a.number==="L1"||a.number==="L2"||a.number})}else if(o.lockers){const n=o.lockers.map(a=>{const i=xe.value.find(r=>r.id===a.LOCKR_TYPE_CD),d=(i==null?void 0:i.height)||60;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X||0,y:a.Y||0,width:(i==null?void 0:i.width)||40,height:(i==null?void 0:i.depth)||40,depth:(i==null?void 0:i.depth)||40,actualHeight:d,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});N.lockers=n}else console.warn("[API] No lockers data in response:",o),N.lockers=[]}catch(t){console.error("[API] Failed to load lockers:",t.message),N.lockers=[]}},Vt=async()=>{try{we.value=!0;const t=await fetch(`${H}/types`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.success){const s=(e.types||[]).map(o=>({id:o.LOCKR_TYPE_CD,name:o.LOCKR_TYPE_NM,width:o.WIDTH,height:o.HEIGHT,depth:o.DEPTH,color:o.COLOR||"#3b82f6",type:o.LOCKR_TYPE_CD}));xe.value=s}}catch(t){console.error("Failed to load locker types:",t),xe.value=[]}finally{we.value=!1,mo.value=!0}},yo=async t=>{try{const e=await fetch(`${H}/zones`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save zone");const s=await e.json();if(s.success)return await xt(),s}catch(e){throw console.error("[API] Zone save failed:",e),yt.value="Failed to save zone",e}},Yt=async t=>{try{const e=await fetch(`${H}/lockrs`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save locker");const s=await e.json();if(s.success)return await he(),s}catch(e){throw console.error("[API] Locker save failed:",e),yt.value="Failed to save locker",e}},It=async(t,e)=>{try{const s=await fetch(`${H}/lockrs/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!s.ok){const n=await s.text();throw new Error(`Failed to update locker placement: ${s.status} - ${n}`)}const o=await s.json();if(o.success)return o}catch(s){throw console.error("[API] Locker placement update failed:",s),yt.value="Failed to update locker placement",s}},xo=async t=>{try{const e=await fetch(`${H}/lockrs/batch-numbers`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({updates:t})});if(!e.ok){const o=await e.text();throw new Error(`Failed to batch update locker numbers: ${e.status} - ${o}`)}const s=await e.json();if(s.success)return s;throw new Error(`Batch update failed: ${s.message||"Unknown error"}`)}catch(e){throw console.error("[API] Batch locker number update failed:",e),e}},wo=async t=>{try{const e=t.map(s=>{var i;const o=x.value.find(d=>d.id===s.id),n=Math.round(s.x*100)/100,a=Math.round(s.y*100)/100;if(o&&o.lockrCd)return It(o.lockrCd,{X:n,Y:a});if(o){const d={LOCKR_KND:(i=V.value)==null?void 0:i.id,LOCKR_TYPE_CD:o.type||"1",X:n,Y:a,LOCKR_LABEL:o.number,ROTATION:o.rotation||0,LOCKR_STAT:"00"};return Yt(d).then(r=>(r&&r.lockrCd&&(o.lockrCd=r.lockrCd),r))}});await Promise.all(e)}catch(e){console.error("[API] Failed to save some locker positions:",e)}},Lo=m([]),ot=t=>{if(t.length<=1)return null;const e=2,s=t.map(d=>{const r=p.value==="front"?d.actualHeight||d.height||60:d.depth||d.height||40,u=p.value==="front"&&d.frontViewX!==void 0?d.frontViewX:d.x,c=p.value==="front"&&d.frontViewY!==void 0?d.frontViewY:d.y;return{left:u,right:u+d.width*e,top:c,bottom:c+r*e,locker:d}}),o=Math.min(...s.map(d=>d.left)),n=Math.max(...s.map(d=>d.right)),a=Math.min(...s.map(d=>d.top)),i=Math.max(...s.map(d=>d.bottom));return{minX:o,maxX:n,minY:a,maxY:i,width:n-o,height:i-a}},bo=(t,e,s=5)=>{const n=p.value==="front"?t.actualHeight||t.height||60:t.depth||t.height||40,a=p.value==="front"?e.actualHeight||e.height||60:e.depth||e.height||40,i=b=>p.value==="front"?{x:b.frontViewX!==void 0?b.frontViewX:b.x,y:b.frontViewY!==void 0?b.frontViewY:b.y}:{x:b.x,y:b.y},d=i(t),r=i(e),u={left:d.x,right:d.x+t.width*2,top:d.y,bottom:d.y+n*2},c={left:r.x,right:r.x+e.width*2,top:r.y,bottom:r.y+a*2},v=s,g=Math.min(Math.abs(u.right-c.left),Math.abs(c.right-u.left)),h=Math.min(Math.abs(u.bottom-c.top),Math.abs(c.bottom-u.top))<=v,y=u.left<c.right&&c.left<u.right,k=g<=v,f=u.top<c.bottom&&c.top<u.bottom;return h&&y||k&&f},Co=t=>{const e=[],s=new Set,o=(n,a)=>{s.has(n.id)||(s.add(n.id),a.push(n),t.forEach(i=>{!s.has(i.id)&&bo(n,i)&&o(i,a)}))};return t.forEach(n=>{if(!s.has(n.id)){const a=[];o(n,a),e.push(a)}}),e},ko=t=>{if(!_.value.has(t))return[];const e=x.value.find(u=>u.id===t);if(!e)return[];const s=[],o=10,n=W(e),a=(e.rotation||0)%360,i={0:{top:"top",right:"right",bottom:"bottom",left:"left"},90:{top:"left",right:"top",bottom:"right",left:"bottom"},180:{top:"bottom",right:"left",bottom:"top",left:"right"},270:{top:"right",right:"bottom",bottom:"left",left:"top"}},d=Math.round(a/90)*90%360,r=i[d]||i[0];return Pt.value.forEach(u=>{if(u.id===t)return;const c=W(u);F.value&&console.log(`[Adjacent Check] ${t} vs ${u.id}:`,{locker:{id:t,rotation:a,bounds:n},other:{id:u.id,rotation:u.rotation,bounds:c},mapping:r}),Math.abs(n.y-(c.y+c.height))<o&&n.x<c.x+c.width&&n.x+n.width>c.x&&(s.push(r.top),F.value&&console.log("  -> TOP adjacent (physical top touches other's bottom)")),Math.abs(n.y+n.height-c.y)<o&&n.x<c.x+c.width&&n.x+n.width>c.x&&s.push(r.bottom),Math.abs(n.x-(c.x+c.width))<o&&n.y<c.y+c.height&&n.y+n.height>c.y&&s.push(r.left),Math.abs(n.x+n.width-c.x)<o&&n.y<c.y+c.height&&n.y+n.height>c.y&&s.push(r.right)}),[...new Set(s)]};z(()=>xe.value.filter(t=>!Lo.value.includes(t.id)));const x=z(()=>{if(!V.value)return[];let t=N.lockers.filter(e=>e.zoneId===V.value.id);return p.value==="floor"&&(t=t.filter(e=>!e.parentLockrCd)),t.forEach(e=>{!e.parentLockrCd||`${e.parentLockrCd}`}),t}),Mo=z(()=>{const t={},e=N.lockers.filter(s=>{var o;return s.zoneId===((o=V.value)==null?void 0:o.id)});return console.log("Computing lockersWithChildren, viewMode:",p.value),console.log("All lockers in zone:",e),x.value.forEach(s=>{if(!s.parentLockrCd){const o=e.filter(n=>n.parentLockrCd===s.lockrCd||n.parentLockerId===s.id).sort((n,a)=>(a.tierLevel||0)-(n.tierLevel||0));o.length>0&&console.log(`Parent locker ${s.lockrCd} has ${o.length} children:`,o),t[s.id]=o}}),console.log("Final childrenMap:",t),t}),Eo=z(()=>x.value.map((e,s)=>{let o,n,a;const i=e.actualHeight||e.height||60;if(p.value==="floor"){const r=go(e.x,e.y);o=r.x,n=r.y,a=po(e.width,e.height||e.depth||40).height}else{const r=de();if(e.frontViewX!==void 0&&e.frontViewX!==null&&e.frontViewY!==void 0&&e.frontViewY!==null)o=e.frontViewX*r,n=e.frontViewY*r,a=i*r;else if(e.x!==void 0&&e.x!==null&&e.y!==void 0&&e.y!==null){const u=400+s*80,c=200;o=u,n=c,a=i*r}else o=100+s*100,n=100,a=i*r}const d=e.width*de();return{...e,displayX:o,displayY:n,displayWidth:d,displayHeight:a,actualHeight:e.actualHeight||i||60,logicalX:e.x,logicalY:e.y,logicalWidth:e.width,logicalHeight:e.height||e.depth||40}})),$o=z(()=>{const t=Eo.value.map(e=>{if(p.value==="front"){const s=e.actualHeight||e.height||60,o=e.displayX/de(),n=e.displayY/de(),a=e.frontViewRotation!==void 0?e.frontViewRotation:0;return e.x===o&&e.y===n&&e.height===s&&e.rotation===a?e:{...e,x:o,y:n,height:s,actualHeight:s,rotation:a}}return e});if(p.value==="front")return t;if(C.value){const e=t.findIndex(s=>s.id===C.value.id);if(e>-1){const[s]=t.splice(e,1);t.push(s)}}return t}),Pt=z(()=>x.value.filter(t=>_.value.has(t.id))),nt=z(()=>Co(Pt.value)),Ao=z(()=>{const t=new Set;return nt.value.forEach(e=>{e.length>1&&e.forEach(s=>t.add(s.id))}),t});m(!1),m([]);const Ft=()=>{if(!C.value)return{x:0,y:0};const t=x.value.find(e=>e.id===C.value.id);return t?p.value==="front"?{x:t.frontViewX!==void 0?t.frontViewX:t.x,y:t.frontViewY!==void 0?t.frontViewY:t.y}:{x:t.x,y:t.y}:{x:C.value.x,y:C.value.y}},te=t=>{if(!t)return{width:0,height:0};const e=2;return p.value==="floor"?{width:(t.width||40)*e,height:(t.depth||t.height||40)*e}:{width:(t.width||40)*e,height:(t.actualHeight||t.height||60)*e}},Xt=m(!1),Do=m(!1),Le=m([]),_=m(new Set);m(null);const Ye=m(!1),P=m({x:0,y:0}),X=m({x:0,y:0}),oe=m([]),Kt=m(!1),st=m(!1);m([]);const Ie=m(!1),Ht=m([]),Bt=m([]),Pe=async t=>{V.value=t,C.value=null,p.value==="front"&&(console.log("[Zone Change] Loading lockers for zone in front view mode..."),await he(),fe(()=>{x.value.some(s=>s.frontViewX==null||s.frontViewY==null)?(console.log("[Zone Change] Found lockers without front view coordinates, recalculating..."),$e()):console.log("[Zone Change] All lockers have front view coordinates")})),setTimeout(()=>{Fe()},100)},To=(t,e)=>{t.preventDefault(),t.stopPropagation(),pt.value=e,gt.value={x:t.clientX,y:t.clientY},Ze.value=!0;const s=()=>{Ze.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},No=async t=>{var e;try{const s=x.value.filter(d=>d.LOCKR_KND===t.id||d.zoneId===t.id||d.LOCKR_KND===t.LOCKR_KND_CD);if(s.length>0){alert(`구역 삭제 불가

이 구역에 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`구역 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=t.LOCKR_KND_CD||t.id,n=`${H}/zones/${o}`,a=await fetch(n,{method:"DELETE"});if(!a.ok){const d=await a.json();throw new Error(d.message||"Failed to delete zone")}(await a.json()).success&&(await xt(),((e=V.value)==null?void 0:e.id)===t.id&&(ye.value.length>0?Pe(ye.value[0]):V.value=null),alert("구역이 성공적으로 삭제되었습니다."))}catch(s){console.error("[API] Zone deletion failed:",s),alert(`구역 삭제 중 오류가 발생했습니다:
${s.message}`)}finally{Ze.value=!1}},So=async t=>{var e;try{const s=x.value.filter(a=>a.LOCKR_TYPE_CD===t.id||a.type===t.id);if(s.length>0){alert(`타입 삭제 불가

이 타입으로 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`락커 타입 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=await fetch(`${H}/types/${t.id}`,{method:"DELETE"});if(!o.ok){const a=await o.json();throw new Error(a.message||"Failed to delete locker type")}(await o.json()).success&&(await Vt(),((e=De.value)==null?void 0:e.id)===t.id&&(De.value=null),_t.value=!1)}catch(s){console.error("Failed to delete locker type:",s),alert("락커 타입 삭제에 실패했습니다.")}},at=t=>{const e=ie.value;if(!e)return{x:0,y:0};const s=e.createSVGPoint();s.x=t.clientX,s.y=t.clientY;const o=s.matrixTransform(e.getScreenCTM().inverse());return de(),{x:Math.round(o.x*100)/100,y:Math.round(o.y*100)/100}},_o=t=>{if(p.value!=="floor"&&p.value!=="front"||!t.ctrlKey)return;t.preventDefault();const s=t.currentTarget.getBoundingClientRect(),o=(t.clientX-s.left)/s.width,n=(t.clientY-s.top)/s.height,a=se/I.value,i=pe/I.value,d=K.value.x+o*a,r=K.value.y+n*i,u=t.deltaY>0?.9:1.1,c=Math.min(Math.max(I.value*u,Ot),Rt);if(c!==I.value){const v=se/c,g=pe/c,L={x:d-o*v,y:r-n*g};K.value=wt(L,c),I.value=c}},wt=(t,e)=>{const s=se/e,o=pe/e,n=0,a=0,i=Math.max(0,Ge-s),d=Math.max(0,ut-o);return{x:Math.max(n,Math.min(i,t.x)),y:Math.max(a,Math.min(d,t.y))}},Fe=()=>{if(console.log("[AutoFit] Starting autoFitLockers...",{lockersCount:x.value.length,viewMode:p.value}),x.value.length===0){console.log("[AutoFit] No lockers found, using default zoom"),I.value=1,K.value={x:0,y:0};return}let t=1/0,e=1/0,s=-1/0,o=-1/0;const n=2;if(x.value.forEach(w=>{if(w.parentLockerId)return;let b,T,M,S;if(p.value==="floor")b=w.x,T=w.y,M=w.x+(w.width||40)*n,S=w.y+(w.depth||w.height||40)*n;else if(p.value==="front")b=w.frontViewX!==void 0?w.frontViewX:w.x,T=w.frontViewY!==void 0?w.frontViewY:w.y,M=b+(w.width||40)*n,S=T+(w.actualHeight||w.height||60)*n;else return;t=Math.min(t,b),e=Math.min(e,T),s=Math.max(s,M),o=Math.max(o,S)}),t===1/0||e===1/0){I.value=1,K.value={x:0,y:0};return}const a=s-t,i=o-e,d=.3,r=a*(1+d),u=i*(1+d),c=se/r,v=pe/u;let g=Math.min(c,v);g=g*.729,g=Math.max(Ot,Math.min(g,Rt));const L=(t+s)/2,h=(e+o)/2,y=se/(2*g),k=pe/(2*g);I.value=g;const f={x:L-y,y:h-k};K.value=wt(f,g),console.log("[AutoFit]",p.value,"mode - Zoom:",g,"Pan:",K.value,"Bounds:",{minX:t,minY:e,maxX:s,maxY:o})},Oo=t=>{if((p.value==="floor"||p.value==="front")&&t.button===1){t.preventDefault(),Re.value=!0,tt.value={x:t.clientX,y:t.clientY};return}const e=at(t);e.x,e.y;const s=t.target;!(s.closest("[data-locker-id]")||s.tagName==="rect"&&!s.classList.contains("canvas-background")||s.tagName==="text"||s.tagName==="g"&&s.querySelector("text"))&&(s.tagName==="svg"||s.classList.contains("canvas-background")||s.getAttribute("fill")==="url(#grid)"||s.classList.contains("selection-box"))},Ro=t=>{if((p.value==="floor"||p.value==="front")&&Re.value){const n=(t.clientX-tt.value.x)/I.value,a=(t.clientY-tt.value.y)/I.value,i={x:K.value.x-n,y:K.value.y-a};K.value=wt(i,I.value),tt.value={x:t.clientX,y:t.clientY};return}const e=at(t),s=e.x,o=e.y;Ye.value?(X.value={x:s,y:o},Math.sqrt(Math.pow(s-P.value.x,2)+Math.pow(o-P.value.y,2))>co&&jt()):F.value&&Io(t)},zt=t=>{if((p.value==="floor"||p.value==="front")&&Re.value){Re.value=!1;return}if(!(Xt.value||Do.value)){if(Ye.value){const e=at(t),s=e.x,o=e.y;Math.sqrt(Math.pow(s-P.value.x,2)+Math.pow(o-P.value.y,2))>co?(jt(),Kt.value=!0,_.value.size>0&&(D.value=!0),setTimeout(()=>{Kt.value=!1},100)):Xt.value||(_.value.clear(),C.value=null),Ye.value=!1,P.value={x:0,y:0},X.value={x:0,y:0}}F.value&&Po()}},jt=()=>{if(!P.value||!X.value||P.value.x==null||P.value.y==null||X.value.x==null||X.value.y==null){console.warn("[Rectangle Select] Invalid coordinates, skipping selection update");return}const t=Math.min(P.value.x,X.value.x),e=Math.max(P.value.x,X.value.x),s=Math.min(P.value.y,X.value.y),o=Math.max(P.value.y,X.value.y);if(_.value.clear(),x.value.forEach(n=>{let a,i,d,r;if(p.value==="front"){const c=n.frontViewX!==void 0?n.frontViewX:n.x,v=n.frontViewY!==void 0?n.frontViewY:n.y,g=te(n);a=c,i=c+g.width,d=v,r=v+g.height}else{const c=te(n);a=n.x,i=n.x+c.width,d=n.y,r=n.y+c.height}!(i<t||a>e||r<s||d>o)&&_.value.add(n.id)}),_.value.size>0){const n=Array.from(_.value)[0];C.value=x.value.find(a=>a.id===n),D.value=!0}else C.value=null},Vo=()=>{if(F.value||Nt.value.isSelecting||st.value){console.log("[Modal] Floor modal close prevented - operation in progress");return}_e.value=!1},Yo=()=>{if(F.value||Nt.value.isSelecting||st.value){console.log("[Modal] Number modal close prevented - operation in progress");return}Oe.value=!1};m(null);const Io=t=>{if(!F.value||oe.value.length===0)return;const e=at(t),s=oe.value.find(y=>y.isLeader);if(!s)return;const o=x.value.find(y=>y.id===s.id);if(!o)return;const n=e.x-Ne.value.x,a=e.y-Ne.value.y,i=te(o),d=lt(n),r=lt(a),u=ln(d,r,i.width,i.height,s.id,o.rotation||0),c=u.x!==d||u.y!==r;c&&console.log("[SNAP DEBUG] Position was snapped from",{x:d,y:r},"to",u);const v=u.x-s.initialX,g=u.y-s.initialY,L=[];let h=!1;if(oe.value.forEach(y=>{const k=x.value.find(f=>f.id===y.id);if(k){const f=te(k);let w,b;y.isLeader?(w=u.x,b=u.y):(w=u.x+y.relativeX,b=u.y+y.relativeY);const T=ee.value-f.width,M=ue.value-f.height;w=Math.max(0,Math.min(w,T)),b=Math.max(0,Math.min(b,M)),oo(w,b,f.width,f.height,k.id,k.rotation||0,c)&&(h=!0),L.push({id:k.id,x:w,y:b,dims:f})}}),!h)L.forEach(y=>{var w;const k=Math.round(y.x*100)/100,f=Math.round(y.y*100)/100;N.updateLocker(y.id,{x:k,y:f},!0),((w=C.value)==null?void 0:w.id)===y.id&&(C.value={...C.value,x:k,y:f})}),console.log("[Group Drag] Moving",_.value.size,"lockers. Leader:",s.id,"Delta:",{x:v.toFixed(1),y:g.toFixed(1)});else if(c&&h){console.log("[SNAP WARNING] Collision detected at snapped position, checking overlap amount...");let y=0;oe.value.forEach(k=>{const f=x.value.find(w=>w.id===k.id);if(f){const w=te(f);let b,T;k.isLeader?(b=u.x,T=u.y):(b=u.x+k.relativeX,T=u.y+k.relativeY);const M=W({x:b,y:T,width:w.width,height:w.height,rotation:f.rotation||0});x.value.forEach(S=>{if(S.id!==f.id&&!_.value.has(S.id)){const $=W(S),O=Math.min(M.x+M.width,$.x+$.width)-Math.max(M.x,$.x),B=Math.min(M.y+M.height,$.y+$.height)-Math.max(M.y,$.y);O>0&&B>0&&(y=Math.max(y,Math.min(O,B)),console.log("[SNAP OVERLAP] With",S.id,"- X:",O.toFixed(1),"Y:",B.toFixed(1)))}})}}),y<1?(console.log("[SNAP] Accepting snapped position with micro-overlap:",y.toFixed(2),"px"),L.forEach(k=>{var f;N.updateLocker(k.id,{x:k.x,y:k.y},!0),((f=C.value)==null?void 0:f.id)===k.id&&(C.value={...C.value,x:k.x,y:k.y})})):console.warn("[SNAP] Rejecting snapped position due to significant overlap:",y.toFixed(1),"px")}else{console.log("[COLLISION ADJUSTMENT DEBUG] Collision detected (non-snapped), finding valid position:",{snappedLeader:u,proposedPositions:L.length,hasCollision:h,wasSnapped:c});let y=u.x,k=u.y,f=!1;const w=[{dx:-20,dy:0},{dx:20,dy:0},{dx:0,dy:-20},{dx:0,dy:20},{dx:-20,dy:-20},{dx:20,dy:-20},{dx:-20,dy:20},{dx:20,dy:20}];for(const b of w){const T=u.x+b.dx,M=u.y+b.dy;let S=!1;if(oe.value.forEach($=>{const O=x.value.find(B=>B.id===$.id);if(O&&!S){const B=te(O);let ne,Z;$.isLeader?(ne=T,Z=M):(ne=T+$.relativeX,Z=M+$.relativeY);const Ke=ee.value-B.width,He=ue.value-B.height;ne=Math.max(0,Math.min(ne,Ke)),Z=Math.max(0,Math.min(Z,He)),oo(ne,Z,B.width,B.height,O.id,O.rotation||0,!1)&&(S=!0)}}),!S){y=T,k=M,f=!0;break}}f?(oe.value.forEach(b=>{var M;const T=x.value.find(S=>S.id===b.id);if(T){let S,$;b.isLeader?(S=y,$=k):(S=y+b.relativeX,$=k+b.relativeY);const O=te(T),B=ee.value-O.width,ne=ue.value-O.height;S=Math.max(0,Math.min(S,B)),$=Math.max(0,Math.min($,ne)),N.updateLocker(T.id,{x:S,y:$},!0),((M=C.value)==null?void 0:M.id)===T.id&&(C.value={...C.value,x:S,y:$})}}),console.log("[COLLISION] Adjusted to valid position:",`(${y}, ${k})`)):console.warn("[COLLISION] No collision-free adjustment found, keeping original positions")}},Po=()=>{if(F.value){if(st.value=!0,console.log("[Drag] Setting lockerDragJustFinished flag to true"),setTimeout(()=>{st.value=!1,console.log("[Drag] Cleared lockerDragJustFinished flag")},150),oe.value.length>0){const t=oe.value.map(e=>{const s=x.value.find(o=>o.id===e.id);return{id:e.id,x:(s==null?void 0:s.x)||e.x,y:(s==null?void 0:s.y)||e.y}});wo(t)}F.value=!1,D.value=!0,Ne.value={x:0,y:0},oe.value=[],Ie.value=!1,Ht.value=[],Bt.value=[],console.log("[Drag] End dragging - Current selection count:",_.value.size)}},Fo=()=>{const t=[],e=new Set,s=x.value.filter(o=>!o.parentLockerId);for(let o=0;o<s.length;o++){const n=s[o],a=n.rotation||0;let i=null;if(a===0||a===360?i={minX:n.x,maxX:n.x+n.width,minY:n.y+(n.depth||n.height),maxY:n.y+(n.depth||n.height)+50}:a===90?i={minX:n.x+n.width,maxX:n.x+n.width+50,minY:n.y,maxY:n.y+(n.depth||n.height)}:a===180?i={minX:n.x,maxX:n.x+n.width,minY:n.y-50,maxY:n.y}:a===270&&(i={minX:n.x-50,maxX:n.x,minY:n.y,maxY:n.y+(n.depth||n.height)}),i)for(let d=0;d<s.length;d++){if(o===d)continue;const r=s[d];if(n.zoneId!==r.zoneId)continue;const u=r.depth||r.height,c=!(r.x+r.width<=i.minX||r.x>=i.maxX),v=!(r.y+u<=i.minY||r.y>=i.maxY);c&&v&&(e.add(n.id),e.add(r.id),t.push(`락커 ${n.number}의 문 앞이 락커 ${r.number}에 의해 막혀있습니다.`))}}t.length>0?console.log("[Door Blockage Check]:",{blocked:!0,errors:t,problematicLockers:Array.from(e)}):console.log("[Door Blockage Check]: All locker doors are accessible"),t.length>0&&(t.length=0,t.push("세로배치 모드 불가: 락커의 문 앞이 다른 락커에 의해 막혀있습니다."));for(let o=0;o<x.value.length;o++){const n=x.value[o];for(let a=o+1;a<x.value.length;a++){const i=x.value[a],d=Math.abs(n.x+n.width-i.x)<5||Math.abs(i.x+i.width-n.x)<5,r=Math.abs(n.y+(n.depth||n.height)-i.y)<5||Math.abs(i.y+(i.depth||i.height)-n.y)<5;if(d||r){if(d){const u=n.rotation%180===0,c=i.rotation%180===180;(n.x<i.x&&u&&c||i.x<n.x&&c&&u)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}if(r){const u=n.rotation%180===90,c=n.rotation%180===270,v=i.rotation%180===90,g=i.rotation%180===270;(n.y<i.y&&u&&g||i.y<n.y&&v&&c)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}}}}return console.log("[Placement Validation]:",{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}),{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}},Xo=t=>{x.value.forEach(e=>{e.hasError=!1}),t.forEach(e=>{const s=x.value.find(o=>o.id===e);s&&(s.hasError=!0)})},Lt=m(!1),Gt=t=>{console.log("[setViewMode] Switching to:",t),t==="floor"&&p.value==="front"&&(Lt.value=!0,setTimeout(()=>{Lt.value=!1},400)),p.value=t,t==="front"&&setTimeout(()=>{Fe()},50),t==="floor"&&setTimeout(()=>{Fe()},50),Ut(),console.log("[ViewMode] Switching to:",t,{previousScale:t==="floor"?ro:lo,newScale:de(),viewMode:p.value}),fe(()=>{mt()})},Ut=()=>{if(p.value==="front"){const e=Fo();if(e.isValid)console.log("[Validation PASSED] Front view validation successful");else{console.error("[Validation FAILED] Cannot switch to front view:",e.errors),console.error("[Validation FAILED] Problematic lockers:",e.problematicLockers),alert(`세로모드 진입 불가: 락커 배치가 규칙에 맞지 않습니다.
문제: `+e.errors.join(`
`)),Xo(e.problematicLockers),p.value="floor";return}x.value.forEach(s=>s.hasError=!1)}console.log("[View Mode] Configuration:",{mode:p.value,floorY:ge,dimensions:p.value==="floor"?"width×depth":"width×height",interactions:p.value==="floor"?"enabled":"disabled"}),Te.value=p.value==="front",p.value==="front"?(C.value=null,_.value.clear(),F.value=!1,D.value=!1):(D.value=!0,console.log("[Floor View] Interactions enabled, full editing mode"));const t=p.value==="floor"?"flat":"vertical";N.setPlacementMode(t)},Wt=()=>{const t=x.value;if(t.length===0)return;const e={minX:Math.min(...t.map(c=>c.x)),maxX:Math.max(...t.map(c=>c.x+c.width)),minY:Math.min(...t.map(c=>c.y)),maxY:Math.max(...t.map(c=>c.y+(c.depth||c.height)))},s=[],o=[],n=[],a=[],i=[];t.forEach(c=>{const v=Math.abs(c.y-e.minY)<30,g=Math.abs(c.y+(c.depth||c.height)-e.maxY)<30,L=Math.abs(c.x-e.minX)<30,h=Math.abs(c.x+c.width-e.maxX)<30;v&&!L&&!h?s.push(c):g&&!L&&!h?n.push(c):h&&!v&&!g?o.push(c):L&&!v&&!g?a.push(c):v&&h||g&&h?o.push(c):v&&L?s.push(c):g&&L?n.push(c):i.push(c)}),s.sort((c,v)=>c.x-v.x),o.sort((c,v)=>c.y-v.y),n.sort((c,v)=>v.x-c.x),a.sort((c,v)=>v.y-c.y);let d=[];s.length>0&&o.length>0&&n.length>0?(console.log("[U-Shape] Detected ㄷ pattern"),d=[...s,...o,...n],console.log("[U-Shape] Walking order:",{top:s.map(c=>`L${c.number}`).join("→"),right:o.map(c=>`L${c.number}`).join("→"),bottom:n.map(c=>`L${c.number}`).join("→"),total:d.map(c=>`L${c.number}`).join("→")})):a.length>0&&o.length>0?(console.log("[Back-to-Back] Detected two columns"),a.sort((c,v)=>c.y-v.y),o.sort((c,v)=>v.y-c.y),d=[...a,...o]):(console.log("[Simple Row] Single line of lockers"),d=[...t].sort((c,v)=>c.x-v.x)),a.length>0&&d.indexOf(a[0])===-1&&(console.log("[Left Column] Adding left side lockers"),d.push(...a)),i.length>0&&(console.log("[Middle] Adding uncategorized lockers:",i.length),d.push(...i));const r=t.length,u=d.length;if(r!==u){console.error("[Transform] Locker count mismatch!",{original:r,unfolded:u});const c=new Set(d.map(g=>g.id)),v=t.filter(g=>!c.has(g.id));console.log("[Missing] Lockers not included:",v.map(g=>`L${g.number}`)),d.push(...v)}Tt.value=d,console.log("[Front View] Transformation complete:",{totalLockers:d.length,sequence:d.map(c=>c.number||c.id).join(" -> ")})},Xe=t=>{let e=t%360;return e<0&&(e+=360),e},Zt=t=>so(t),it=t=>t.reduce((e,s)=>s.y<e.y||s.y===e.y&&s.x<e.x?s:e,t[0]),qt=t=>t.sort((e,s)=>{const o=it(e),n=it(s);return Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x}),bt=t=>{const e=[],s=new Set;return t.forEach(o=>{if(s.has(o.id))return;const n=[],a=[o];for(;a.length>0;){const i=a.shift();s.has(i.id)||(s.add(i.id),n.push(i),t.forEach(d=>{s.has(d.id)||kt(i,d)&&a.push(d)}))}n.length>0&&e.push(n)}),e.forEach((o,n)=>{console.log(`  Minor group ${n+1}: ${o.map(a=>a.number||a.id).join(", ")}`)}),e},Ko=t=>{if(t.length<=1)return t[0]?t[0][0]:null;const e=new Map;for(const o of t){let n=0;for(const a of t){if(o===a)continue;let i=!1;for(const d of o){for(const r of a)if(Mt(d,r)){i=!0;break}if(i)break}i&&n++}e.set(o,n)}const s=t.filter(o=>e.get(o)===1);if(s.length===0){console.log("[Clockwise Start] Complete loop detected, finding leftmost group");let o=t[0];for(const n of t){const a=Ee(n),i=Ee(o);a.x<i.x&&(o=n)}return console.log("[Clockwise Start] Selected leftmost group:",o.map(n=>n.number||n.id).join(",")),o[0]}if(s.length>=2){console.log("[Clockwise Start] Broken chain detected with",s.length,"endpoints");let o=s[0];for(const n of s){const a=Ee(n),i=Ee(o);(a.y<i.y||Math.abs(a.y-i.y)<10&&a.x<i.x)&&(o=n)}return console.log("[Clockwise Start] Selected endpoint:",o.map(n=>n.number||n.id).join(",")),o[0]}return console.log("[Clockwise Start] Fallback to first group"),t[0][0]},Ho=(t,e)=>{for(const s of e)if(s.some(o=>o.id===t.id))return s;return null},Ee=t=>{const e=t.reduce((o,n)=>o+n.x,0),s=t.reduce((o,n)=>o+n.y,0);return{x:e/t.length,y:s/t.length}},Bo=(t,e,s)=>{const o=[],n=Ee(t);for(const a of s){if(e.has(a))continue;let i=!1;for(const d of t){for(const r of a)if(Mt(d,r)){i=!0;break}if(i)break}if(i){const d=Ee(a),r=d.x-n.x,u=d.y-n.y;let c=Math.atan2(u,r)*180/Math.PI;c<0&&(c+=360),o.push({group:a,angle:c})}}return o.length===0?null:(o.sort((a,i)=>a.angle-i.angle),o[0].group)},Jt=t=>{if(t.length<=1)return t;const e=[],s=new Set,o=Ko(t),n=Ho(o,t);if(!n)return t.sort((i,d)=>{const r=it(i),u=it(d);return Math.abs(r.y-u.y)>1?r.y-u.y:r.x-u.x});let a=n;for(;a&&!s.has(a);)e.push(a),s.add(a),a=Bo(a,s,t);for(const i of t)s.has(i)||e.push(i);return e},Qt=t=>{if(t.length===0)return[];const e=Xe(t[0].rotation||0);let s=[...t];switch(console.log(`[Rotation] Processing minor group with rotation ${e}°:`,t.map(o=>`${o.number||o.id}`)),e){case 0:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 90:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 180:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:n.x-o.x);break;case 270:s.sort((o,n)=>Math.abs(o.x-n.x)>1?o.x-n.x:n.y-o.y);break}return console.log("[Rotation] After rotation, order:",s.map(o=>o.number||o.id)),s},zo=(t,e,s,o)=>{let n=null,a=null;s.forEach((g,L)=>{g.some(h=>h.id===t.id)&&(n=L),g.some(h=>h.id===e.id)&&(a=L)});const i=n!==null&&a!==null&&n===a;let d=!1;if(o){const g=o.get(t.id),L=o.get(e.id);d=g!==void 0&&L!==void 0&&g===L}const r=g=>{if(g.typeId==="custom-1755675491548")return"normal";if(g.typeId==="custom-1755675506519")return"tall";if(g.color==="#4A90E2")return"blue";if(g.color==="#BD10E0")return"purple";if(!g.typeId&&g.actualHeight){if(g.actualHeight===30)return"normal";if(g.actualHeight===90)return"tall"}return g.typeId||"default"},u=r(t),c=r(e),v=u===c;return i?{same:!0,sameType:v,sameMinorGroup:!0,sameMajorGroup:d,prevMinorGroup:n,currentMinorGroup:a,prevType:u,currentType:c}:{same:!1,sameType:v,sameMinorGroup:!1,sameMajorGroup:d,prevMinorGroup:n,currentMinorGroup:a,prevType:u,currentType:c}},jo=(t,e,s,o)=>{const n=zo(t,e,s,o);return console.log(`  Group spacing between ${t.number} and ${e.number}:`,n),n.sameMinorGroup?(console.log("  → Same minor group: 0px gap"),0):n.sameMajorGroup?(console.log("  → Same major group, different minor group: 10px gap"),10):(console.log("  → Different major group: 20px gap"),20)},$e=()=>{console.trace("Called from:");const t=x.value.filter(f=>!f.parentLockrCd&&!f.parentLockerId&&(!f.tierLevel||f.tierLevel===0));if(console.log(`[Transform] Processing ${t.length} parent lockers (${x.value.length-t.length} child lockers excluded from grouping)`),t.length===0)return;const e=Zt(t),s=qt(e),o=[],n=2;let a=0;const i=[],d=[],r=[],u=new Map;s.forEach((f,w)=>{console.log(`[Front View] Processing major group ${w+1}:`,f.map(M=>`${M.number||M.id}(rot:${M.rotation||0})`)),f.forEach(M=>{u.set(M.id,w)});const b=bt(f),T=Jt(b);r.push(...T),console.log(`  Found ${T.length} minor groups:`),T.forEach((M,S)=>{console.log(`    Minor Group ${S+1}:`,M.map($=>`${$.number}(rot:${$.rotation||0})`))}),T.forEach((M,S)=>{console.log(`  Processing minor group ${S+1}:`,M.map(O=>`${O.number||O.id}(rot:${O.rotation||0})`)),Qt(M).forEach(O=>{d.push(O)})})});let c=null;d.forEach((f,w)=>{if(o.push(f),c&&w>0){let M=0;!c.parentLockrCd&&!f.parentLockrCd&&(M=jo(c,f,r,u)),a+=M}const b=(f.width||40)*n,T=(f.actualHeight||f.height||60)*n;if(i.push({...f,frontViewX:a,frontViewY:ge-T,frontViewRotation:0}),f.parentLockrCd){const M=i.find(S=>S.lockrCd===f.parentLockrCd);if(M){let S=30;if(M.lockrTypeCd||M.typeId||M.type){const Z=M.lockrTypeCd||M.typeId||M.type,Ke=xe.value.find(He=>He.id===Z||He.type===Z||He.LOCKR_TYPE_CD===Z);Ke&&Ke.height&&(S=Ke.height,console.log(`[TIER HEIGHT] Using type height: ${S} for parent type: ${Z}`))}const $=S*n,O=f.tierLevel||1,B=M.frontViewX,ne=M.frontViewY-$*O;i[i.length-1].frontViewX=B,i[i.length-1].frontViewY=ne,i[i.length-1].frontViewRotation=0}else console.error(`[CHILD POSITION] Parent not found for ${f.number}, parentLockrCd: ${f.parentLockrCd}`),i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=ge-T,i[i.length-1].frontViewRotation=0,a+=b}else i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=ge-T,i[i.length-1].frontViewRotation=0,a+=b;c=f});const v=a,g=(ee.value-v)/2;i.forEach(f=>{f.frontViewX+=g});const L=[],h=0;if(i.forEach(f=>{const w=(f.actualHeight||f.height||0)*2,b=f.frontViewY;if(b<h){console.warn(`[Boundary Check] 락커 ${f.number}이(가) 화면 위쪽 경계를 넘어갑니다:`,{lockerId:f.id,number:f.number,topEdge:b,height:w,canvasTop:h,isOverflowing:b<h});const T=x.value.find(M=>M.id===f.id);T&&L.push(T)}}),L.length>0){console.log(`[Boundary Check] 화면을 넘어가는 ${L.length}개의 락커를 삭제합니다:`,L.map(w=>`${w.number}(${w.id})`)),L.forEach(w=>{const b=x.value.findIndex(T=>T.id===w.id);b!==-1&&x.value.splice(b,1)});const f=L.map(async w=>{try{const b=await fetch(`${H}/lockrs/${w.lockrCd}`,{method:"DELETE"});b.ok?console.log(`[Boundary Check] 백엔드에서 락커 ${w.number}(${w.lockrCd}) 삭제 완료`):console.error(`[Boundary Check] 백엔드에서 락커 ${w.number} 삭제 실패:`,await b.text())}catch(b){console.error(`[Boundary Check] 백엔드에서 락커 ${w.number} 삭제 중 오류:`,b)}});Promise.all(f).then(()=>{console.log("[Boundary Check] 모든 경계 초과 락커 삭제 완료, 락커 목록 다시 로드 및 위치 재계산"),he().then(()=>{fe(()=>{$e()})})})}console.log("[Batch Update] Starting batch update for all lockers...");const y=[];i.forEach(f=>{y.push({id:f.id,updates:{frontViewX:f.frontViewX,frontViewY:f.frontViewY,frontViewRotation:f.frontViewRotation||0}})}),N.batchUpdateLockers(y),console.log(`[Batch Update] Updated ${y.length} lockers simultaneously`),console.log("[DB Save] Saving front view coordinates to database...");const k=y.map(async f=>{try{const w=x.value.find(b=>b.id===f.id);if(w&&w.lockrCd){const b={};f.updates.frontViewX!==void 0&&(b.FRONT_VIEW_X=f.updates.frontViewX),f.updates.frontViewY!==void 0&&(b.FRONT_VIEW_Y=f.updates.frontViewY);const T=await fetch(`${H}/lockrs/${w.lockrCd}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)});T.ok?console.log(`[DB Save] Saved locker ${w.number} with FRONT_VIEW_X=${b.FRONT_VIEW_X}, FRONT_VIEW_Y=${b.FRONT_VIEW_Y}`):console.error(`[DB Save] Failed to save locker ${w.number}:`,await T.text())}}catch(w){console.error(`[DB Save] Failed to save locker ${f.id}:`,w)}});Promise.all(k).then(()=>{console.log("[DB Save] All front view coordinates saved to database")}).catch(f=>{console.error("[DB Save] Error saving some lockers:",f)}),Tt.value=o,console.log("[Front View] NEW Transformation complete:",{totalLockers:o.length,majorGroups:s.length,sequence:o.map(f=>f.number||f.id).join(" → "),deletedLockers:L.length})},eo=()=>{if(p.value!=="front"){to();return}const t=_.value.size>0?Array.from(_.value):C.value?[C.value.id]:[];if(t.length===0)return;const e=t.map(a=>x.value.find(i=>i.id===a)).filter(Boolean);if(e.some(a=>!a.parentLockrCd||a.tierLevel===0)){alert("부모 락커는 삭제할 수 없습니다. 자식 락커(상단 락커)만 삭제 가능합니다.");return}const o=new Map;e.forEach(a=>{const i=a.parentLockrCd||"no-parent";o.has(i)||o.set(i,[]),o.get(i).push(a)}),console.log("[DELETE] Lockers grouped by parent:",Array.from(o.entries()).map(([a,i])=>({parent:a,lockers:i.map(d=>({id:d.id,number:d.number,tierLevel:d.tierLevel}))})));for(const[a,i]of o.entries()){const d=i.map(c=>c.tierLevel||0).filter((c,v,g)=>g.indexOf(c)===v).sort((c,v)=>v-c);console.log(`[DELETE] Parent ${a} tier levels:`,d);const r=Math.max(...d);if(!d.every((c,v)=>{const g=r-v,L=c===g;return console.log(`[DELETE] Parent ${a} tier validation:`,{tier:c,index:v,expected:g,isValid:L}),L})){alert(`삭제는 각 부모 그룹별로 가장 높은 tier부터 순서대로만 가능합니다. (부모: ${a})`);return}}const n=[];for(const[a,i]of o.entries()){const d=Math.max(...i.map(u=>u.tierLevel||0));console.log(`[DELETE] Parent ${a} selected max tier:`,d);const r=x.value.some(u=>u.parentLockrCd===a&&!i.find(c=>c.id===u.id)&&(u.tierLevel||0)>d);console.log(`[DELETE] Parent ${a} has upper tiers:`,r),r&&n.push({parentKey:a,selectedMaxTier:d,reason:"선택된 최상단 락커 위에 더 높은 tier 존재"})}if(n.length>0){console.log("[DELETE] Blocked groups:",n),alert("선택된 락커들 중 일부 그룹에서 최상단 락커 위에 더 높은 tier가 있습니다. 가장 높은 tier부터 삭제해주세요.");return}to(),C.value=null,console.log("[Delete] Deleted lockers:",t)},Go=t=>{const e=t.match(/locker-(\d+)/);return e?parseInt(e[1]):null},to=async()=>{const t=_.value.size>0?Array.from(_.value):C.value?[C.value.id]:[];if(t.length===0)return;const e=[];for(const s of t){const o=x.value.find(n=>n.id===s);if(o&&(o.tierLevel===0||!o.parentLockerId)){const n=Go(s);if(n)try{const a=await fetch(`${H}/lockrs/${n}/children`);if(a.ok){const i=await a.json(),d=i.children||i;d&&d.length>0&&e.push(o)}}catch(a){console.error("[DEBUG] Error checking children:",a)}}}if(e.length>0){alert("상단 락커가 존재합니다. 정면 배치모드에서 상단 락커를 먼저 삭제해주세요.");return}else{const s=t.length;if(!confirm(`삭제하시겠습니까? (${s}개 락커)`))return}t.forEach(s=>{N.deleteLocker(s)}),_.value.clear(),C.value=null,console.log("[Delete] Deleted lockers:",t)},Uo=()=>{const e=(V.value?N.lockers.filter(o=>o.zoneId===V.value.id):x.value).map(o=>parseInt(String(o.lockrNo||0))).filter(o=>o>0).sort((o,n)=>o-n);if(e.length===0)return[];const s=[];for(let o=1;o<e[e.length-1];o++)e.includes(o)||s.push(`L${o}`);return s},Ae=()=>{St.value=!1},Wo=()=>{eo(),Ae()},Zo=()=>{Ae(),_e.value=!0,re.value=1},qo=async()=>{const t=Number(re.value);if(isNaN(t)||t<1||t>9){alert("단수는 1부터 9까지 숫자만 입력 가능합니다.");return}if(p.value!=="front"){alert("단수 추가는 정면배치모드(Front View)에서만 가능합니다.");return}console.log("[AddFloors] Loading latest locker data from database..."),await he(),console.log("[AddFloors] Latest data loaded, processing tier addition...");const e=Array.from(_.value).map(o=>x.value.find(n=>n.id===o)).filter(Boolean),s=e.map(async o=>{let n=o,a=null;if(o.parentLockerId||o.parentLockrCd){if(a=x.value.find(u=>u.id===o.parentLockerId||u.lockrCd===o.parentLockrCd),!a){console.error(`[AddFloors] Parent not found for child locker ${o.number}`);return}n=a,console.log(`[AddFloors] Selected locker is CHILD (${o.number}), using parent (${n.number})`)}else console.log(`[AddFloors] Selected locker is PARENT (${n.number})`);console.log("[AddFloors] Finding existing children for parent:",{parentId:n.id,parentLockrCd:n.lockrCd,parentNumber:n.number});const i=x.value.filter(u=>{const c=u.parentLockrCd&&u.parentLockrCd===n.lockrCd||u.parentLockerId&&u.parentLockerId===n.id;return c&&console.log("[AddFloors] Found existing child:",{childId:u.id,childNumber:u.number,parentLockrCd:u.parentLockrCd,parentLockerId:u.parentLockerId,tierLevel:u.tierLevel||0}),c}),d=i.reduce((u,c)=>Math.max(u,c.tierLevel||0),0),r=d>0?d+1:1;console.log("[AddFloors] Tier level calculation:",{existingChildrenCount:i.length,maxExistingTier:d,startTierLevel:r,algorithm:d>0?`Children exist -> Start from tier ${r}`:"No children -> Start from tier 1"}),console.log(`[AddFloors] Adding ${t} tiers to parent locker:`,{number:n.number,parentLockrCd:n.lockrCd,existingChildren:i.length,existingChildrenDetails:i.map(u=>({number:u.number,tierLevel:u.tierLevel})),maxExistingTier:d,startTierLevel:r,frontViewX:n.frontViewX,frontViewY:n.frontViewY});try{const u={tierCount:t,startTierLevel:r,parentFrontViewX:n.frontViewX,parentFrontViewY:n.frontViewY};console.log("[AddFloors] Sending to backend:",u);const v=await(await fetch(`${H}/lockrs/${n.lockrCd}/tiers`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(u)})).json();if(v.success)console.log(`[AddFloors] Successfully added ${v.count} tiers starting from level ${r}`);else throw console.error("[AddFloors] Failed to add tiers:",v.error),new Error(v.error)}catch(u){throw console.error("[AddFloors] Error adding tiers:",u),u}});try{await Promise.all(s),console.log("[AddFloors] All tiers added successfully")}catch(o){console.error("[AddFloors] Some tiers failed to add:",o),alert("티어 추가 중 오류가 발생했습니다: "+o.message);return}_e.value=!1,console.log(`[Context Menu] Added ${t} tiers to ${e.length} lockers`),he().then(()=>{fe(()=>{console.log("[AddFloors] Applying front view transformation for new tiers...");try{$e(),console.log("[AddFloors] Front view transformation completed for new tiers")}catch(o){console.error("[AddFloors] Front view transformation failed:",o),Wt()}})}),Ut()},Jo=t=>{const e=t.target,o=e.value.replace(/[^0-9]/g,"");if(o!==""){const n=parseInt(o);n>9?(e.value="9",re.value=9):n<1?(e.value="1",re.value=1):(e.value=o,re.value=n)}else e.value="",re.value=1},Qo=()=>{Ae();const t=V.value?N.lockers.filter(o=>o.zoneId===V.value.id):x.value,e=new Set(t.map(o=>o.lockrNo).filter(o=>o&&o>0));let s=1;for(;e.has(s);)s++;console.log("[Number Dialog] 기존 번호:",Array.from(e).sort((o,n)=>o-n)),console.log(`[Number Dialog] 첫 번째 빈 번호: ${s}`),Oe.value=!0,Je.value=s,Me.value="horizontal",Qe.value=!1,et.value=!1},en=()=>{console.log("[Grouping Analysis] Starting analysis..."),console.log("[TEST] Running test with known data first..."),cn();const t=x.value.filter(s=>!s.parentLockrCd);if(t.length===0){vt.value="분석할 락커가 없습니다.",Se.value=!0;return}console.log("[REAL DATA] Now analyzing actual lockers...");let e=`세로배치 순서별 그룹 분석
`;e+=`━━━━━━━━━━━━━━━━━━━━━
`;try{const s=Zt(t),o=qt(s);if(o.forEach((n,a)=>{e+=`대그룹 ${a+1} (${n.length}개 락커):
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;const i=bt(n),d=Jt(i);if(d.forEach((r,u)=>{const v=Qt(r).map(L=>{const h=t.find(y=>y.id===L.id);return`${(h==null?void 0:h.number)||L.id}(${(h==null?void 0:h.rotation)||0}°)`}).join(", ");let g="";if(r.length===1?g="단독":g="인접 (같은방향)",e+=`  소그룹 ${a+1}-${u+1}: ${v} - ${g}
`,r.length>1){e+=`    소그룹 내 거리:
`;for(let L=0;L<r.length-1;L++)for(let h=L+1;h<r.length;h++)if(kt(r[L],r[h])){const y=Ct(r[L],r[h]),k=r[L].number||r[L].id,f=r[h].number||r[h].id;e+=`      ${k} ↔ ${f}: ${y.toFixed(2)}px
`}}}),d.length>1){e+=`  소그룹 간 거리:
`;for(let r=0;r<d.length-1;r++)for(let u=r+1;u<d.length;u++){let c=1/0,v={l1:"",l2:""};for(const g of d[r])for(const L of d[u]){const h=Ct(g,L);h<c&&(c=h,v.l1=g.number||g.id,v.l2=L.number||L.id)}e+=`    소그룹 ${a+1}-${r+1} ↔ 소그룹 ${a+1}-${u+1}: ${c.toFixed(2)}px (${v.l1} - ${v.l2})
`}}e+=`
`}),o.length>1){e+=`대그룹 간 거리:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;for(let n=0;n<o.length-1;n++)for(let a=n+1;a<o.length;a++){let i=1/0,d={l1:"",l2:""};for(const r of o[n])for(const u of o[a]){const c=Ct(r,u);c<i&&(i=c,d.l1=r.number||r.id,d.l2=u.number||u.id)}e+=`  대그룹 ${n+1} ↔ 대그룹 ${a+1}: ${i.toFixed(2)}px (${d.l1} - ${d.l2})
`}e+=`
`}e+=`요약:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`,e+=`총 대그룹: ${s.length}개
`,e+=`총 소그룹: ${o.reduce((n,a)=>n+bt(a).length,0)}개
`,e+=`
💡 이 순서는 세로배치 시 실제 표시 순서와 동일합니다.`}catch(s){console.error("[Grouping Analysis] Error:",s),e+=`분석 중 오류가 발생했습니다.
`,e+=s.message}vt.value=e,Se.value=!0},tn=()=>{const t=V.value?N.lockers.filter(o=>o.zoneId===V.value.id):x.value;console.log("[findNextAvailableLabel] Total lockers in zone:",t.length);const e=t.map(o=>{const n=o.number||o.lockrLabel||"",a=n.toString().match(/^L(\d+)$/),i=a?parseInt(a[1]):0;return i>0&&console.log(`[findNextAvailableLabel] Found label ${n} -> number ${i}`),i}).filter(o=>o>0).sort((o,n)=>o-n);if(console.log("[findNextAvailableLabel] Assigned numbers:",e),e.length===0)return console.log("[findNextAvailableLabel] No existing labels, returning L1"),"L1";for(let o=1;o<e[e.length-1];o++)if(!e.includes(o))return console.log(`[findNextAvailableLabel] Found gap at ${o}, returning L${o}`),`L${o}`;const s=e[e.length-1]+1;return console.log(`[findNextAvailableLabel] No gaps found, returning L${s}`),`L${s}`},on=(t,e)=>{if(t.length===0)return[];const s=20;if(e){const o=new Map;return t.forEach(n=>{const a=n.frontViewY||n.y;let i=null;for(let[d]of o)if(Math.abs(a-d)<=s){i=d;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewX||a.x)-(i.frontViewX||i.x)))}else{const o=new Map;return t.forEach(n=>{const a=n.frontViewX||n.x;let i=null;for(let[d]of o)if(Math.abs(a-d)<=s){i=d;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewY||a.y)-(i.frontViewY||i.y)))}},nn=async()=>{me.value=!0,ce.value="번호 할당을 준비중입니다...";try{const t=V.value?N.lockers.filter(h=>h.zoneId===V.value.id):x.value,e=new Set(t.map(h=>h.lockrNo).filter(h=>h&&h>0));console.log("[Number Assignment] Step 1 - 기존 번호들:",Array.from(e).sort((h,y)=>h-y));const s=Array.from(_.value).map(h=>x.value.find(y=>y.id===h)).filter(Boolean);s.length>0&&(console.log("[Number Assignment] 샘플 락커 전체 데이터:",s[0]),console.log("[Number Assignment] 샘플 락커 주요 필드:",{id:s[0].id,lockrNo:s[0].lockrNo,lockrNoType:typeof s[0].lockrNo,number:s[0].number,numberType:typeof s[0].number,lockrCd:s[0].lockrCd,LOCKR_NO:s[0].LOCKR_NO,LOCKR_NO_Type:typeof s[0].LOCKR_NO}));const o=[],n=[];if(s.forEach((h,y)=>{const k=h.lockrNo||h.LOCKR_NO||h.number,f=Number(k),w=!isNaN(f)&&f>0;y<3&&console.log(`[Number Assignment] 락커 ${y+1} 상세:`,{id:h.id.slice(-4),lockrNo:h.lockrNo,LOCKR_NO:h.LOCKR_NO,number:h.number,converted:f,hasNumber:w}),w?(h.lockrNo=f,o.push(h)):n.push(h)}),console.log(`[Number Assignment] Step 2 - 선택된 락커: 총 ${s.length}개`),console.log(`  - 번호 있음: ${o.length}개`,o.map(h=>`L${h.lockrNo}`)),console.log(`  - 번호 없음: ${n.length}개`),n.length===0){alert("선택한 모든 락커에 이미 번호가 부여되어 있습니다."),me.value=!1;return}const a=Me.value==="horizontal";let i=on(n,a);et.value&&i.reverse(),Qe.value&&i.forEach(h=>h.reverse());const d=i.flat();console.log("[Number Assignment] Step 2 - 정렬 완료:",d.map((h,y)=>`${y+1}번째: ${h.id.slice(-4)}`));const r=Je.value||1;let u=r;const c=[],v=[];G.value==="odd"&&u%2===0?(u++,console.log(`[Number Assignment] 홀수 모드: 시작번호를 ${r}에서 ${u}로 조정`)):G.value==="even"&&u%2===1&&(u++,console.log(`[Number Assignment] 짝수 모드: 시작번호를 ${r}에서 ${u}로 조정`)),console.log(`[Number Assignment] Step 3 - 시작번호: ${u}, 할당할 락커 수: ${d.length}, 모드: ${G.value}`),ce.value=`락커 번호를 할당중입니다... (0/${d.length})`;let g=0;for(const h of d){for(;e.has(u);)console.log(`  - ${u}번은 이미 사용중, 다음 번호 확인`),G.value==="all"?u++:u+=2;console.log(`  - ${h.id.slice(-4)} 락커에 ${u}번 할당`),N.updateLocker(h.id,{lockrNo:u}),h.lockrCd&&c.push({lockrCd:h.lockrCd,LOCKR_NO:u}),v.push(`${g+1}. ${h.id.slice(-4)} → L${u}`),e.add(u),G.value==="all"?u++:u+=2,g++,ce.value=`락커 번호를 할당중입니다... (${g}/${d.length})`}if(console.log("[Number Assignment] Step 3 완료 - 할당 내역:",v),c.length>0)try{ce.value=`데이터베이스에 ${c.length}개 락커 번호를 저장중입니다...`,console.log(`[Number Assignment] Step 4 - DB 배치 업데이트 시작: ${c.length}개`),await xo(c),console.log("[Number Assignment] Step 4 완료 - DB 업데이트 성공"),ce.value="번호 할당이 완료되었습니다!"}catch(h){console.error("[Number Assignment] DB 업데이트 실패:",h),ce.value="데이터베이스 저장에 실패했습니다.",alert("데이터베이스 저장 중 오류가 발생했습니다. 다시 시도해주세요.");return}console.log("[Number Assignment] 전체 프로세스 완료"),console.log(`  - 총 ${n.length}개 락커에 번호 할당 완료`),console.log(`  - ${o.length}개 락커는 기존 번호 유지`);const L=Uo();L.length>0&&console.log("[Number Assignment] 번호 갭 발견:",L),setTimeout(()=>{Oe.value=!1},500)}catch(t){console.error("[Number Assignment] Assignment failed:",t),ce.value="번호 할당 중 오류가 발생했습니다.",alert("번호 할당 중 오류가 발생했습니다. 다시 시도해주세요.")}finally{me.value=!1}},sn=async()=>{if(Ae(),confirm("선택된 락커의 번호를 삭제하시겠습니까?")){const t=Array.from(_.value).map(async e=>{try{N.updateLocker(e,{lockrNo:void 0});const s=x.value.find(o=>o.id===e);s&&s.lockrCd&&await It(s.lockrCd,{LOCKR_NO:0})}catch(s){console.error(`[Number Deletion] Failed to delete number for locker ${e}:`,s)}});await Promise.all(t)}},an=()=>{console.log("[Overlap Fix] Starting overlap detection and fix...");let t=0;for(let e=0;e<x.value.length;e++){const s=x.value[e],o=W(s);for(let n=e+1;n<x.value.length;n++){const a=x.value[n],i=W(a),d=Math.min(o.x+o.width,i.x+i.width)-Math.max(o.x,i.x),r=Math.min(o.y+o.height,i.y+i.height)-Math.max(o.y,i.y),u=.5;if(d>u&&r>u){let c=a.x,v=a.y;if(Math.abs(d)<Math.abs(r))if(i.x<o.x+o.width/2){const y=Math.max(Math.abs(d)+4,4);c=a.x-y}else{const y=Math.max(Math.abs(d)+4,4);c=a.x+y}else if(i.y<o.y+o.height/2){const y=Math.max(Math.abs(r)+4,4);v=a.y-y}else{const y=Math.max(Math.abs(r)+4,4);v=a.y+y}c=lt(c),v=lt(v);const g=te(a);c=Math.max(0,Math.min(c,ee.value-g.width)),v=Math.max(0,Math.min(v,ue.value-g.height));const L=a.x,h=a.y;N.updateLocker(a.id,{x:c,y:v}),t++,console.log(`[Overlap Fix] Moved ${a.id} from (${L}, ${h}) to (${c}, ${v})`)}}}return t>0?console.log(`[Overlap Fix] Fixed ${t} overlapping lockers`):console.log("[Overlap Fix] No overlaps detected"),t},W=t=>{let e,s;if(t.type||t.id){const h=te(t);e=h.width,s=h.height}else e=t.width,s=t.height;const o=(t.rotation||0)*Math.PI/180;if(o===0)return{x:t.x,y:t.y,width:e,height:s,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s};const n=e/2,a=s/2,i=Math.cos(o),d=Math.sin(o),u=[{x:0,y:0},{x:e,y:0},{x:e,y:s},{x:0,y:s}].map(h=>{const y=h.x-n,k=h.y-a,f=y*i-k*d,w=y*d+k*i;return{x:t.x+n+f,y:t.y+a+w}}),c=Math.min(...u.map(h=>h.x)),v=Math.max(...u.map(h=>h.x)),g=Math.min(...u.map(h=>h.y)),L=Math.max(...u.map(h=>h.y));return{x:c,y:g,width:v-c,height:L-g,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s}},lt=(t,e=20)=>Math.round(t/e)*e,ln=(t,e,s,o,n,a=0)=>{const r=W({x:t,y:e,width:s,height:o,rotation:a});let u=t,c=e,v=!1;console.log("=== SNAP PRIORITY DEBUG ==="),console.log("Checking corner snap first (priority 1)");for(const g of x.value){if(g.id===n)continue;const L=W(g),h=L.x,y=L.y,k=L.width,f=L.height,w=[{existingX:h+k,existingY:y+f,dragX:r.x,dragY:r.y,type:"corner-bottom-right-to-top-left"},{existingX:h,existingY:y+f,dragX:r.x+r.width,dragY:r.y,type:"corner-bottom-left-to-top-right"},{existingX:h+k,existingY:y,dragX:r.x,dragY:r.y+r.height,type:"corner-top-right-to-bottom-left"},{existingX:h,existingY:y,dragX:r.x+r.width,dragY:r.y+r.height,type:"corner-top-left-to-bottom-right"}];for(const $ of w){const O=Math.sqrt(Math.pow($.existingX-$.dragX,2)+Math.pow($.existingY-$.dragY,2));if(O<20){console.log(`[CORNER SNAP] ${$.type}, distance: ${O.toFixed(1)}`),u=t+($.existingX-$.dragX),c=e+($.existingY-$.dragY),v=!0;break}}if(v){console.log("Corner snap succeeded - skipping face-to-face snap");break}if(console.log("No corner snap - checking face-to-face snap (priority 2)"),Math.abs(h+k-r.x)<20&&!v){u=t+(h+k-r.x);const $=Math.abs(r.y-y),O=Math.abs(r.y+r.height-(y+f));$<20?c=e+(y-r.y):O<20&&(c=e+(y+f-(r.y+r.height))),v=!0,console.log("[FACE SNAP] Right snap applied");continue}if(Math.abs(h-(r.x+r.width))<20&&!v){u=t+(h-(r.x+r.width));const $=Math.abs(r.y-y),O=Math.abs(r.y+r.height-(y+f));$<20?c=e+(y-r.y):O<20&&(c=e+(y+f-(r.y+r.height))),v=!0,console.log("[FACE SNAP] Left snap applied");continue}if(Math.abs(y+f-r.y)<20&&!v){c=e+(y+f-r.y);const $=Math.abs(r.x-h),O=Math.abs(r.x+r.width-(h+k));$<20?u=t+(h-r.x):O<20&&(u=t+(h+k-(r.x+r.width))),v=!0,console.log("[FACE SNAP] Bottom snap applied");continue}if(Math.abs(y-(r.y+r.height))<20&&!v){c=e+(y-(r.y+r.height));const $=Math.abs(r.x-h),O=Math.abs(r.x+r.width-(h+k));$<20?u=t+(h-r.x):O<20&&(u=t+(h+k-(r.x+r.width))),v=!0,console.log("[FACE SNAP] Top snap applied");continue}}return console.log("Final result: snapped =",v),{x:u,y:c}},oo=(t,e,s,o,n=null,a=0,i=!1)=>{const d=W({x:t,y:e,width:s,height:o,rotation:a});return x.value.some(r=>{if(r.id===n||F.value&&_.value.has(r.id))return!1;const u=W(r),c=Math.min(d.x+d.width,u.x+u.width)-Math.max(d.x,u.x),v=Math.min(d.y+d.height,u.y+u.height)-Math.max(d.y,u.y),g=.5,L=c>g&&v>g;return L&&console.log("[COLLISION] Detected with",r.id,"- overlap:",`(${c.toFixed(1)}, ${v.toFixed(1)})`,"tolerance:",g),L})},rn=()=>{console.log("[TEST] Creating test locker data with Adjacent/Connected thresholds..."),console.log("[TEST] ADJACENT: ≤30px + same direction, CONNECTED: 40-43px (any direction)");const t=[{id:"test-L1",number:"L1",x:100,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L2",number:"L2",x:165,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L3",number:"L3",x:230,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L4",number:"L4",x:312,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L5",number:"L5",x:377,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L6",number:"L6",x:442,y:100,width:40,height:60,rotation:90,color:"#BD10E0"}];return console.log("[TEST] Expected result: ALL in 1 major group (connected through L3↔L4)"),console.log("[TEST] Expected minor groups: [L1,L2,L3] (adjacent, 0°), [L4,L5,L6] (adjacent, 90°)"),console.log("[TEST] Key distances:"),console.log("[TEST]   L1↔L2: 25px (adjacent, same dir)"),console.log("[TEST]   L2↔L3: 25px (adjacent, same dir)"),console.log("[TEST]   L3↔L4: 42px (connected, diff dir)"),console.log("[TEST]   L4↔L5: 25px (adjacent, same dir)"),console.log("[TEST]   L5↔L6: 25px (adjacent, same dir)"),t},cn=()=>{console.log("=== TESTING WITH KNOWN DATA ===");const t=[...x.value];x.value=rn();const e=so();return x.value=t,console.log("=== TEST COMPLETE ==="),e},rt=t=>{const e=t.x||t.left||0,s=t.y||t.top||0,o=t.width||60,n=t.height||t.depth||40,a=(t.rotation||0)*Math.PI/180,i=e+o/2,d=s+n/2;return[{x:-o/2,y:-n/2},{x:o/2,y:-n/2},{x:o/2,y:n/2},{x:-o/2,y:n/2}].map(u=>({x:i+u.x*Math.cos(a)-u.y*Math.sin(a),y:d+u.x*Math.sin(a)+u.y*Math.cos(a)}))},Ct=(t,e)=>{const s=rt(t),o=rt(e);let n=1/0;for(const a of s)for(const i of o){const d=Math.sqrt(Math.pow(a.x-i.x,2)+Math.pow(a.y-i.y,2));n=Math.min(n,d)}return n},no=(t,e,s)=>{const o=rt(t),n=rt(e);let a=0;for(const i of o)for(const d of n)Math.sqrt(Math.pow(i.x-d.x,2)+Math.pow(i.y-d.y,2))<s&&a++;return a},kt=(t,e)=>{const s=no(t,e,uo),o=Xe(t.rotation||0),n=Xe(e.rotation||0),a=o===n;return s>=2&&a},Mt=(t,e)=>{const s=no(t,e,uo);if(s>=1)return!0;if(s>=2){const o=Xe(t.rotation||0),n=Xe(e.rotation||0);return o!==n}return!1},so=t=>{const e=[],s=new Set,o=t||x.value;return o.forEach(n=>{console.log(`  ${n.number||n.id}: x=${n.x}, y=${n.y}, width=${n.width}, height=${n.height||n.depth}, rotation=${n.rotation||0}°`)}),o.forEach(n=>{if(s.has(n.id))return;const a=[n];s.add(n.id);const i=[n];for(;i.length>0;){const d=i.shift();o.forEach(r=>{if(s.has(r.id))return;const u=kt(d,r),c=Mt(d,r);(u||c)&&(a.push(r),s.add(r.id),i.push(r))})}e.push(a)}),e.forEach((n,a)=>{console.log(`  Group ${a+1}: ${n.map(i=>i.number||i.id).join(", ")}`)}),e},dn=async t=>{try{const s={LOCKR_KND_CD:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,LOCKR_KND_NM:t.name,X:0,Y:0,WIDTH:ee.value,HEIGHT:ue.value,COLOR:t.color||"#f0f9ff"};await yo(s);const o=ye.value.find(n=>n.LOCKR_KND_NM===t.name);o&&Pe(o),U.value=!1}catch(e){console.error("Failed to save zone:",e),alert("Failed to save zone. Please try again.")}},un=async t=>{var e;try{const s={id:`locker-${Date.now()}`,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:`custom-${Date.now()}`,zoneId:((e=V.value)==null?void 0:e.id)||null,x:0,y:0,rotation:0};await Yt(s);try{const n=await fetch(`${H}/types`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LOCKR_TYPE_CD:`custom-${Date.now()}`,LOCKR_TYPE_NM:t.name,WIDTH:t.width,HEIGHT:t.height,DEPTH:t.depth,COLOR:t.color||"#3b82f6"})});n.ok?console.log("[Locker Registration] Type saved to backend successfully"):console.error("Failed to save locker type to backend:",await n.text())}catch(n){console.error("Error saving locker type to backend:",n)}const o={id:s.id,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:s.type};xe.value.push(o),ke.value=!1,console.log("[Locker Registration] New locker saved:",{id:s.id,name:s.name,dimensions:{width:s.width,depth:s.depth,height:s.height},type:s.type})}catch(s){console.error("Failed to save locker:",s),alert("Failed to save locker. Please try again.")}},ct=(t,e)=>{if(!C.value)return;const s=Math.max(0,Math.min(C.value.x+t,ee.value-C.value.width)),o=Math.max(0,Math.min(C.value.y+e,ue.value-C.value.height));N.updateLocker(C.value.id,{x:s,y:o})},Et=t=>{(t.ctrlKey||t.metaKey)&&(Q.value=!0);const e=t.target;if(e.tagName==="INPUT"||e.tagName==="TEXTAREA"){console.log("[Keyboard] Ignored - typing in input field");return}if(ke.value||U.value){console.log("[Keyboard] Ignored - modal is open");return}if((t.ctrlKey||t.metaKey)&&t.shiftKey&&t.key==="F"){t.preventDefault();const s=an();s>0?(console.log(`[Keyboard] Fixed ${s} overlapping lockers`),alert(`Fixed ${s} overlapping lockers`)):(console.log("[Keyboard] No overlaps detected"),alert("No overlapping lockers found"));return}if((t.ctrlKey||t.metaKey)&&t.key==="a"){t.preventDefault(),x.value.forEach(s=>{_.value.add(s.id)}),x.value.length>0&&(C.value=x.value[0]),console.log("[Multi-Select] Selected all lockers");return}if(t.key==="r"||t.key==="R"){t.preventDefault(),C.value;return}if((t.ctrlKey||t.metaKey)&&t.key==="c"){if(p.value==="front"){console.log("[Copy] Disabled in front view mode");return}t.preventDefault(),_.value.size>0?(Le.value=Array.from(_.value).map(s=>{const o=x.value.find(n=>n.id===s);return o?{...o}:null}).filter(Boolean),console.log("[Multi-Select] Copied",Le.value.length,"lockers")):C.value&&(Le.value=[{...C.value}],console.log("[Copy] Locker copied:",C.value.id));return}if((t.ctrlKey||t.metaKey)&&t.key==="v"&&Le.value&&Le.value.length>0&&V.value){if(p.value==="front"){console.log("[Paste] Disabled in front view mode");return}t.preventDefault(),_.value.clear(),Le.value.forEach((s,o)=>{const n={...s,id:`locker-${Date.now()}-${Math.random()}`,number:tn(),x:s.x+20,y:s.y+20,zoneId:V.value.id},a=N.addLocker(n);_.value.add(a.id),o===0&&(C.value=a)}),console.log("[Multi-Select] Pasted",Le.value.length,"lockers");return}if((t.key==="Delete"||t.key==="Backspace")&&(C.value||_.value.size>0)&&(t.preventDefault(),eo()),(t.key==="g"||t.key==="G")&&(t.preventDefault(),Ie.value=!Ie.value,console.log(`[Alignment] Guides ${Ie.value?"ON":"OFF"}`)),t.ctrlKey&&t.key==="z"&&(t.preventDefault(),N.undo()),t.ctrlKey&&t.key==="y"&&(t.preventDefault(),N.redo()),t.key==="Escape"&&(_.value.clear(),C.value=null,N.selectLocker(null)),C.value){const s=t.shiftKey?20:1;t.key==="ArrowLeft"?(t.preventDefault(),ct(-s,0)):t.key==="ArrowRight"?(t.preventDefault(),ct(s,0)):t.key==="ArrowUp"?(t.preventDefault(),ct(0,-s)):t.key==="ArrowDown"&&(t.preventDefault(),ct(0,s))}};Ue(()=>x.value,t=>{if(C.value){const e=t.find(s=>s.id===C.value.id);e&&(C.value=e)}},{deep:!0}),Ue(()=>p.value,async(t,e)=>{if(e&&t!==e){if(console.log(`[ViewMode Change] ${e} → ${t}, reloading lockers...`),await he(),t==="front"&&e==="floor")console.log("[ViewMode Change] Transitioning from floor to front - recalculating positions..."),fe(()=>{try{$e(),console.log("[ViewMode Change] Front view transformation completed")}catch(s){console.error("[ViewMode Change] Front view transformation failed:",s),Wt()}});else if(t==="front"&&e==="front"){console.log("[ViewMode Change] Zone change in front view - checking for missing coordinates...");const s=x.value.filter(o=>o.frontViewX===null||o.frontViewX===void 0||o.frontViewY===null||o.frontViewY===void 0);s.length>0?(console.log(`[ViewMode Change] Found ${s.length} lockers with missing front view coordinates`),console.log("[ViewMode Change] Missing coordinates for lockers:",s.map(o=>o.number).join(", ")),console.log("[ViewMode Change] Recalculating positions for ALL lockers in zone using grouping logic"),fe(()=>{try{$e(),console.log("[ViewMode Change] Zone-wide recalculation completed")}catch(o){console.error("[ViewMode Change] Zone-wide recalculation failed:",o)}})):console.log("[ViewMode Change] All lockers have saved positions - using DB coordinates")}}else e||console.log("[ViewMode Watcher] Initial mount - skipping reload (onMounted will handle it)")});const hn=z(()=>Re.value||F.value?"grabbing":Ye.value?"crosshair":Q.value&&_.value.size>0?"copy":_.value.size>0?"move":"default"),fn=z(()=>{const t=se/I.value,e=pe/I.value,s=K.value.x,o=K.value.y;return`${s} ${o} ${t} ${e}`});Ue(_,t=>{},{immediate:!0,deep:!0}),Ue(nt,t=>{},{deep:!0}),yn(async()=>{console.log("Component mounted, loading data..."),p.value="floor",console.log("[onMounted] Initial view mode set to:",p.value),we.value=!0,Ve.value=!0;try{if(await Promise.all([xt(),Vt()]),console.log("[onMounted] About to load lockers with view mode:",p.value),await he(),await fe(),we.value=!1,Ve.value=!1,console.log("All data loading completed"),p.value==="floor"&&x.value.length>0&&setTimeout(()=>{Fe()},100),p.value==="front"){const t=x.value.filter(e=>e.frontViewX===null||e.frontViewX===void 0||e.frontViewY===null||e.frontViewY===void 0);t.length>0&&(console.log(`[onMounted] Found ${t.length} lockers with missing front view coordinates`),console.log("[onMounted] Auto-calculating positions for lockers:",t.map(e=>e.number).join(", ")),fe(()=>{try{$e(),console.log("[onMounted] Auto-calculation completed")}catch(e){console.error("[onMounted] Auto-calculation failed:",e)}}))}ye.value.length>0&&!V.value&&(Pe(ye.value[0]),console.log("[Data Loading] Auto-selected first zone:",ye.value[0].name))}catch(t){console.error("Error loading data:",t),we.value=!1,Ve.value=!1}window.addEventListener("resize",mt),document.addEventListener("keydown",Et),document.addEventListener("keyup",$t),document.addEventListener("click",Ae),N.zones.length>0&&Pe(N.zones[0]),document.addEventListener("keydown",Et),document.addEventListener("keyup",$t)});const $t=t=>{!t.ctrlKey&&!t.metaKey&&(Q.value=!1)},vn=t=>{p.value==="front"&&(Ce.value=t.lockrNo!==void 0&&t.lockrNo!==null?t.lockrNo:t.lockrLabel||t.number||"",J.value={userName:t.userName||"",userPhone:t.userPhone||"",startDate:t.startDate||"",endDate:t.endDate||"",usage:t.usage||""},le.value=!0)},gn=()=>{le.value=!1,Ce.value="",J.value=null},pn=t=>{console.log("락커 배정 데이터:",t)};return xn(()=>{document.removeEventListener("keydown",Et),document.removeEventListener("keyup",$t),document.removeEventListener("click",Ae),window.removeEventListener("resize",mt)}),(t,e)=>{var s;return E(),A("div",jn,[we.value||Ve.value?(E(),A("div",Gn,e[33]||(e[33]=[l("div",{class:"loading-spinner"},[l("div",{class:"spinner"}),l("p",null,"Loading locker data...")],-1)]))):(E(),A("div",Un,[l("div",Wn,[Y("",!0),l("main",Zn,[l("div",qn,[l("div",Jn,[(E(!0),A(ve,null,be(ye.value,o=>{var n,a;return E(),A("button",{key:o.id,class:ze(["zone-tab",{active:((n=V.value)==null?void 0:n.id)===o.id}]),onClick:i=>Pe(o),onContextmenu:i=>To(i,o)},[q(R(o.name)+" ",1),((a=V.value)==null?void 0:a.id)===o.id?(E(),A("span",es)):Y("",!0)],42,Qn)}),128))]),l("div",ts,[l("button",{class:"zone-add-btn",onClick:e[1]||(e[1]=o=>U.value=!0)}," + 구역 추가 "),l("div",os,[l("button",{class:ze(["mode-btn",{active:p.value==="floor"}]),onClick:e[2]||(e[2]=o=>Gt("floor")),title:"평면배치모드 (P)"},e[39]||(e[39]=[ht('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-56768b3e><rect x="3" y="3" width="18" height="18" rx="2" data-v-56768b3e></rect><rect x="7" y="7" width="4" height="4" data-v-56768b3e></rect><rect x="13" y="7" width="4" height="4" data-v-56768b3e></rect><rect x="7" y="13" width="4" height="4" data-v-56768b3e></rect><rect x="13" y="13" width="4" height="4" data-v-56768b3e></rect></svg><span data-v-56768b3e>평면배치</span>',2)]),2),l("button",{class:ze(["mode-btn",{active:p.value==="front"}]),onClick:e[3]||(e[3]=o=>Gt("front")),title:"정면배치모드 (F)"},e[40]||(e[40]=[ht('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-56768b3e><rect x="3" y="3" width="18" height="18" rx="2" data-v-56768b3e></rect><line x1="3" y1="15" x2="21" y2="15" stroke-dasharray="2 2" data-v-56768b3e></line><rect x="7" y="7" width="4" height="6" data-v-56768b3e></rect><rect x="13" y="7" width="4" height="6" data-v-56768b3e></rect></svg><span data-v-56768b3e>정면배치</span>',2)]),2),l("button",{class:"mode-btn",onClick:en,title:"그룹핑 결과 확인"},e[41]||(e[41]=[l("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("circle",{cx:"12",cy:"12",r:"3"}),l("path",{d:"M12 1v6m0 6v6"}),l("path",{d:"m21 12-6-3-6 3-6-3"})],-1),l("span",null,"그룹핑 확인",-1)])),p.value==="floor"||p.value==="front"?(E(),A("div",ns,[l("button",{class:"zoom-btn",onClick:Fe,title:"모든 락커가 화면에 맞춤 (클릭)"},[e[42]||(e[42]=l("svg",{width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("rect",{x:"3",y:"3",width:"18",height:"18",rx:"2"}),l("path",{d:"M7 7h.01M7 12h.01M7 17h.01M12 7h.01M12 12h.01M12 17h.01M17 7h.01M17 12h.01M17 17h.01"})],-1)),l("span",null,R(Math.round(I.value*100))+"%",1)]),e[43]||(e[43]=l("div",{class:"zoom-hints",style:{display:"none"}},[l("span",{class:"hint"},"Ctrl+스크롤: 줌"),l("span",{class:"hint"},"휠클릭+드래그: 이동")],-1))])):Y("",!0),l("button",{class:"mode-btn debug-btn",onClick:e[4]||(e[4]=o=>qe.value=!0),title:"락커 데이터 상세 확인",style:{display:"none"}},e[44]||(e[44]=[l("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("path",{d:"m9 12 2 2 4-4"}),l("path",{d:"M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"}),l("path",{d:"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"})],-1),l("span",null,"디버그 정보",-1)]))])])]),l("div",ss,[(E(),A("svg",{ref_key:"canvasRef",ref:ie,class:"canvas",width:"100%",height:"100%",viewBox:fn.value,style:dt({cursor:hn.value,margin:0,padding:0}),preserveAspectRatio:"xMidYMid meet",onWheel:ae(_o,["prevent"]),onMousedown:Oo,onMousemove:Ro,onMouseup:zt,onMouseleave:zt},[e[46]||(e[46]=ht('<defs data-v-56768b3e><pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse" data-v-56768b3e><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e5e5e5" stroke-width="0.5" data-v-56768b3e></path></pattern><filter id="buttonShadow" x="-50%" y="-50%" width="200%" height="200%" data-v-56768b3e><feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" data-v-56768b3e></feDropShadow></filter></defs><rect width="100%" height="100%" fill="url(#grid)" class="canvas-background" data-v-56768b3e></rect>',2)),V.value?(E(),A("rect",{key:0,x:"0",y:"0",width:ee.value,height:ue.value,fill:"none",stroke:"black","stroke-width":"1"},null,8,is)):Y("",!0),p.value==="front"?(E(),A("g",ls,[l("line",{x1:0,y1:ge,x2:Ge,y2:ge,stroke:"#94a3b8","stroke-width":"2","stroke-dasharray":"10,5"}),l("text",{x:K.value.x+20/I.value,y:ge+20,fill:"#64748b","font-size":12/I.value,"font-weight":"500"}," 바닥선 ",8,rs),l("text",{x:K.value.x+(se-80)/I.value,y:ge+20,fill:"#64748b","font-size":12/I.value,"font-weight":"500","text-anchor":"end"}," 바닥선 ",8,cs)])):Y("",!0),(E(!0),A(ve,null,be($o.value,o=>(E(),Be(En,{key:o.id,locker:o,"is-selected":!1,"is-multi-selected":!1,"should-hide-individual-outline":Ao.value.has(o.id),"is-dragging":!1,"adjacent-sides":ko(o.id),"view-mode":p.value,"is-transitioning-to-floor":Lt.value,"show-number":!0,"show-rotate-handle":!1,"zoom-level":I.value,"is-management-page":!0,"child-lockers":Mo.value[o.id]||[],onClick:n=>vn(o)},null,8,["locker","should-hide-individual-outline","adjacent-sides","view-mode","is-transitioning-to-floor","zoom-level","child-lockers","onClick"]))),128)),nt.value.length>0&&!F.value?(E(),A("g",ds,[(E(!0),A(ve,null,be(nt.value.filter(o=>o.length>1),(o,n)=>{var a,i,d,r;return E(),A("rect",{key:`group-${n}`,x:(((a=ot(o))==null?void 0:a.minX)||0)-5,y:(((i=ot(o))==null?void 0:i.minY)||0)-5,width:(((d=ot(o))==null?void 0:d.width)||0)+10,height:(((r=ot(o))==null?void 0:r.height)||0)+10,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"unified-selection-outline","pointer-events":"none"},e[45]||(e[45]=[l("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,us)}),128))])):Y("",!0),C.value&&!F.value&&D.value?(E(),A("g",hs,[l("g",{transform:`translate(${Ft().x}, ${Ft().y}) rotate(${C.value.rotation||0}, ${C.value.width/2}, ${C.value.height/2})`},null,8,fs)])):Y("",!0),Ie.value?(E(),A("g",vs,[(E(!0),A(ve,null,be(Ht.value,o=>(E(),A("line",{key:`h-${o.position}`,x1:0,y1:o.position,x2:ee.value,y2:o.position,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,gs))),128)),(E(!0),A(ve,null,be(Bt.value,o=>(E(),A("line",{key:`v-${o.position}`,x1:o.position,y1:0,x2:o.position,y2:ue.value,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,ps))),128))])):Y("",!0),Ye.value&&P.value.x!=null&&P.value.y!=null&&X.value.x!=null&&X.value.y!=null&&Math.abs((X.value.x||0)-(P.value.x||0))>5?(E(),A("rect",{key:5,x:Math.min(P.value.x||0,X.value.x||0),y:Math.min(P.value.y||0,X.value.y||0),width:Math.abs((X.value.x||0)-(P.value.x||0)),height:Math.abs((X.value.y||0)-(P.value.y||0)),fill:"rgba(0, 122, 255, 0.1)",stroke:"#007AFF","stroke-width":"1","stroke-dasharray":"5 5","pointer-events":"none",class:"selection-box"},null,8,ms)):Y("",!0)],44,as))])])])])),U.value?(E(),Be(bn,{key:2,onClose:e[5]||(e[5]=o=>U.value=!1),onSave:dn})):Y("",!0),ke.value?(E(),Be(Cn,{key:3,onClose:e[6]||(e[6]=o=>ke.value=!1),onSave:un})):Y("",!0),St.value?(E(),A("div",{key:4,style:dt({position:"fixed",left:We.value.x+"px",top:We.value.y+"px",zIndex:1e3}),class:"context-menu",onClick:e[7]||(e[7]=ae(()=>{},["stop"]))},[p.value==="front"?(E(),A(ve,{key:0},[l("div",{class:"context-menu-item",onClick:Zo},e[47]||(e[47]=[l("i",{class:"fas fa-layer-group"},null,-1),q(" 단수 입력 ",-1)])),l("div",{class:"context-menu-item",onClick:Qo},e[48]||(e[48]=[l("i",{class:"fas fa-sort-numeric-up"},null,-1),q(" 번호 부여 ",-1)])),l("div",{class:"context-menu-item",onClick:sn},e[49]||(e[49]=[l("i",{class:"fas fa-eraser"},null,-1),q(" 번호 삭제 ",-1)]))],64)):Y("",!0),l("div",{class:"context-menu-item",onClick:Wo},e[50]||(e[50]=[l("i",{class:"fas fa-trash"},null,-1),q(" 락커 삭제 ",-1)]))],4)):Y("",!0),_e.value?(E(),A("div",{key:5,class:"modal-overlay",onClick:Vo},[l("div",{class:"modal-content",onClick:e[10]||(e[10]=ae(()=>{},["stop"]))},[e[52]||(e[52]=l("h3",null,"단수 입력",-1)),l("div",ys,[e[51]||(e[51]=l("label",null,"단수:",-1)),j(l("input",{"onUpdate:modelValue":e[8]||(e[8]=o=>re.value=o),type:"number",min:"1",max:"9",placeholder:"1-9 사이 입력",class:"form-control",onInput:Jo},null,544),[[ft,re.value,void 0,{number:!0}]])]),l("div",xs,[l("button",{class:"btn btn-secondary",onClick:e[9]||(e[9]=o=>_e.value=!1)},"취소"),l("button",{class:"btn btn-primary",onClick:qo},"확인")])])])):Y("",!0),Oe.value?(E(),A("div",{key:6,class:"modal-overlay",onClick:Yo},[l("div",{class:"modal-content number-assign-modal",onClick:e[20]||(e[20]=ae(()=>{},["stop"]))},[e[65]||(e[65]=l("h3",null,"번호 부여",-1)),l("div",ws,[e[56]||(e[56]=l("div",{style:{display:"flex","justify-content":"space-between","margin-bottom":"10px"}},[l("label",null,"시작번호:"),l("label",{style:{"margin-right":"100px"}},"번호생성옵션:")],-1)),l("div",Ls,[j(l("input",{"onUpdate:modelValue":e[11]||(e[11]=o=>Je.value=o),type:"number",min:1,placeholder:"시작 번호",class:"form-control number-input",style:{width:"120px"}},null,512),[[ft,Je.value,void 0,{number:!0}]]),l("div",bs,[l("label",Cs,[j(l("input",{type:"radio","onUpdate:modelValue":e[12]||(e[12]=o=>G.value=o),value:"all"},null,512),[[je,G.value]]),e[53]||(e[53]=l("span",null,"전체",-1))]),l("label",ks,[j(l("input",{type:"radio","onUpdate:modelValue":e[13]||(e[13]=o=>G.value=o),value:"odd"},null,512),[[je,G.value]]),e[54]||(e[54]=l("span",null,"홀수",-1))]),l("label",Ms,[j(l("input",{type:"radio","onUpdate:modelValue":e[14]||(e[14]=o=>G.value=o),value:"even"},null,512),[[je,G.value]]),e[55]||(e[55]=l("span",null,"짝수",-1))])])])]),l("div",Es,[e[59]||(e[59]=l("div",{class:"form-labels-row"},[l("label",{class:"section-label"},"생성방향:")],-1)),l("div",$s,[l("div",As,[l("label",Ds,[j(l("input",{type:"radio","onUpdate:modelValue":e[15]||(e[15]=o=>Me.value=o),value:"horizontal"},null,512),[[je,Me.value]]),e[57]||(e[57]=l("span",null,"가로",-1))]),l("label",Ts,[j(l("input",{type:"radio","onUpdate:modelValue":e[16]||(e[16]=o=>Me.value=o),value:"vertical"},null,512),[[je,Me.value]]),e[58]||(e[58]=l("span",null,"세로",-1))])])])]),l("div",Ns,[e[62]||(e[62]=l("label",{class:"section-label"},"추가옵션:",-1)),l("div",Ss,[e[60]||(e[60]=l("span",{style:{"margin-right":"8px"}},"역방향",-1)),j(l("input",{type:"checkbox","onUpdate:modelValue":e[17]||(e[17]=o=>Qe.value=o),style:{"margin-right":"30px"}},null,512),[[ao,Qe.value]]),e[61]||(e[61]=l("span",{style:{"margin-right":"8px"}},"아래에서부터",-1)),j(l("input",{type:"checkbox","onUpdate:modelValue":e[18]||(e[18]=o=>et.value=o)},null,512),[[ao,et.value]])])]),me.value?(E(),A("div",_s,[l("div",Os,[e[63]||(e[63]=l("div",{class:"loading-spinner"},null,-1)),l("span",Rs,R(ce.value),1)])])):Y("",!0),l("div",Vs,[l("button",{class:"btn btn-secondary",onClick:e[19]||(e[19]=o=>Oe.value=!1),disabled:me.value}," 취소 ",8,Ys),l("button",{class:"btn btn-primary",onClick:nn,disabled:me.value},[me.value?(E(),A("span",Ps,e[64]||(e[64]=[l("i",{class:"fas fa-spinner fa-spin"},null,-1),q(" 처리중... ",-1)]))):(E(),A("span",Fs,"번호 부여"))],8,Is)])])])):Y("",!0),Se.value?(E(),A("div",{key:7,class:"modal-overlay",onClick:e[23]||(e[23]=o=>Se.value=!1)},[l("div",{class:"modal-content grouping-popup",onClick:e[22]||(e[22]=ae(()=>{},["stop"]))},[e[66]||(e[66]=l("h3",null,"대그룹 분석 결과",-1)),l("div",Xs,[l("pre",null,R(vt.value),1)]),l("div",Ks,[l("button",{class:"btn btn-primary",onClick:e[21]||(e[21]=o=>Se.value=!1)},"확인")])])])):Y("",!0),qe.value?(E(),A("div",{key:8,class:"modal-overlay",onClick:e[27]||(e[27]=o=>qe.value=!1)},[l("div",{class:"modal-content debug-popup",onClick:e[26]||(e[26]=ae(()=>{},["stop"]))},[e[73]||(e[73]=l("h3",null,"🔍 락커 데이터 디버깅 정보",-1)),l("div",Hs,[e[71]||(e[71]=l("h4",null,"📊 전체 통계",-1)),l("div",Bs,[l("div",zs,[e[67]||(e[67]=l("span",{class:"label"},"Store 전체:",-1)),l("span",js,R(At(N).lockers.length)+"개",1)]),l("div",Gs,[e[68]||(e[68]=l("span",{class:"label"},"현재 구역:",-1)),l("span",Us,R(x.value.length)+"개",1)]),l("div",Ws,[e[69]||(e[69]=l("span",{class:"label"},"뷰모드:",-1)),l("span",Zs,R(p.value),1)]),l("div",qs,[e[70]||(e[70]=l("span",{class:"label"},"선택 구역:",-1)),l("span",Js,R(((s=V.value)==null?void 0:s.name)||"None"),1)])])]),l("div",Qs,[l("h4",null,"🏢 Store 전체 락커 ("+R(At(N).lockers.length)+"개)",1),l("div",ea,[(E(!0),A(ve,null,be(At(N).lockers,o=>(E(),A("div",{key:o.id,class:ze(["locker-item",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[l("div",ta,[l("span",oa,R(o.number),1),l("span",na,R(o.parentLockrCd?"자식":"부모"),1)]),l("div",sa,[l("span",null,"ID: "+R(o.id),1),l("span",null,"Zone: "+R(o.zoneId),1),l("span",null,"Parent: "+R(o.parentLockrCd||"None"),1),l("span",null,"Height: "+R(o.actualHeight||o.height)+"px",1)])],2))),128))])]),l("div",aa,[l("h4",null,"👁️ 현재 표시 락커 ("+R(x.value.length)+"개)",1),l("div",ia,[(E(!0),A(ve,null,be(x.value,o=>(E(),A("div",{key:o.id,class:ze(["locker-item current",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[l("div",la,[l("span",ra,R(o.number),1),l("span",ca,R(o.parentLockrCd?"자식":"부모"),1),e[72]||(e[72]=l("span",{class:"render-status"},"표시중",-1))]),l("div",da,[l("span",null,"위치: ("+R(o.x)+", "+R(o.y)+")",1),l("span",null,"크기: "+R(o.width)+"x"+R(o.height),1),l("span",null,"실제높이: "+R(o.actualHeight)+"px",1),l("span",null,"회전: "+R(o.rotation)+"°",1)])],2))),128))])]),l("div",ua,[l("button",{class:"btn btn-secondary",onClick:e[24]||(e[24]=o=>he())},"🔄 새로고침"),l("button",{class:"btn btn-primary",onClick:e[25]||(e[25]=o=>qe.value=!1)},"닫기")])])])):Y("",!0),(E(),Be(io,{to:"body"},[Ze.value?(E(),A("div",{key:0,class:"zone-context-menu",style:dt({position:"fixed",left:gt.value.x+"px",top:gt.value.y+"px",zIndex:9999}),onClick:e[30]||(e[30]=ae(()=>{},["stop"]))},[l("div",{class:"zone-context-menu-item",onClick:e[28]||(e[28]=o=>t.editZone(pt.value))},e[74]||(e[74]=[l("span",{class:"zone-context-menu-icon"},"✏️",-1),q(" 구역 수정 ",-1)])),l("div",{class:"zone-context-menu-item",onClick:e[29]||(e[29]=o=>No(pt.value))},e[75]||(e[75]=[l("span",{class:"zone-context-menu-icon"},"🗑️",-1),q(" 구역 삭제 ",-1)]))],4)):Y("",!0)])),(E(),Be(io,{to:"body"},[_t.value?(E(),A("div",{key:0,class:"context-menu",style:dt({position:"fixed",left:We.value.x+"px",top:We.value.y+"px",zIndex:9999}),onClick:e[32]||(e[32]=ae(()=>{},["stop"]))},[l("div",{class:"context-menu-item",onClick:e[31]||(e[31]=o=>So(vo.value))},e[76]||(e[76]=[l("span",{class:"context-menu-icon"},"🗑️",-1),q(" 타입 삭제 ",-1)]))],4)):Y("",!0)])),wn(zn,{"is-open":le.value,"locker-number":Ce.value,"locker-data":J.value,onClose:gn,onConfirm:pn},null,8,["is-open","locker-number","locker-data"])])}}}),pa=fo(ha,[["__scopeId","data-v-56768b3e"]]);export{pa as default};
