import{d as In,r as m,c as ae,w as vt,o as Vn,n as le,a as Xn,b as T,e as M,f as We,g as V,h as u,F as re,i as de,j as se,k as Re,t as _,l as ue,m as Ft,p as gt,q as he,v as Lo,s as bo,u as Ze,x as Co,y as Kt,T as Eo,_ as Pn}from"./index.js";import{u as Fn,L as Kn,Z as Hn,a as zn,i as Bn,g as jn}from"./LockerRegistrationModal.js";const Gn={class:"locker-placement"},Un={key:0,class:"loading-overlay"},Wn={key:1,class:"main-content"},Zn={class:"container"},qn={class:"sidebar"},Jn={key:0,class:"loading-state"},Qn={key:1,class:"empty-state"},es={key:2,class:"locker-types"},ts=["onClick","onDblclick","onContextmenu"],os={class:"type-visual"},ns=["width","height","viewBox"],ss=["width","height","fill"],is=["y1","x2","y2","stroke"],as={class:"type-info"},ls={class:"type-name"},rs={class:"type-size"},cs=["onClick"],ds={key:3,class:"deleted-types-section"},us=["onClick"],hs={class:"canvas-area"},fs={class:"zone-tabs"},vs={class:"zone-tab-group"},gs=["onClick","onContextmenu"],ps={key:0,class:"tab-indicator"},ms={class:"zone-controls"},ys={class:"mode-toggle-inline"},xs={key:0,class:"zoom-controls"},ws={class:"canvas-wrapper"},Ls=["viewBox"],bs=["width","height"],Cs={key:1},Es=["x","y","font-size"],Ms=["x","y","font-size"],ks={key:2,class:"unified-outlines"},As=["x","y","width","height"],Ts={key:3},Ds=["transform"],$s={key:4,class:"alignment-guides"},Ns=["y1","x2","y2"],_s=["x1","x2","y2"],Ss=["x","y","width","height"],Rs={key:5,class:"modal-overlay"},Os={class:"form-group"},Ys={class:"modal-buttons"},Is={key:6,class:"modal-overlay"},Vs={class:"form-group"},Xs={style:{display:"flex","justify-content":"space-between","align-items":"flex-start"}},Ps={class:"radio-group-horizontal",style:{flex:"1","margin-left":"20px"}},Fs={class:"radio-label"},Ks={class:"radio-label"},Hs={class:"radio-label"},zs={class:"form-section"},Bs={class:"form-options-row"},js={class:"radio-group-horizontal"},Gs={class:"radio-label"},Us={class:"radio-label"},Ws={class:"form-section"},Zs={style:{"margin-top":"10px"}},qs={style:{"margin-bottom":"8px"}},Js={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},Qs={style:{"font-size":"12px",color:"#666"}},ei={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},ti={style:{"font-size":"12px",color:"#666"}},oi={key:0,class:"progress-section"},ni={class:"progress-indicator"},si={class:"progress-text"},ii={class:"modal-buttons"},ai=["disabled"],li=["disabled"],ri={key:0},ci={key:1},di={class:"grouping-results"},ui={class:"modal-buttons"},hi={class:"debug-section"},fi={class:"debug-stats"},vi={class:"stat-item"},gi={class:"value"},pi={class:"stat-item"},mi={class:"value"},yi={class:"stat-item"},xi={class:"value"},wi={class:"stat-item"},Li={class:"value"},bi={class:"debug-section"},Ci={class:"locker-list"},Ei={class:"locker-header"},Mi={class:"locker-name"},ki={class:"locker-type"},Ai={class:"locker-details"},Ti={class:"debug-section"},Di={class:"locker-list"},$i={class:"locker-header"},Ni={class:"locker-name"},_i={class:"locker-type"},Si={class:"locker-details"},Ri={class:"modal-buttons"},Mo=1,ko=1,we=1350,qe=3100,pt=1440,fe=1550,Le=720,Ao=5,To=55,Oi=In({__name:"LockerPlacementFigma",setup(Yi){const D=Fn(),Y=m(null),Oe=m(null),w=m(null),Do=m(!1),mt=m(null),Ye=m(!1),Ie=m(!1),P=m(!1),Je=m({x:0,y:0}),L=m("floor"),Z=m(!0),yt=m(!1),Ht=m([]),$o=m({isSelecting:!1,startX:0,startY:0,endX:0,endY:0}),Ve=m(!1),xt=m(""),wt=m(!1),Xe=m({x:0,y:0}),Qe=m(!1),Lt=m({x:0,y:0}),bt=m(null),et=m(!1),No=m({x:0,y:0}),zt=m(null),tt=m(!1),ve=m(1),Bt=m(null),jt=m(null),ot=m(!1),nt=m(!1),st=m(1),J=m("all"),ke=m("horizontal"),Ae=m(!1),Te=m(!1),be=m(!1),ge=m(""),pe=()=>L.value==="floor"?Mo:ko,Q=m(qe),ee=m(pt);m(1550),m(700);const F=m(1),Gt=Math.max(fe/qe,Le/pt),Ut=Math.min(qe/fe,pt/Le),W=m({x:0,y:0}),Pe=m(!1),it=m({x:0,y:0}),Ct=()=>{if(ye.value||Fe.value)return;const t=document.querySelector(".canvas-wrapper");if(t){const e=t.getBoundingClientRect();e.width,e.height}},_o=(t,e)=>{const s=pe();return{x:t*s,y:e*s}},So=(t,e)=>{const s=pe();return{width:t*s,height:e*s}},Ce=ae(()=>D.zones),me=m([]);m(!1);const ye=m(!0),Fe=m(!0),Wt=m(!1),Et=m(null);m(null);const U=(()=>{if(Bn()){const t=jn();return t?`${t.baseUrl}/api`:"/api"}return"http://localhost:3333/api"})(),Mt=async()=>{try{const t=await fetch(`${U}/zones`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.zones){const s=e.zones.map(o=>({id:o.LOCKR_KND_CD,name:o.LOCKR_KND_NM,x:o.X,y:o.Y,width:o.WIDTH,height:o.HEIGHT,color:o.COLOR,floor:o.FLOOR,...o}));D.zones=s}else console.warn("[API] No zones data in response:",e),D.zones=[]}catch(t){console.error("[API] Failed to load zones:",t.message),D.zones=[]}},ce=async()=>{try{const e=L.value==="floor"?`${U}/lockrs?parentOnly=true`:`${U}/lockrs`,s=await fetch(e);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const o=await s.json();if(o.lockers&&o.lockers.forEach(n=>{const a=n.PARENT_LOCKR_CD===null?"PARENT":`CHILD of ${n.PARENT_LOCKR_CD}`}),o.success&&o.lockers){const n=o.lockers.map(i=>{const a=me.value.find(v=>v.id===i.LOCKR_TYPE_CD),c=(a==null?void 0:a.width)||40,l=(a==null?void 0:a.height)||60,d=(a==null?void 0:a.depth)||40,r=i.PARENT_LOCKR_CD?`locker-${i.PARENT_LOCKR_CD}`:null;return{id:`locker-${i.LOCKR_CD}`,lockrCd:i.LOCKR_CD,number:i.LOCKR_LABEL||`L${i.LOCKR_CD}`,x:i.X!==null&&i.X!==void 0?i.X:void 0,y:i.Y!==null&&i.Y!==void 0?i.Y:void 0,width:c,height:d,depth:d,actualHeight:l,status:"available",rotation:i.ROTATION||0,zoneId:i.LOCKR_KND,typeId:i.LOCKR_TYPE_CD,type:i.LOCKR_TYPE_CD,color:a==null?void 0:a.color,compCd:i.COMP_CD,bcoffCd:i.BCOFF_CD,lockrLabel:i.LOCKR_LABEL,lockrNo:i.LOCKR_NO,lockrKnd:i.LOCKR_KND,lockrTypeCd:i.LOCKR_TYPE_CD,frontViewX:i.FRONT_VIEW_X,frontViewY:i.FRONT_VIEW_Y,frontViewNumber:i.FRONT_VIEW_NUMBER,parentLockerId:r,parentLockrCd:i.PARENT_LOCKR_CD,tierLevel:i.TIER_LEVEL,lockrStat:i.LOCKR_STAT}});D.lockers=n,D.lockers.forEach(i=>{const c=!i.parentLockrCd?"PARENT":`CHILD of ${i.parentLockrCd}`}),n.forEach(i=>{i.number==="L3"||i.number==="L4"||i.number==="L1"||i.number==="L2"||i.number})}else if(o.lockers){const n=o.lockers.map(i=>{const a=me.value.find(l=>l.id===i.LOCKR_TYPE_CD),c=(a==null?void 0:a.height)||60;return{id:`locker-${i.LOCKR_CD}`,lockrCd:i.LOCKR_CD,number:i.LOCKR_LABEL||`L${i.LOCKR_CD}`,x:i.X||0,y:i.Y||0,width:(a==null?void 0:a.width)||40,height:(a==null?void 0:a.depth)||40,depth:(a==null?void 0:a.depth)||40,actualHeight:c,status:"available",rotation:i.ROTATION||0,zoneId:i.LOCKR_KND,typeId:i.LOCKR_TYPE_CD,type:i.LOCKR_TYPE_CD,color:a==null?void 0:a.color,compCd:i.COMP_CD,bcoffCd:i.BCOFF_CD,lockrLabel:i.LOCKR_LABEL,lockrNo:i.LOCKR_NO,lockrKnd:i.LOCKR_KND,lockrTypeCd:i.LOCKR_TYPE_CD,frontViewX:i.FRONT_VIEW_X,frontViewY:i.FRONT_VIEW_Y,frontViewNumber:i.FRONT_VIEW_NUMBER,parentLockrCd:i.PARENT_LOCKR_CD,tierLevel:i.TIER_LEVEL,lockrStat:i.LOCKR_STAT}});D.lockers=n}else console.warn("[API] No lockers data in response:",o),D.lockers=[]}catch(t){console.error("[API] Failed to load lockers:",t.message),D.lockers=[]}},Zt=async()=>{try{ye.value=!0;const t=await fetch(`${U}/types`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.success){const s=(e.types||[]).map(o=>({id:o.LOCKR_TYPE_CD,name:o.LOCKR_TYPE_NM,width:o.WIDTH,height:o.HEIGHT,depth:o.DEPTH,color:o.COLOR||"#3b82f6",type:o.LOCKR_TYPE_CD}));me.value=s}}catch(t){console.error("Failed to load locker types:",t),me.value=[]}finally{ye.value=!1,Wt.value=!0}},Ro=async t=>{try{const e=await fetch(`${U}/zones`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save zone");const s=await e.json();if(s.success)return await Mt(),s}catch(e){throw console.error("[API] Zone save failed:",e),Et.value="Failed to save zone",e}},kt=async t=>{try{const e=await fetch(`${U}/lockrs`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save locker");const s=await e.json();if(s.success)return await ce(),s}catch(e){throw console.error("[API] Locker save failed:",e),Et.value="Failed to save locker",e}},qt=async(t,e)=>{try{const s=await fetch(`${U}/lockrs/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!s.ok){const n=await s.text();throw new Error(`Failed to update locker placement: ${s.status} - ${n}`)}const o=await s.json();if(o.success)return o}catch(s){throw console.error("[API] Locker placement update failed:",s),Et.value="Failed to update locker placement",s}},Oo=async t=>{try{const e=await fetch(`${U}/lockrs/batch-numbers`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({updates:t})});if(!e.ok){const o=await e.text();throw new Error(`Failed to batch update locker numbers: ${e.status} - ${o}`)}const s=await e.json();if(s.success)return s;throw new Error(`Batch update failed: ${s.message||"Unknown error"}`)}catch(e){throw console.error("[API] Batch locker number update failed:",e),e}},Yo=async t=>{try{const e=t.map(s=>{var a;const o=g.value.find(c=>c.id===s.id),n=Math.round(s.x*100)/100,i=Math.round(s.y*100)/100;if(o&&o.lockrCd)return qt(o.lockrCd,{X:n,Y:i});if(o){const c={LOCKR_KND:(a=Y.value)==null?void 0:a.id,LOCKR_TYPE_CD:o.type||"1",X:n,Y:i,LOCKR_LABEL:o.number,ROTATION:o.rotation||0,LOCKR_STAT:"00"};return kt(c).then(l=>(l&&l.lockrCd&&(o.lockrCd=l.lockrCd),l))}});await Promise.all(e)}catch(e){console.error("[API] Failed to save some locker positions:",e)}},Ke=m([]),at=t=>{if(t.length<=1)return null;const e=2,s=t.map(c=>{const l=L.value==="front"?c.actualHeight||c.height||60:c.depth||c.height||40,d=L.value==="front"&&c.frontViewX!==void 0?c.frontViewX:c.x,r=L.value==="front"&&c.frontViewY!==void 0?c.frontViewY:c.y;return{left:d,right:d+c.width*e,top:r,bottom:r+l*e,locker:c}}),o=Math.min(...s.map(c=>c.left)),n=Math.max(...s.map(c=>c.right)),i=Math.min(...s.map(c=>c.top)),a=Math.max(...s.map(c=>c.bottom));return{minX:o,maxX:n,minY:i,maxY:a,width:n-o,height:a-i}},Io=(t,e,s=5)=>{const n=L.value==="front"?t.actualHeight||t.height||60:t.depth||t.height||40,i=L.value==="front"?e.actualHeight||e.height||60:e.depth||e.height||40,a=A=>L.value==="front"?{x:A.frontViewX!==void 0?A.frontViewX:A.x,y:A.frontViewY!==void 0?A.frontViewY:A.y}:{x:A.x,y:A.y},c=a(t),l=a(e),d={left:c.x,right:c.x+t.width*2,top:c.y,bottom:c.y+n*2},r={left:l.x,right:l.x+e.width*2,top:l.y,bottom:l.y+i*2},h=s,v=Math.min(Math.abs(d.right-r.left),Math.abs(r.right-d.left)),f=Math.min(Math.abs(d.bottom-r.top),Math.abs(r.bottom-d.top))<=h,b=d.left<r.right&&r.left<d.right,N=v<=h,p=d.top<r.bottom&&r.top<d.bottom;return f&&b||N&&p},Vo=t=>{const e=[],s=new Set,o=(n,i)=>{s.has(n.id)||(s.add(n.id),i.push(n),t.forEach(a=>{!s.has(a.id)&&Io(n,a)&&o(a,i)}))};return t.forEach(n=>{if(!s.has(n.id)){const i=[];o(n,i),e.push(i)}}),e},Xo=t=>{if(!y.value.has(t))return[];const e=g.value.find(d=>d.id===t);if(!e)return[];const s=[],o=10,n=ie(e),i=(e.rotation||0)%360,a={0:{top:"top",right:"right",bottom:"bottom",left:"left"},90:{top:"left",right:"top",bottom:"right",left:"bottom"},180:{top:"bottom",right:"left",bottom:"top",left:"right"},270:{top:"right",right:"bottom",bottom:"left",left:"top"}},c=Math.round(i/90)*90%360,l=a[c]||a[0];return Jt.value.forEach(d=>{if(d.id===t)return;const r=ie(d);P.value&&console.log(`[Adjacent Check] ${t} vs ${d.id}:`,{locker:{id:t,rotation:i,bounds:n},other:{id:d.id,rotation:d.rotation,bounds:r},mapping:l}),Math.abs(n.y-(r.y+r.height))<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&(s.push(l.top),P.value&&console.log("  -> TOP adjacent (physical top touches other's bottom)")),Math.abs(n.y+n.height-r.y)<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&s.push(l.bottom),Math.abs(n.x-(r.x+r.width))<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.left),Math.abs(n.x+n.width-r.x)<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.right)}),[...new Set(s)]},At=ae(()=>me.value.filter(t=>!Ke.value.includes(t.id))),g=ae(()=>{if(!Y.value)return[];let t=D.lockers.filter(e=>e.zoneId===Y.value.id);return L.value==="floor"&&(t=t.filter(e=>!e.parentLockrCd)),t.forEach(e=>{!e.parentLockrCd||`${e.parentLockrCd}`}),t}),Po=ae(()=>g.value.map((e,s)=>{let o,n,i;const a=e.actualHeight||e.height||60;if(L.value==="floor"){const l=_o(e.x,e.y);o=l.x,n=l.y,i=So(e.width,e.height||e.depth||40).height}else{const l=pe();if(e.frontViewX!==void 0&&e.frontViewX!==null&&e.frontViewY!==void 0&&e.frontViewY!==null)o=e.frontViewX*l,n=e.frontViewY*l,i=a*l;else if(e.x!==void 0&&e.x!==null&&e.y!==void 0&&e.y!==null){const d=400+s*80,r=200;o=d,n=r,i=a*l}else o=100+s*100,n=100,i=a*l}const c=e.width*pe();return{...e,displayX:o,displayY:n,displayWidth:c,displayHeight:i,actualHeight:e.actualHeight||a||60,logicalX:e.x,logicalY:e.y,logicalWidth:e.width,logicalHeight:e.height||e.depth||40}})),Fo=ae(()=>{const t=Po.value.map(e=>{if(L.value==="front"){const s=e.actualHeight||e.height||60,o=e.displayX/pe(),n=e.displayY/pe(),i=e.frontViewRotation!==void 0?e.frontViewRotation:0;return e.x===o&&e.y===n&&e.height===s&&e.rotation===i?e:{...e,x:o,y:n,height:s,actualHeight:s,rotation:i}}return e});if(L.value==="front")return t;if(w.value){const e=t.findIndex(s=>s.id===w.value.id);if(e>-1){const[s]=t.splice(e,1);t.push(s)}}return t}),Jt=ae(()=>g.value.filter(t=>y.value.has(t.id))),lt=ae(()=>Vo(Jt.value)),Ko=ae(()=>{const t=new Set;return lt.value.forEach(e=>{e.length>1&&e.forEach(s=>t.add(s.id))}),t});m(!1),m([]);const Qt=()=>{if(!w.value)return{x:0,y:0};const t=g.value.find(e=>e.id===w.value.id);return t?L.value==="front"?{x:t.frontViewX!==void 0?t.frontViewX:t.x,y:t.frontViewY!==void 0?t.frontViewY:t.y}:{x:t.x,y:t.y}:{x:w.value.x,y:w.value.y}},te=t=>{if(!t)return{width:0,height:0};const e=2;return L.value==="floor"?{width:(t.width||40)*e,height:(t.depth||t.height||40)*e}:{width:(t.width||40)*e,height:(t.actualHeight||t.height||60)*e}},He=m(!1),rt=m(!1),Ee=m([]),y=m(new Set),Tt=m(null),xe=m(!1),X=m({x:0,y:0}),H=m({x:0,y:0}),oe=m([]),Dt=m(!1),ct=m(!1);m([]);const ze=m(!1),eo=m([]),to=m([]),Be=async t=>{Y.value=t,w.value=null,L.value==="front"&&(console.log("[Zone Change] Loading lockers for zone in front view mode..."),await ce(),le(()=>{g.value.some(s=>s.frontViewX==null||s.frontViewY==null)?(console.log("[Zone Change] Found lockers without front view coordinates, recalculating..."),_e()):console.log("[Zone Change] All lockers have front view coordinates")})),setTimeout(()=>{De()},100)},Ho=(t,e)=>{t.preventDefault(),t.stopPropagation(),bt.value=e,Lt.value={x:t.clientX,y:t.clientY},Qe.value=!0;const s=()=>{Qe.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},zo=async t=>{var e;try{const s=g.value.filter(c=>c.LOCKR_KND===t.id||c.zoneId===t.id||c.LOCKR_KND===t.LOCKR_KND_CD);if(s.length>0){alert(`구역 삭제 불가

이 구역에 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`구역 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=t.LOCKR_KND_CD||t.id,n=`${U}/zones/${o}`,i=await fetch(n,{method:"DELETE"});if(!i.ok){const c=await i.json();throw new Error(c.message||"Failed to delete zone")}(await i.json()).success&&(await Mt(),((e=Y.value)==null?void 0:e.id)===t.id&&(Ce.value.length>0?Be(Ce.value[0]):Y.value=null),alert("구역이 성공적으로 삭제되었습니다."))}catch(s){console.error("[API] Zone deletion failed:",s),alert(`구역 삭제 중 오류가 발생했습니다:
${s.message}`)}finally{Qe.value=!1}},Bo=(t,e)=>{t.preventDefault(),zt.value=e,No.value={x:t.clientX,y:t.clientY},et.value=!0;const s=()=>{et.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},oo=async t=>{var e;try{const s=g.value.filter(i=>i.LOCKR_TYPE_CD===t.id||i.type===t.id);if(s.length>0){alert(`타입 삭제 불가

이 타입으로 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`락커 타입 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=await fetch(`${U}/types/${t.id}`,{method:"DELETE"});if(!o.ok){const i=await o.json();throw new Error(i.message||"Failed to delete locker type")}(await o.json()).success&&(await Zt(),((e=Oe.value)==null?void 0:e.id)===t.id&&(Oe.value=null),et.value=!1)}catch(s){console.error("Failed to delete locker type:",s),alert("락커 타입 삭제에 실패했습니다.")}},jo=t=>{Oe.value=t},Go=(t,e,s,o)=>{let n=t,i=e;n=Math.round(n/20)*20,i=Math.round(i/20)*20;let a=0;const c=50;for(;a<c;){if(!Ot(n,i,s,o,null,0,!1))return{x:n,y:i};n+=20,n>Q.value-s-100&&(n=t,i+=20,i>ee.value-o-100&&(i=100,t+=20,n=t)),a++}return console.warn("[Direct Add] Could not find collision-free position, using default"),{x:t,y:e}},Uo=async t=>{if(L.value!=="floor"){alert("평면배치모드에서만 락커를 추가할 수 있습니다.");return}if(!Y.value){alert("구역을 선택해주세요.");return}Oe.value=t;const e=100,s=Math.round(ee.value/3),o=Go(e,s,t.width,t.depth||t.width),n=yo(o.x,o.y,t.width,t.depth||t.width),i={id:`locker-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,name:t.name,x:n.x,y:n.y,width:t.width,height:t.depth||t.width,depth:t.depth||t.width,actualHeight:t.height,color:t.color,rotation:0,type:t.name,status:"available",number:Rt(),zoneId:Y.value.id};let a=null;try{const l={LOCKR_KND:Y.value.id,LOCKR_TYPE_CD:t.id||t.type,X:i.x,Y:i.y,LOCKR_LABEL:i.number,ROTATION:i.rotation||0,LOCKR_STAT:"00"},d=await kt(l);d&&d.lockrCd&&(await ce(),De(),a=g.value.find(r=>r.x===i.x&&r.y===i.y&&r.number===i.number))}catch(l){console.error("[Database] Failed to save locker:",l),a=D.addLocker(i)}a&&(w.value=a,y.value.clear(),y.value.add(a.id),Z.value=!0),_n();const c=window.event;if(c&&c.currentTarget){const l=c.currentTarget;l.classList.add("pulse-animation"),setTimeout(()=>l.classList.remove("pulse-animation"),300)}},Wo=t=>{const e=Ke.value.indexOf(t);e>-1&&Ke.value.splice(e,1)},Zo=t=>{const e=me.value.find(s=>s.type===t);return e?e.name:t},je=t=>{const e=mt.value;if(!e)return{x:0,y:0};const s=e.createSVGPoint();s.x=t.clientX,s.y=t.clientY;const o=s.matrixTransform(e.getScreenCTM().inverse());return pe(),{x:Math.round(o.x*100)/100,y:Math.round(o.y*100)/100}},qo=t=>{if(L.value!=="floor"&&L.value!=="front"||!t.ctrlKey)return;t.preventDefault();const s=t.currentTarget.getBoundingClientRect(),o=(t.clientX-s.left)/s.width,n=(t.clientY-s.top)/s.height,i=fe/F.value,a=Le/F.value,c=W.value.x+o*i,l=W.value.y+n*a,d=t.deltaY>0?.9:1.1,r=Math.min(Math.max(F.value*d,Gt),Ut);if(r!==F.value){const h=fe/r,v=Le/r,x={x:c-o*h,y:l-n*v};W.value=$t(x,r),F.value=r}},$t=(t,e)=>{const s=fe/e,o=Le/e,n=0,i=0,a=Math.max(0,qe-s),c=Math.max(0,pt-o);return{x:Math.max(n,Math.min(a,t.x)),y:Math.max(i,Math.min(c,t.y))}},De=()=>{if(console.log("[AutoFit] Starting autoFitLockers...",{lockersCount:g.value.length,viewMode:L.value}),g.value.length===0){console.log("[AutoFit] No lockers found, using default zoom"),F.value=1,W.value={x:0,y:0};return}let t=1/0,e=1/0,s=-1/0,o=-1/0;const n=2;if(g.value.forEach(C=>{if(C.parentLockerId)return;let A,S,$,z;if(L.value==="floor")A=C.x,S=C.y,$=C.x+(C.width||40)*n,z=C.y+(C.depth||C.height||40)*n;else if(L.value==="front")A=C.frontViewX!==void 0?C.frontViewX:C.x,S=C.frontViewY!==void 0?C.frontViewY:C.y,$=A+(C.width||40)*n,z=S+(C.actualHeight||C.height||60)*n;else return;t=Math.min(t,A),e=Math.min(e,S),s=Math.max(s,$),o=Math.max(o,z)}),t===1/0||e===1/0){F.value=1,W.value={x:0,y:0};return}const i=s-t,a=o-e,c=.3,l=i*(1+c),d=a*(1+c),r=fe/l,h=Le/d;let v=Math.min(r,h);v=v*.729,v=Math.max(Gt,Math.min(v,Ut));const x=(t+s)/2,f=(e+o)/2,b=fe/(2*v),N=Le/(2*v);F.value=v;const p={x:x-b,y:f-N};W.value=$t(p,v),console.log("[AutoFit]",L.value,"mode - Zoom:",v,"Pan:",W.value,"Bounds:",{minX:t,minY:e,maxX:s,maxY:o})},Jo=t=>{if((L.value==="floor"||L.value==="front")&&t.button===1){t.preventDefault(),Pe.value=!0,it.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y,n=t.target;!(n.closest("[data-locker-id]")||n.tagName==="rect"&&!n.classList.contains("canvas-background")||n.tagName==="text"||n.tagName==="g"&&n.querySelector("text"))&&(n.tagName==="svg"||n.classList.contains("canvas-background")||n.getAttribute("fill")==="url(#grid)"||n.classList.contains("selection-box"))&&!P.value&&(xe.value=!0,X.value={x:s,y:o},H.value={x:s,y:o},y.value.clear(),w.value=null,t.preventDefault(),t.stopPropagation())},Qo=t=>{if((L.value==="floor"||L.value==="front")&&Pe.value){const n=(t.clientX-it.value.x)/F.value,i=(t.clientY-it.value.y)/F.value,a={x:W.value.x-n,y:W.value.y-i};W.value=$t(a,F.value),it.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y;xe.value?(H.value={x:s,y:o},Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Ao&&so()):P.value&&rn(t)},no=t=>{if((L.value==="floor"||L.value==="front")&&Pe.value){Pe.value=!1;return}if(!(He.value||rt.value)){if(xe.value){const e=je(t),s=e.x,o=e.y;Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Ao?(so(),Dt.value=!0,y.value.size>0&&(Z.value=!0),setTimeout(()=>{Dt.value=!1},100)):He.value||(y.value.clear(),w.value=null),xe.value=!1,X.value={x:0,y:0},H.value={x:0,y:0}}P.value&&cn()}},so=()=>{if(!X.value||!H.value||X.value.x==null||X.value.y==null||H.value.x==null||H.value.y==null){console.warn("[Rectangle Select] Invalid coordinates, skipping selection update");return}const t=Math.min(X.value.x,H.value.x),e=Math.max(X.value.x,H.value.x),s=Math.min(X.value.y,H.value.y),o=Math.max(X.value.y,H.value.y);if(y.value.clear(),g.value.forEach(n=>{let i,a,c,l;if(L.value==="front"){const r=n.frontViewX!==void 0?n.frontViewX:n.x,h=n.frontViewY!==void 0?n.frontViewY:n.y,v=te(n);i=r,a=r+v.width,c=h,l=h+v.height}else{const r=te(n);i=n.x,a=n.x+r.width,c=n.y,l=n.y+r.height}!(a<t||i>e||l<s||c>o)&&y.value.add(n.id)}),y.value.size>0){const n=Array.from(y.value)[0];w.value=g.value.find(i=>i.id===n),Z.value=!0}else w.value=null},en=t=>{if(Dt.value||ct.value||rt.value)return;const e=t.target,s=e.tagName==="svg"||e.classList.contains("canvas-background")||e.tagName==="rect"&&e.getAttribute("fill")==="url(#grid)"||e.classList.contains("canvas");if(s&&!t.ctrlKey&&!t.shiftKey&&!t.metaKey){w.value=null,y.value.clear(),D.selectLocker(null),Z.value=!1;return}if(s&&(t.shiftKey||t.ctrlKey)){const o=mt.value.getBoundingClientRect();$o.value={isSelecting:!0,startX:t.clientX-o.left,startY:t.clientY-o.top,endX:t.clientX-o.left,endY:t.clientY-o.top},console.log("[Selection] Drag selection started");return}},tn=(t,e)=>{var s;if(console.log("[Selection] Attempting to select in mode:",L.value,"Locker:",t.id),ct.value){console.log("[Select] Ignored - drag just finished");return}if(xe.value){console.log("[Select] Ignored - drag selection in progress");return}if(!P.value){if(e&&(e.ctrlKey||e.metaKey)){if(y.value.has(t.id)){if(y.value.delete(t.id),((s=w.value)==null?void 0:s.id)===t.id){const o=Array.from(y.value);w.value=o.length>0?g.value.find(n=>n.id===o[0]):null}}else y.value.add(t.id),w.value=t;Z.value=!0,console.log(`[Selection] Toggle select ${t.id}, total: ${y.value.size}`)}else e&&e.shiftKey&&Tt.value?(on(Tt.value,t),Z.value=!0):(y.value.clear(),y.value.add(t.id),w.value=t,console.log("[Selection UI] Rotation applied:",{lockerRotation:t.rotation||0,buttonPositions:{left:{x:t.width/2-15,y:-30},right:{x:t.width/2+15,y:-30},delete:{x:t.width+15,y:-15}},rotationCenter:{x:t.width/2,y:t.height/2}}));Tt.value=t,D.selectLocker(t.id),Z.value=!0,console.log("[Select] Selection updated - Count:",y.value.size,"IDs:",Array.from(y.value),"ShowUI:",Z.value)}},on=(t,e)=>{const s=g.value.findIndex(a=>a.id===t.id),o=g.value.findIndex(a=>a.id===e.id);if(s===-1||o===-1)return;const n=Math.min(s,o),i=Math.max(s,o);y.value.clear();for(let a=n;a<=i;a++)y.value.add(g.value[a].id);w.value=e,console.log(`[Selection] Range select from ${t.id} to ${e.id}, total: ${y.value.size}`)},nn=(t,e)=>{if(L.value==="front")return;if(!t||xe.value){console.log("[Drag] Ignored - drag selection in progress");return}P.value=!0,Z.value=!1;const s=e.ctrlKey||e.metaKey;console.log("[Multi-Select] Copying with drag:",s),console.log("[Drag] Started - hiding selection UI");let o=t;if(s){const l=new Map;if(Array.from(y.value).forEach(d=>{const r=g.value.find(h=>h.id===d);if(r){const h={...r,id:`locker-${Date.now()}-${Math.random()}`,number:"",x:r.x+20,y:r.y+20},v=D.addLocker(h);D.updateLocker(v.id,{lockrNo:Rt()}),l.set(r.id,v.id)}}),l.size>0){if(l.has(t.id)){const d=l.get(t.id);o=g.value.find(r=>r.id===d)}y.value.clear(),l.forEach(d=>{y.value.add(d)}),w.value=o,console.log("[Multi-Select] Created copies:",l.size,"New leader:",o.id)}}!s&&!y.value.has(t.id)&&(y.value.clear(),y.value.add(t.id),w.value=t),P.value=!0;const n=je(e);oe.value=Array.from(y.value).map(l=>{const d=g.value.find(N=>N.id===l),r=Math.round(d.x*100)/100,h=Math.round(d.y*100)/100,v=Math.round(o.x*100)/100,x=Math.round(o.y*100)/100,f=r-v,b=h-x;return{id:d.id,initialX:r,initialY:h,relativeX:f,relativeY:b,isLeader:d.id===o.id}});const i=Math.round(o.x*100)/100,a=Math.round(o.y*100)/100;Je.value={x:n.x-i,y:n.y-a};const c=y.value.size;c>1?console.log("[Group Drag] Started with",c,"lockers, leader:",o.id):console.log("[Drag] Start dragging locker:",t.id),e.preventDefault()},$e=m(null),sn=(t,e)=>{if(t){if(y.value.has(t.id)||(w.value=t,y.value.add(t.id)),He.value=!0,y.value.size>1){const s=Array.from(y.value),o=g.value.filter(l=>s.includes(l.id)),n={minX:Math.min(...o.map(l=>l.x)),maxX:Math.max(...o.map(l=>l.x+l.width)),minY:Math.min(...o.map(l=>l.y)),maxY:Math.max(...o.map(l=>l.y+(l.height||l.depth||40)))},i=(n.minX+n.maxX)/2,a=(n.minY+n.maxY)/2,c=new Map;o.forEach(l=>{const d=te(l),r=l.x+d.width/2,h=l.y+d.height/2;c.set(l.id,{relativeX:r-i,relativeY:h-a,width:d.width,height:d.height,initialRotation:l.rotation||0})}),$e.value={centerX:i,centerY:a,lockerStates:c,leaderId:t.id}}else $e.value=null;P.value=!1}},an=(t,e)=>{if(y.value.size>1&&$e.value){const s=$e.value,o=g.value.find(r=>r.id===t);if(!o||!s)return;o._lastRotation===void 0&&(o._lastRotation=o.rotation||0,console.log("=== ROTATION INIT ==="),console.log("  Initial rotation set to:",o._lastRotation));let n=e-o._lastRotation;for(console.log("=== ROTATION DEBUG ==="),console.log("  newRotation:",e),console.log("  lastRotation:",o._lastRotation),console.log("  raw delta:",n);n>180;)n-=360,console.log("  → Adjusted delta (>180):",n);for(;n<-180;)n+=360,console.log("  → Adjusted delta (<-180):",n);const i=o._rotationDirection||0,a=Math.sign(n);i!==0&&a!==0&&i!==a&&console.log("  Direction change detected! prev:",i,"current:",a),o._rotationDirection=a,o._lastRotation=e,console.log("  Final delta:",n);const c=s.centerX,l=s.centerY;Array.from(y.value).forEach(r=>{const h=g.value.find(A=>A.id===r);if(!h)return;const v=s.lockerStates.get(r);if(!v)return;const x=e-(s.lockerStates.get(s.leaderId).initialRotation||0),f=x*Math.PI/180,b=Math.cos(f),N=Math.sin(f),p=v.relativeX*b-v.relativeY*N+c,C=v.relativeX*N+v.relativeY*b+l;h.x=p-v.width/2,h.y=C-v.height/2,h.id===s.leaderId?(h.rotation=e,console.log(`[ROTATION DIRECTION] Leader locker ${h.id} rotation: ${h.rotation}`)):(h.rotation=v.initialRotation+x,console.log(`[ROTATION DIRECTION] Follower locker ${h.id} rotation: ${h.rotation}`)),io(h.id,h.rotation)})}else{const s=g.value.find(o=>o.id===t);s&&(s.rotation=e,console.log(`[ROTATION DIRECTION] Single locker ${s.id} rotation: ${s.rotation}`),io(t,s.rotation))}},ln=t=>{if(y.value.size>1)Array.from(y.value).forEach(n=>{const i=g.value.find(a=>a.id===n);if(i){const a=Math.round(i.rotation/45)*45;i.rotation=a,console.log(`[ROTATION END] Snapped locker ${n} from ${i.rotation} to ${a}`)}});else{const o=g.value.find(n=>n.id===t);if(o){const n=o.rotation,i=Math.round(n/45)*45;o.rotation=i,console.log(`[ROTATION END] Snapped locker ${t} from ${n} to ${i}`)}}rt.value=!0,He.value=!1,setTimeout(()=>{rt.value=!1},200);const s=g.value.find(o=>o.id===t);if(s&&(delete s._lastRotation,delete s._lastRawRotation,delete s._rotationDirection),$e.value&&($e.value=null),y.value.size>1){const o=Array.from(y.value);g.value.filter(i=>o.includes(i.id)).forEach(i=>{Nt(i.id,i.rotation)})}else{const o=g.value.find(n=>n.id===t);o&&Nt(t,o.rotation)}},io=(()=>{let t=null;return(e,s)=>{clearTimeout(t),t=setTimeout(()=>{Nt(e,s)},200)}})(),Nt=async(t,e)=>{try{if(D.getLockerById(t)){let o=e%360;o>180?o-=360:o<-180&&(o+=360);const n=He.value;await D.updateLocker(t,{rotation:o},n)}}catch(s){console.error("[Rotation] Failed to save rotation:",s)}},rn=t=>{if(!P.value||oe.value.length===0)return;const e=je(t),s=oe.value.find(E=>E.isLeader);if(!s)return;const o=g.value.find(E=>E.id===s.id);if(!o)return;const n=e.x-Je.value.x,i=e.y-Je.value.y,a=te(o),c=ut(n),l=ut(i),d=yo(c,l,a.width,a.height,s.id,o.rotation||0),r=d.x!==c||d.y!==l;r&&console.log("[SNAP DEBUG] Position was snapped from",{x:c,y:l},"to",d);const h=d.x-s.initialX,v=d.y-s.initialY,x=[];let f=!1,b=1/0,N=1/0,p=-1/0,C=-1/0;oe.value.forEach(E=>{const k=g.value.find(R=>R.id===E.id);if(k){const R=te(k);let I,O;E.isLeader?(I=d.x,O=d.y):(I=d.x+E.relativeX,O=d.y+E.relativeY),b=Math.min(b,I),N=Math.min(N,O),p=Math.max(p,I+R.width),C=Math.max(C,O+R.height)}});let A=0,S=0;b<0?A=-b:p>Q.value&&(A=Q.value-p),N<0?S=-N:C>ee.value&&(S=ee.value-C);const $=d.x+A,z=d.y+S;if(oe.value.forEach(E=>{const k=g.value.find(R=>R.id===E.id);if(k){const R=te(k);let I,O;E.isLeader?(I=$,O=z):(I=$+E.relativeX,O=z+E.relativeY),Ot(I,O,R.width,R.height,k.id,k.rotation||0,r)&&(f=!0),x.push({id:k.id,x:I,y:O,dims:R})}}),!f)x.forEach(E=>{var I;const k=Math.round(E.x*100)/100,R=Math.round(E.y*100)/100;D.updateLocker(E.id,{x:k,y:R},!0),((I=w.value)==null?void 0:I.id)===E.id&&(w.value={...w.value,x:k,y:R})}),console.log("[Group Drag] Moving",y.value.size,"lockers. Leader:",s.id,"Delta:",{x:h.toFixed(1),y:v.toFixed(1)});else if(r&&f){console.log("[SNAP WARNING] Collision detected at snapped position, checking overlap amount...");let E=0;oe.value.forEach(k=>{const R=g.value.find(I=>I.id===k.id);if(R){const I=te(R);let O,B;k.isLeader?(O=d.x,B=d.y):(O=d.x+k.relativeX,B=d.y+k.relativeY);const j=ie({x:O,y:B,width:I.width,height:I.height,rotation:R.rotation||0});g.value.forEach(G=>{if(G.id!==R.id&&!y.value.has(G.id)){const K=ie(G),ne=Math.min(j.x+j.width,K.x+K.width)-Math.max(j.x,K.x),q=Math.min(j.y+j.height,K.y+K.height)-Math.max(j.y,K.y);ne>0&&q>0&&(E=Math.max(E,Math.min(ne,q)),console.log("[SNAP OVERLAP] With",G.id,"- X:",ne.toFixed(1),"Y:",q.toFixed(1)))}})}}),E<1?(console.log("[SNAP] Accepting snapped position with micro-overlap:",E.toFixed(2),"px"),x.forEach(k=>{var R;D.updateLocker(k.id,{x:k.x,y:k.y},!0),((R=w.value)==null?void 0:R.id)===k.id&&(w.value={...w.value,x:k.x,y:k.y})})):console.warn("[SNAP] Rejecting snapped position due to significant overlap:",E.toFixed(1),"px")}else{console.log("[COLLISION ADJUSTMENT DEBUG] Collision detected (non-snapped), finding valid position:",{snappedLeader:d,proposedPositions:x.length,hasCollision:f,wasSnapped:r});let E=d.x,k=d.y,R=!1;const I=[{dx:-20,dy:0},{dx:20,dy:0},{dx:0,dy:-20},{dx:0,dy:20},{dx:-20,dy:-20},{dx:20,dy:-20},{dx:-20,dy:20},{dx:20,dy:20}];for(const O of I){const B=d.x+O.dx,j=d.y+O.dy;let G=!1;if(oe.value.forEach(K=>{const ne=g.value.find(q=>q.id===K.id);if(ne&&!G){const q=te(ne);let Me,Ue;K.isLeader?(Me=B,Ue=j):(Me=B+K.relativeX,Ue=j+K.relativeY);const On=Q.value-q.width,Yn=ee.value-q.height;Me=Math.max(0,Math.min(Me,On)),Ue=Math.max(0,Math.min(Ue,Yn)),Ot(Me,Ue,q.width,q.height,ne.id,ne.rotation||0,!1)&&(G=!0)}}),!G){E=B,k=j,R=!0;break}}R?(oe.value.forEach(O=>{var j;const B=g.value.find(G=>G.id===O.id);if(B){let G,K;O.isLeader?(G=E,K=k):(G=E+O.relativeX,K=k+O.relativeY);const ne=te(B),q=Q.value-ne.width,Me=ee.value-ne.height;G=Math.max(0,Math.min(G,q)),K=Math.max(0,Math.min(K,Me)),D.updateLocker(B.id,{x:G,y:K},!0),((j=w.value)==null?void 0:j.id)===B.id&&(w.value={...w.value,x:G,y:K})}}),console.log("[COLLISION] Adjusted to valid position:",`(${E}, ${k})`)):console.warn("[COLLISION] No collision-free adjustment found, keeping original positions")}},cn=()=>{if(P.value){if(ct.value=!0,console.log("[Drag] Setting lockerDragJustFinished flag to true"),setTimeout(()=>{ct.value=!1,console.log("[Drag] Cleared lockerDragJustFinished flag")},150),oe.value.length>0){const t=oe.value.map(e=>{const s=g.value.find(o=>o.id===e.id);return{id:e.id,x:(s==null?void 0:s.x)||e.x,y:(s==null?void 0:s.y)||e.y}});Yo(t)}P.value=!1,Z.value=!0,Je.value={x:0,y:0},oe.value=[],ze.value=!1,eo.value=[],to.value=[],console.log("[Drag] End dragging - Current selection count:",y.value.size)}},dn=()=>{const t=[],e=new Set,s=g.value.filter(o=>!o.parentLockerId);for(let o=0;o<s.length;o++){const n=s[o],i=n.rotation||0;let a=null;if(i===0||i===360?a={minX:n.x,maxX:n.x+n.width,minY:n.y+(n.depth||n.height),maxY:n.y+(n.depth||n.height)+50}:i===90?a={minX:n.x+n.width,maxX:n.x+n.width+50,minY:n.y,maxY:n.y+(n.depth||n.height)}:i===180?a={minX:n.x,maxX:n.x+n.width,minY:n.y-50,maxY:n.y}:i===270&&(a={minX:n.x-50,maxX:n.x,minY:n.y,maxY:n.y+(n.depth||n.height)}),a)for(let c=0;c<s.length;c++){if(o===c)continue;const l=s[c];if(n.zoneId!==l.zoneId)continue;const d=l.depth||l.height,r=!(l.x+l.width<=a.minX||l.x>=a.maxX),h=!(l.y+d<=a.minY||l.y>=a.maxY);r&&h&&(e.add(n.id),e.add(l.id),t.push(`락커 ${n.number}의 문 앞이 락커 ${l.number}에 의해 막혀있습니다.`))}}t.length>0?console.log("[Door Blockage Check]:",{blocked:!0,errors:t,problematicLockers:Array.from(e)}):console.log("[Door Blockage Check]: All locker doors are accessible"),t.length>0&&(t.length=0,t.push("세로배치 모드 불가: 락커의 문 앞이 다른 락커에 의해 막혀있습니다."));for(let o=0;o<g.value.length;o++){const n=g.value[o];for(let i=o+1;i<g.value.length;i++){const a=g.value[i],c=Math.abs(n.x+n.width-a.x)<5||Math.abs(a.x+a.width-n.x)<5,l=Math.abs(n.y+(n.depth||n.height)-a.y)<5||Math.abs(a.y+(a.depth||a.height)-n.y)<5;if(c||l){if(c){const d=n.rotation%180===0,r=a.rotation%180===180;(n.x<a.x&&d&&r||a.x<n.x&&r&&d)&&(e.add(n.id),e.add(a.id),t.push(`락커 ${n.number}와 ${a.number}의 입구가 마주보고 있습니다`))}if(l){const d=n.rotation%180===90,r=n.rotation%180===270,h=a.rotation%180===90,v=a.rotation%180===270;(n.y<a.y&&d&&v||a.y<n.y&&h&&r)&&(e.add(n.id),e.add(a.id),t.push(`락커 ${n.number}와 ${a.number}의 입구가 마주보고 있습니다`))}}}}return console.log("[Placement Validation]:",{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}),{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}},un=t=>{g.value.forEach(e=>{e.hasError=!1}),t.forEach(e=>{const s=g.value.find(o=>o.id===e);s&&(s.hasError=!0)})},_t=m(!1),ao=t=>{console.log("[setViewMode] Switching to:",t),t==="floor"&&L.value==="front"&&(_t.value=!0,setTimeout(()=>{_t.value=!1},400)),L.value=t,t==="front"&&setTimeout(()=>{De()},50),t==="floor"&&setTimeout(()=>{De()},50),lo(),console.log("[ViewMode] Switching to:",t,{previousScale:t==="floor"?ko:Mo,newScale:pe(),viewMode:L.value}),le(()=>{Ct()})},lo=()=>{if(L.value==="front"){const e=dn();if(e.isValid)console.log("[Validation PASSED] Front view validation successful");else{console.error("[Validation FAILED] Cannot switch to front view:",e.errors),console.error("[Validation FAILED] Problematic lockers:",e.problematicLockers),alert(`세로모드 진입 불가: 락커 배치가 규칙에 맞지 않습니다.
문제: `+e.errors.join(`
`)),un(e.problematicLockers),L.value="floor";return}g.value.forEach(s=>s.hasError=!1)}console.log("[View Mode] Configuration:",{mode:L.value,floorY:we,dimensions:L.value==="floor"?"width×depth":"width×height",interactions:L.value==="floor"?"enabled":"disabled"}),Do.value=L.value==="front",L.value==="front"?(w.value=null,y.value.clear(),P.value=!1,Z.value=!1):(Z.value=!0,console.log("[Floor View] Interactions enabled, full editing mode"));const t=L.value==="floor"?"flat":"vertical";D.setPlacementMode(t)},ro=()=>{const t=g.value;if(t.length===0)return;const e={minX:Math.min(...t.map(r=>r.x)),maxX:Math.max(...t.map(r=>r.x+r.width)),minY:Math.min(...t.map(r=>r.y)),maxY:Math.max(...t.map(r=>r.y+(r.depth||r.height)))},s=[],o=[],n=[],i=[],a=[];t.forEach(r=>{const h=Math.abs(r.y-e.minY)<30,v=Math.abs(r.y+(r.depth||r.height)-e.maxY)<30,x=Math.abs(r.x-e.minX)<30,f=Math.abs(r.x+r.width-e.maxX)<30;h&&!x&&!f?s.push(r):v&&!x&&!f?n.push(r):f&&!h&&!v?o.push(r):x&&!h&&!v?i.push(r):h&&f||v&&f?o.push(r):h&&x?s.push(r):v&&x?n.push(r):a.push(r)}),s.sort((r,h)=>r.x-h.x),o.sort((r,h)=>r.y-h.y),n.sort((r,h)=>h.x-r.x),i.sort((r,h)=>h.y-r.y);let c=[];s.length>0&&o.length>0&&n.length>0?(console.log("[U-Shape] Detected ㄷ pattern"),c=[...s,...o,...n],console.log("[U-Shape] Walking order:",{top:s.map(r=>`L${r.number}`).join("→"),right:o.map(r=>`L${r.number}`).join("→"),bottom:n.map(r=>`L${r.number}`).join("→"),total:c.map(r=>`L${r.number}`).join("→")})):i.length>0&&o.length>0?(console.log("[Back-to-Back] Detected two columns"),i.sort((r,h)=>r.y-h.y),o.sort((r,h)=>h.y-r.y),c=[...i,...o]):(console.log("[Simple Row] Single line of lockers"),c=[...t].sort((r,h)=>r.x-h.x)),i.length>0&&c.indexOf(i[0])===-1&&(console.log("[Left Column] Adding left side lockers"),c.push(...i)),a.length>0&&(console.log("[Middle] Adding uncategorized lockers:",a.length),c.push(...a));const l=t.length,d=c.length;if(l!==d){console.error("[Transform] Locker count mismatch!",{original:l,unfolded:d});const r=new Set(c.map(v=>v.id)),h=t.filter(v=>!r.has(v.id));console.log("[Missing] Lockers not included:",h.map(v=>`L${v.number}`)),c.push(...h)}Ht.value=c,console.log("[Front View] Transformation complete:",{totalLockers:c.length,sequence:c.map(r=>r.number||r.id).join(" -> ")})},Ge=t=>{let e=t%360;return e<0&&(e+=360),e},co=t=>wo(t),dt=t=>t.reduce((e,s)=>s.y<e.y||s.y===e.y&&s.x<e.x?s:e,t[0]),uo=t=>t.sort((e,s)=>{const o=dt(e),n=dt(s);return Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x}),St=t=>{const e=[],s=new Set;return t.forEach(o=>{if(s.has(o.id))return;const n=[],i=[o];for(;i.length>0;){const a=i.shift();s.has(a.id)||(s.add(a.id),n.push(a),t.forEach(c=>{s.has(c.id)||It(a,c)&&i.push(c)}))}n.length>0&&e.push(n)}),e.forEach((o,n)=>{console.log(`  Minor group ${n+1}: ${o.map(i=>i.number||i.id).join(", ")}`)}),e},hn=t=>{if(t.length<=1)return t[0]?t[0][0]:null;const e=new Map;for(const o of t){let n=0;for(const i of t){if(o===i)continue;let a=!1;for(const c of o){for(const l of i)if(Vt(c,l)){a=!0;break}if(a)break}a&&n++}e.set(o,n)}const s=t.filter(o=>e.get(o)===1);if(s.length===0){console.log("[Clockwise Start] Complete loop detected, finding leftmost group");let o=t[0];for(const n of t){const i=Ne(n),a=Ne(o);i.x<a.x&&(o=n)}return console.log("[Clockwise Start] Selected leftmost group:",o.map(n=>n.number||n.id).join(",")),o[0]}if(s.length>=2){console.log("[Clockwise Start] Broken chain detected with",s.length,"endpoints");let o=s[0];for(const n of s){const i=Ne(n),a=Ne(o);(i.y<a.y||Math.abs(i.y-a.y)<10&&i.x<a.x)&&(o=n)}return console.log("[Clockwise Start] Selected endpoint:",o.map(n=>n.number||n.id).join(",")),o[0]}return console.log("[Clockwise Start] Fallback to first group"),t[0][0]},fn=(t,e)=>{for(const s of e)if(s.some(o=>o.id===t.id))return s;return null},Ne=t=>{const e=t.reduce((o,n)=>o+n.x,0),s=t.reduce((o,n)=>o+n.y,0);return{x:e/t.length,y:s/t.length}},vn=(t,e,s)=>{const o=[],n=Ne(t);for(const i of s){if(e.has(i))continue;let a=!1;for(const c of t){for(const l of i)if(Vt(c,l)){a=!0;break}if(a)break}if(a){const c=Ne(i),l=c.x-n.x,d=c.y-n.y;let r=Math.atan2(d,l)*180/Math.PI;r<0&&(r+=360),o.push({group:i,angle:r})}}return o.length===0?null:(o.sort((i,a)=>i.angle-a.angle),o[0].group)},ho=t=>{if(t.length<=1)return t;const e=[],s=new Set,o=hn(t),n=fn(o,t);if(!n)return t.sort((a,c)=>{const l=dt(a),d=dt(c);return Math.abs(l.y-d.y)>1?l.y-d.y:l.x-d.x});let i=n;for(;i&&!s.has(i);)e.push(i),s.add(i),i=vn(i,s,t);for(const a of t)s.has(a)||e.push(a);return e},fo=t=>{if(t.length===0)return[];const e=Ge(t[0].rotation||0);let s=[...t];switch(console.log(`[Rotation] Processing minor group with rotation ${e}°:`,t.map(o=>`${o.number||o.id}`)),e){case 0:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 90:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 180:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:n.x-o.x);break;case 270:s.sort((o,n)=>Math.abs(o.x-n.x)>1?o.x-n.x:n.y-o.y);break}return console.log("[Rotation] After rotation, order:",s.map(o=>o.number||o.id)),s},gn=(t,e,s,o)=>{let n=null,i=null;s.forEach((v,x)=>{v.some(f=>f.id===t.id)&&(n=x),v.some(f=>f.id===e.id)&&(i=x)});const a=n!==null&&i!==null&&n===i;let c=!1;if(o){const v=o.get(t.id),x=o.get(e.id);c=v!==void 0&&x!==void 0&&v===x}const l=v=>{if(v.typeId==="custom-1755675491548")return"normal";if(v.typeId==="custom-1755675506519")return"tall";if(v.color==="#4A90E2")return"blue";if(v.color==="#BD10E0")return"purple";if(!v.typeId&&v.actualHeight){if(v.actualHeight===30)return"normal";if(v.actualHeight===90)return"tall"}return v.typeId||"default"},d=l(t),r=l(e),h=d===r;return a?{same:!0,sameType:h,sameMinorGroup:!0,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:i,prevType:d,currentType:r}:{same:!1,sameType:h,sameMinorGroup:!1,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:i,prevType:d,currentType:r}},pn=(t,e,s,o)=>{const n=gn(t,e,s,o);return console.log(`  Group spacing between ${t.number} and ${e.number}:`,n),n.sameMinorGroup?(console.log("  → Same minor group: 0px gap"),0):n.sameMajorGroup?(console.log("  → Same major group, different minor group: 10px gap"),10):(console.log("  → Different major group: 20px gap"),20)},_e=()=>{console.trace("Called from:");const t=g.value.filter(p=>!p.parentLockrCd&&(!p.tierLevel||p.tierLevel===0));if(console.log(`[Transform] Processing ${t.length} parent lockers (${g.value.length-t.length} child lockers excluded from grouping)`),t.length===0)return;const e=co(t),s=uo(e),o=[],n=2;let i=0;const a=[],c=[],l=[],d=new Map;s.forEach((p,C)=>{console.log(`[Front View] Processing major group ${C+1}:`,p.map($=>`${$.number||$.id}(rot:${$.rotation||0})`)),p.forEach($=>{d.set($.id,C)});const A=St(p),S=ho(A);l.push(...S),console.log(`  Found ${S.length} minor groups:`),S.forEach(($,z)=>{console.log(`    Minor Group ${z+1}:`,$.map(E=>`${E.number}(rot:${E.rotation||0})`))}),S.forEach(($,z)=>{console.log(`  Processing minor group ${z+1}:`,$.map(k=>`${k.number||k.id}(rot:${k.rotation||0})`)),fo($).forEach(k=>{c.push(k)})})});let r=null;c.forEach((p,C)=>{if(o.push(p),r&&C>0){let $=0;!r.parentLockrCd&&!p.parentLockrCd&&($=pn(r,p,l,d)),i+=$}const A=(p.width||40)*n,S=(p.actualHeight||p.height||60)*n;if(a.push({...p,frontViewX:i,frontViewY:we-S,frontViewRotation:0}),p.parentLockrCd){const $=a.find(z=>z.lockrCd===p.parentLockrCd);if($){let z=30;if($.lockrTypeCd||$.typeId||$.type){const O=$.lockrTypeCd||$.typeId||$.type,B=me.value.find(j=>j.id===O||j.type===O||j.LOCKR_TYPE_CD===O);B&&B.height&&(z=B.height,console.log(`[TIER HEIGHT] Using type height: ${z} for parent type: ${O}`))}const E=z*n,k=p.tierLevel||1,R=$.frontViewX,I=$.frontViewY-E*k;a[a.length-1].frontViewX=R,a[a.length-1].frontViewY=I,a[a.length-1].frontViewRotation=0}else console.error(`[CHILD POSITION] Parent not found for ${p.number}, parentLockrCd: ${p.parentLockrCd}`),a[a.length-1].frontViewX=i,a[a.length-1].frontViewY=we-S,a[a.length-1].frontViewRotation=0,i+=A}else a[a.length-1].frontViewX=i,a[a.length-1].frontViewY=we-S,a[a.length-1].frontViewRotation=0,i+=A;r=p});const h=i,v=(Q.value-h)/2;a.forEach(p=>{p.frontViewX+=v});const x=[],f=0;if(a.forEach(p=>{const C=(p.actualHeight||p.height||0)*2,A=p.frontViewY;if(A<f){console.warn(`[Boundary Check] 락커 ${p.number}이(가) 화면 위쪽 경계를 넘어갑니다:`,{lockerId:p.id,number:p.number,topEdge:A,height:C,canvasTop:f,isOverflowing:A<f});const S=g.value.find($=>$.id===p.id);S&&x.push(S)}}),x.length>0){console.log(`[Boundary Check] 화면을 넘어가는 ${x.length}개의 락커를 삭제합니다:`,x.map(C=>`${C.number}(${C.id})`)),x.forEach(C=>{const A=g.value.findIndex(S=>S.id===C.id);A!==-1&&g.value.splice(A,1)});const p=x.map(async C=>{try{const A=await fetch(`${U}/lockrs/${C.lockrCd}`,{method:"DELETE"});A.ok?console.log(`[Boundary Check] 백엔드에서 락커 ${C.number}(${C.lockrCd}) 삭제 완료`):console.error(`[Boundary Check] 백엔드에서 락커 ${C.number} 삭제 실패:`,await A.text())}catch(A){console.error(`[Boundary Check] 백엔드에서 락커 ${C.number} 삭제 중 오류:`,A)}});Promise.all(p).then(()=>{console.log("[Boundary Check] 모든 경계 초과 락커 삭제 완료, 락커 목록 다시 로드 및 위치 재계산"),ce().then(()=>{le(()=>{_e()})})})}console.log("[Batch Update] Starting batch update for all lockers...");const b=[];a.forEach(p=>{b.push({id:p.id,updates:{frontViewX:p.frontViewX,frontViewY:p.frontViewY,frontViewRotation:p.frontViewRotation||0}})}),console.log("[Transform] Child lockers excluded - preserving their existing FRONT_VIEW coordinates from DB"),D.batchUpdateLockers(b),console.log(`[Batch Update] Updated ${b.length} lockers simultaneously`),console.log("[DB Save] Saving front view coordinates to database...");const N=b.map(async p=>{try{const C=g.value.find(A=>A.id===p.id);if(C&&C.lockrCd){const A={};p.updates.frontViewX!==void 0&&(A.FRONT_VIEW_X=p.updates.frontViewX),p.updates.frontViewY!==void 0&&(A.FRONT_VIEW_Y=p.updates.frontViewY);const S=await fetch(`${U}/lockrs/${C.lockrCd}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(A)});S.ok?console.log(`[DB Save] Saved locker ${C.number} with FRONT_VIEW_X=${A.FRONT_VIEW_X}, FRONT_VIEW_Y=${A.FRONT_VIEW_Y}`):console.error(`[DB Save] Failed to save locker ${C.number}:`,await S.text())}}catch(C){console.error(`[DB Save] Failed to save locker ${p.id}:`,C)}});Promise.all(N).then(()=>{console.log("[DB Save] All front view coordinates saved to database")}).catch(p=>{console.error("[DB Save] Error saving some lockers:",p)}),Ht.value=o,console.log("[Front View] NEW Transformation complete:",{totalLockers:o.length,majorGroups:s.length,sequence:o.map(p=>p.number||p.id).join(" → "),deletedLockers:x.length})},vo=()=>{if(L.value!=="front"){go();return}const t=y.value.size>0?Array.from(y.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=t.map(i=>g.value.find(a=>a.id===i)).filter(Boolean);if(e.some(i=>!i.parentLockrCd||i.tierLevel===0)){alert("부모 락커는 삭제할 수 없습니다. 자식 락커(상단 락커)만 삭제 가능합니다.");return}const o=new Map;e.forEach(i=>{const a=i.parentLockrCd||"no-parent";o.has(a)||o.set(a,[]),o.get(a).push(i)}),console.log("[DELETE] Lockers grouped by parent:",Array.from(o.entries()).map(([i,a])=>({parent:i,lockers:a.map(c=>({id:c.id,number:c.number,tierLevel:c.tierLevel}))})));for(const[i,a]of o.entries()){const c=a.map(r=>r.tierLevel||0).filter((r,h,v)=>v.indexOf(r)===h).sort((r,h)=>h-r);console.log(`[DELETE] Parent ${i} tier levels:`,c);const l=Math.max(...c);if(!c.every((r,h)=>{const v=l-h,x=r===v;return console.log(`[DELETE] Parent ${i} tier validation:`,{tier:r,index:h,expected:v,isValid:x}),x})){alert(`삭제는 각 부모 그룹별로 가장 높은 tier부터 순서대로만 가능합니다. (부모: ${i})`);return}}const n=[];for(const[i,a]of o.entries()){const c=Math.max(...a.map(d=>d.tierLevel||0));console.log(`[DELETE] Parent ${i} selected max tier:`,c);const l=g.value.some(d=>d.parentLockrCd===i&&!a.find(r=>r.id===d.id)&&(d.tierLevel||0)>c);console.log(`[DELETE] Parent ${i} has upper tiers:`,l),l&&n.push({parentKey:i,selectedMaxTier:c,reason:"선택된 최상단 락커 위에 더 높은 tier 존재"})}if(n.length>0){console.log("[DELETE] Blocked groups:",n),alert("선택된 락커들 중 일부 그룹에서 최상단 락커 위에 더 높은 tier가 있습니다. 가장 높은 tier부터 삭제해주세요.");return}go(),w.value=null,console.log("[Delete] Deleted lockers:",t)},mn=t=>{const e=t.match(/locker-(\d+)/);return e?parseInt(e[1]):null},go=async()=>{const t=y.value.size>0?Array.from(y.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=[];for(const s of t){const o=g.value.find(n=>n.id===s);if(o&&(o.tierLevel===0||!o.parentLockerId)){const n=mn(s);if(n)try{const i=await fetch(`${U}/lockrs/${n}/children`);if(i.ok){const a=await i.json(),c=a.children||a;c&&c.length>0&&e.push(o)}}catch(i){console.error("[DEBUG] Error checking children:",i)}}}if(e.length>0){alert("상단 락커가 존재합니다. 정면 배치모드에서 상단 락커를 먼저 삭제해주세요.");return}else{const s=t.length;if(!confirm(`삭제하시겠습니까? (${s}개 락커)`))return}t.forEach(s=>{D.deleteLocker(s)}),y.value.clear(),w.value=null,console.log("[Delete] Deleted lockers:",t)},yn=()=>{const e=(Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value).map(o=>parseInt(String(o.lockrNo||0))).filter(o=>o>0).sort((o,n)=>o-n);if(e.length===0)return[];const s=[];for(let o=1;o<e[e.length-1];o++)e.includes(o)||s.push(`L${o}`);return s},xn=t=>{y.value.size===0&&!w.value||(t.preventDefault(),wt.value=!0,Xe.value={x:t.clientX,y:t.clientY})},Se=()=>{wt.value=!1},wn=()=>{vo(),Se()},Ln=()=>{Se(),tt.value=!0,ve.value=1,le(()=>{const t=Bt.value;t&&(t.focus(),t.select())})},po=async()=>{const t=Number(ve.value);if(isNaN(t)||t<1||t>9){alert("단수는 1부터 9까지 숫자만 입력 가능합니다.");return}if(L.value!=="front"){alert("단수 추가는 정면배치모드(Front View)에서만 가능합니다.");return}console.log("[AddFloors] Loading latest locker data from database..."),await ce(),console.log("[AddFloors] Latest data loaded, processing tier addition...");const e=Array.from(y.value).map(o=>g.value.find(n=>n.id===o)).filter(Boolean),s=e.map(async o=>{let n=o,i=null;if(o.parentLockerId||o.parentLockrCd){if(i=g.value.find(d=>d.id===o.parentLockerId||d.lockrCd===o.parentLockrCd),!i){console.error(`[AddFloors] Parent not found for child locker ${o.number}`);return}n=i,console.log(`[AddFloors] Selected locker is CHILD (${o.number}), using parent (${n.number})`)}else console.log(`[AddFloors] Selected locker is PARENT (${n.number})`);console.log("[AddFloors] Finding existing children for parent:",{parentId:n.id,parentLockrCd:n.lockrCd,parentNumber:n.number});const a=g.value.filter(d=>{const r=d.parentLockrCd&&d.parentLockrCd===n.lockrCd||d.parentLockerId&&d.parentLockerId===n.id;return r&&console.log("[AddFloors] Found existing child:",{childId:d.id,childNumber:d.number,parentLockrCd:d.parentLockrCd,parentLockerId:d.parentLockerId,tierLevel:d.tierLevel||0}),r}),c=a.reduce((d,r)=>Math.max(d,r.tierLevel||0),0),l=c>0?c+1:1;console.log("[AddFloors] Tier level calculation:",{existingChildrenCount:a.length,maxExistingTier:c,startTierLevel:l,algorithm:c>0?`Children exist -> Start from tier ${l}`:"No children -> Start from tier 1"}),console.log(`[AddFloors] Adding ${t} tiers to parent locker:`,{number:n.number,parentLockrCd:n.lockrCd,existingChildren:a.length,existingChildrenDetails:a.map(d=>({number:d.number,tierLevel:d.tierLevel})),maxExistingTier:c,startTierLevel:l,frontViewX:n.frontViewX,frontViewY:n.frontViewY});try{const d={tierCount:t,startTierLevel:l,parentFrontViewX:n.frontViewX,parentFrontViewY:n.frontViewY};console.log("[AddFloors] Sending to backend:",d);const h=await(await fetch(`${U}/lockrs/${n.lockrCd}/tiers`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d)})).json();if(h.success)console.log(`[AddFloors] Successfully added ${h.count} tiers starting from level ${l}`);else throw console.error("[AddFloors] Failed to add tiers:",h.error),new Error(h.error)}catch(d){throw console.error("[AddFloors] Error adding tiers:",d),d}});try{await Promise.all(s),console.log("[AddFloors] All tiers added successfully")}catch(o){console.error("[AddFloors] Some tiers failed to add:",o),alert("티어 추가 중 오류가 발생했습니다: "+o.message);return}tt.value=!1,console.log(`[Context Menu] Added ${t} tiers to ${e.length} lockers`),ce().then(()=>{le(()=>{console.log("[AddFloors] Applying front view transformation for new tiers...");try{_e(),console.log("[AddFloors] Front view transformation completed for new tiers")}catch(o){console.error("[AddFloors] Front view transformation failed:",o),ro()}})}),lo()},bn=t=>{const e=t.target,o=e.value.replace(/[^0-9]/g,"");if(o!==""){const n=parseInt(o);n>9?(e.value="9",ve.value=9):n<1?(e.value="1",ve.value=1):(e.value=o,ve.value=n)}else e.value="",ve.value=1},Cn=()=>{Se();const t=Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value,e=new Set(t.map(o=>o.lockrNo).filter(o=>o&&o>0));let s=1;for(;e.has(s);)s++;console.log("[Number Dialog] 기존 번호:",Array.from(e).sort((o,n)=>o-n)),console.log(`[Number Dialog] 첫 번째 빈 번호: ${s}`),nt.value=!0,st.value=s,ke.value="horizontal",Ae.value=!1,Te.value=!1,le(()=>{const o=jt.value;o&&(o.focus(),o.select())})},En=()=>{console.log("[Grouping Analysis] Starting analysis..."),console.log("[TEST] Running test with known data first..."),Dn();const t=g.value.filter(s=>!s.parentLockrCd);if(t.length===0){xt.value="분석할 락커가 없습니다.",Ve.value=!0;return}console.log("[REAL DATA] Now analyzing actual lockers...");let e=`세로배치 순서별 그룹 분석
`;e+=`━━━━━━━━━━━━━━━━━━━━━
`;try{const s=co(t),o=uo(s);if(o.forEach((n,i)=>{e+=`대그룹 ${i+1} (${n.length}개 락커):
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;const a=St(n),c=ho(a);if(c.forEach((l,d)=>{const h=fo(l).map(x=>{const f=t.find(b=>b.id===x.id);return`${(f==null?void 0:f.number)||x.id}(${(f==null?void 0:f.rotation)||0}°)`}).join(", ");let v="";if(l.length===1?v="단독":v="인접 (같은방향)",e+=`  소그룹 ${i+1}-${d+1}: ${h} - ${v}
`,l.length>1){e+=`    소그룹 내 거리:
`;for(let x=0;x<l.length-1;x++)for(let f=x+1;f<l.length;f++)if(It(l[x],l[f])){const b=Yt(l[x],l[f]),N=l[x].number||l[x].id,p=l[f].number||l[f].id;e+=`      ${N} ↔ ${p}: ${b.toFixed(2)}px
`}}}),c.length>1){e+=`  소그룹 간 거리:
`;for(let l=0;l<c.length-1;l++)for(let d=l+1;d<c.length;d++){let r=1/0,h={l1:"",l2:""};for(const v of c[l])for(const x of c[d]){const f=Yt(v,x);f<r&&(r=f,h.l1=v.number||v.id,h.l2=x.number||x.id)}e+=`    소그룹 ${i+1}-${l+1} ↔ 소그룹 ${i+1}-${d+1}: ${r.toFixed(2)}px (${h.l1} - ${h.l2})
`}}e+=`
`}),o.length>1){e+=`대그룹 간 거리:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;for(let n=0;n<o.length-1;n++)for(let i=n+1;i<o.length;i++){let a=1/0,c={l1:"",l2:""};for(const l of o[n])for(const d of o[i]){const r=Yt(l,d);r<a&&(a=r,c.l1=l.number||l.id,c.l2=d.number||d.id)}e+=`  대그룹 ${n+1} ↔ 대그룹 ${i+1}: ${a.toFixed(2)}px (${c.l1} - ${c.l2})
`}e+=`
`}e+=`요약:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`,e+=`총 대그룹: ${s.length}개
`,e+=`총 소그룹: ${o.reduce((n,i)=>n+St(i).length,0)}개
`,e+=`
💡 이 순서는 세로배치 시 실제 표시 순서와 동일합니다.`}catch(s){console.error("[Grouping Analysis] Error:",s),e+=`분석 중 오류가 발생했습니다.
`,e+=s.message}xt.value=e,Ve.value=!0},Rt=()=>{const t=Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value;console.log("[findNextAvailableLabel] Total lockers in zone:",t.length);const e=t.map(o=>{const n=o.number||o.lockrLabel||"",i=n.toString().match(/^L(\d+)$/),a=i?parseInt(i[1]):0;return a>0&&console.log(`[findNextAvailableLabel] Found label ${n} -> number ${a}`),a}).filter(o=>o>0).sort((o,n)=>o-n);if(console.log("[findNextAvailableLabel] Assigned numbers:",e),e.length===0)return console.log("[findNextAvailableLabel] No existing labels, returning L1"),"L1";for(let o=1;o<e[e.length-1];o++)if(!e.includes(o))return console.log(`[findNextAvailableLabel] Found gap at ${o}, returning L${o}`),`L${o}`;const s=e[e.length-1]+1;return console.log(`[findNextAvailableLabel] No gaps found, returning L${s}`),`L${s}`},Mn=(t,e)=>{if(t.length===0)return[];const s=20;if(e){const o=new Map;return t.forEach(n=>{const i=n.frontViewY||n.y;let a=null;for(let[c]of o)if(Math.abs(i-c)<=s){a=c;break}a!==null?o.get(a).push(n):o.set(i,[n])}),Array.from(o.entries()).sort((n,i)=>n[0]-i[0]).map(([,n])=>n.sort((i,a)=>(i.frontViewX||i.x)-(a.frontViewX||a.x)))}else{const o=new Map;return t.forEach(n=>{const i=n.frontViewX||n.x;let a=null;for(let[c]of o)if(Math.abs(i-c)<=s){a=c;break}a!==null?o.get(a).push(n):o.set(i,[n])}),Array.from(o.entries()).sort((n,i)=>n[0]-i[0]).map(([,n])=>n.sort((i,a)=>(i.frontViewY||i.y)-(a.frontViewY||a.y)))}},mo=async()=>{be.value=!0,ge.value="번호 할당을 준비중입니다...";try{const t=Y.value?D.lockers.filter(f=>f.zoneId===Y.value.id):g.value,e=new Set(t.map(f=>f.lockrNo).filter(f=>f&&f>0));console.log("[Number Assignment] Step 1 - 기존 번호들:",Array.from(e).sort((f,b)=>f-b));const s=Array.from(y.value).map(f=>g.value.find(b=>b.id===f)).filter(Boolean);s.length>0&&(console.log("[Number Assignment] 샘플 락커 전체 데이터:",s[0]),console.log("[Number Assignment] 샘플 락커 주요 필드:",{id:s[0].id,lockrNo:s[0].lockrNo,lockrNoType:typeof s[0].lockrNo,number:s[0].number,numberType:typeof s[0].number,lockrCd:s[0].lockrCd,LOCKR_NO:s[0].LOCKR_NO,LOCKR_NO_Type:typeof s[0].LOCKR_NO}));const o=[],n=[];if(s.forEach((f,b)=>{const N=f.lockrNo||f.LOCKR_NO||f.number,p=Number(N),C=!isNaN(p)&&p>0;b<3&&console.log(`[Number Assignment] 락커 ${b+1} 상세:`,{id:f.id.slice(-4),lockrNo:f.lockrNo,LOCKR_NO:f.LOCKR_NO,number:f.number,converted:p,hasNumber:C}),C?(f.lockrNo=p,o.push(f)):n.push(f)}),console.log(`[Number Assignment] Step 2 - 선택된 락커: 총 ${s.length}개`),console.log(`  - 번호 있음: ${o.length}개`,o.map(f=>`L${f.lockrNo}`)),console.log(`  - 번호 없음: ${n.length}개`),n.length===0){alert("선택한 모든 락커에 이미 번호가 부여되어 있습니다."),be.value=!1;return}const i=ke.value==="horizontal";let a=Mn(n,i);Te.value&&a.reverse(),Ae.value&&a.forEach(f=>f.reverse());const c=a.flat();console.log("[Number Assignment] Step 2 - 정렬 완료:",c.map((f,b)=>`${b+1}번째: ${f.id.slice(-4)}`));const l=st.value||1;let d=l;const r=[],h=[];J.value==="odd"&&d%2===0?(d++,console.log(`[Number Assignment] 홀수 모드: 시작번호를 ${l}에서 ${d}로 조정`)):J.value==="even"&&d%2===1&&(d++,console.log(`[Number Assignment] 짝수 모드: 시작번호를 ${l}에서 ${d}로 조정`)),console.log(`[Number Assignment] Step 3 - 시작번호: ${d}, 할당할 락커 수: ${c.length}, 모드: ${J.value}`),ge.value=`락커 번호를 할당중입니다... (0/${c.length})`;let v=0;for(const f of c){for(;e.has(d);)console.log(`  - ${d}번은 이미 사용중, 다음 번호 확인`),J.value==="all"?d++:d+=2;console.log(`  - ${f.id.slice(-4)} 락커에 ${d}번 할당`),D.updateLocker(f.id,{lockrNo:d}),f.lockrCd&&r.push({lockrCd:f.lockrCd,LOCKR_NO:d}),h.push(`${v+1}. ${f.id.slice(-4)} → L${d}`),e.add(d),J.value==="all"?d++:d+=2,v++,ge.value=`락커 번호를 할당중입니다... (${v}/${c.length})`}if(console.log("[Number Assignment] Step 3 완료 - 할당 내역:",h),r.length>0)try{ge.value=`데이터베이스에 ${r.length}개 락커 번호를 저장중입니다...`,console.log(`[Number Assignment] Step 4 - DB 배치 업데이트 시작: ${r.length}개`),await Oo(r),console.log("[Number Assignment] Step 4 완료 - DB 업데이트 성공"),ge.value="번호 할당이 완료되었습니다!"}catch(f){console.error("[Number Assignment] DB 업데이트 실패:",f),ge.value="데이터베이스 저장에 실패했습니다.",alert("데이터베이스 저장 중 오류가 발생했습니다. 다시 시도해주세요.");return}console.log("[Number Assignment] 전체 프로세스 완료"),console.log(`  - 총 ${n.length}개 락커에 번호 할당 완료`),console.log(`  - ${o.length}개 락커는 기존 번호 유지`);const x=yn();x.length>0&&console.log("[Number Assignment] 번호 갭 발견:",x),setTimeout(()=>{nt.value=!1},500)}catch(t){console.error("[Number Assignment] Assignment failed:",t),ge.value="번호 할당 중 오류가 발생했습니다.",alert("번호 할당 중 오류가 발생했습니다. 다시 시도해주세요.")}finally{be.value=!1}},kn=async()=>{if(Se(),confirm("선택된 락커의 번호를 삭제하시겠습니까?")){const t=Array.from(y.value).map(async e=>{try{D.updateLocker(e,{lockrNo:void 0});const s=g.value.find(o=>o.id===e);s&&s.lockrCd&&await qt(s.lockrCd,{LOCKR_NO:0})}catch(s){console.error(`[Number Deletion] Failed to delete number for locker ${e}:`,s)}});await Promise.all(t)}},An=()=>{console.log("[Overlap Fix] Starting overlap detection and fix...");let t=0;for(let e=0;e<g.value.length;e++){const s=g.value[e],o=ie(s);for(let n=e+1;n<g.value.length;n++){const i=g.value[n],a=ie(i),c=Math.min(o.x+o.width,a.x+a.width)-Math.max(o.x,a.x),l=Math.min(o.y+o.height,a.y+a.height)-Math.max(o.y,a.y),d=.5;if(c>d&&l>d){let r=i.x,h=i.y;if(Math.abs(c)<Math.abs(l))if(a.x<o.x+o.width/2){const b=Math.max(Math.abs(c)+4,4);r=i.x-b}else{const b=Math.max(Math.abs(c)+4,4);r=i.x+b}else if(a.y<o.y+o.height/2){const b=Math.max(Math.abs(l)+4,4);h=i.y-b}else{const b=Math.max(Math.abs(l)+4,4);h=i.y+b}r=ut(r),h=ut(h);const v=te(i);r=Math.max(0,Math.min(r,Q.value-v.width)),h=Math.max(0,Math.min(h,ee.value-v.height));const x=i.x,f=i.y;D.updateLocker(i.id,{x:r,y:h}),t++,console.log(`[Overlap Fix] Moved ${i.id} from (${x}, ${f}) to (${r}, ${h})`)}}}return t>0?console.log(`[Overlap Fix] Fixed ${t} overlapping lockers`):console.log("[Overlap Fix] No overlaps detected"),t},ie=t=>{let e,s;if(t.type||t.id){const f=te(t);e=f.width,s=f.height}else e=t.width,s=t.height;const o=(t.rotation||0)*Math.PI/180;if(o===0)return{x:t.x,y:t.y,width:e,height:s,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s};const n=e/2,i=s/2,a=Math.cos(o),c=Math.sin(o),d=[{x:0,y:0},{x:e,y:0},{x:e,y:s},{x:0,y:s}].map(f=>{const b=f.x-n,N=f.y-i,p=b*a-N*c,C=b*c+N*a;return{x:t.x+n+p,y:t.y+i+C}}),r=Math.min(...d.map(f=>f.x)),h=Math.max(...d.map(f=>f.x)),v=Math.min(...d.map(f=>f.y)),x=Math.max(...d.map(f=>f.y));return{x:r,y:v,width:h-r,height:x-v,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s}},ut=(t,e=20)=>Math.round(t/e)*e,yo=(t,e,s,o,n,i=0)=>{const l=ie({x:t,y:e,width:s,height:o,rotation:i});let d=t,r=e,h=!1;console.log("=== SNAP PRIORITY DEBUG ==="),console.log("Checking corner snap first (priority 1)");for(const v of g.value){if(v.id===n)continue;const x=ie(v),f=x.x,b=x.y,N=x.width,p=x.height,C=[{existingX:f+N,existingY:b+p,dragX:l.x,dragY:l.y,type:"corner-bottom-right-to-top-left"},{existingX:f,existingY:b+p,dragX:l.x+l.width,dragY:l.y,type:"corner-bottom-left-to-top-right"},{existingX:f+N,existingY:b,dragX:l.x,dragY:l.y+l.height,type:"corner-top-right-to-bottom-left"},{existingX:f,existingY:b,dragX:l.x+l.width,dragY:l.y+l.height,type:"corner-top-left-to-bottom-right"}];for(const E of C){const k=Math.sqrt(Math.pow(E.existingX-E.dragX,2)+Math.pow(E.existingY-E.dragY,2));if(k<20){console.log(`[CORNER SNAP] ${E.type}, distance: ${k.toFixed(1)}`),d=t+(E.existingX-E.dragX),r=e+(E.existingY-E.dragY),h=!0;break}}if(h){console.log("Corner snap succeeded - skipping face-to-face snap");break}if(console.log("No corner snap - checking face-to-face snap (priority 2)"),Math.abs(f+N-l.x)<20&&!h){d=t+(f+N-l.x);const E=Math.abs(l.y-b),k=Math.abs(l.y+l.height-(b+p));E<20?r=e+(b-l.y):k<20&&(r=e+(b+p-(l.y+l.height))),h=!0,console.log("[FACE SNAP] Right snap applied");continue}if(Math.abs(f-(l.x+l.width))<20&&!h){d=t+(f-(l.x+l.width));const E=Math.abs(l.y-b),k=Math.abs(l.y+l.height-(b+p));E<20?r=e+(b-l.y):k<20&&(r=e+(b+p-(l.y+l.height))),h=!0,console.log("[FACE SNAP] Left snap applied");continue}if(Math.abs(b+p-l.y)<20&&!h){r=e+(b+p-l.y);const E=Math.abs(l.x-f),k=Math.abs(l.x+l.width-(f+N));E<20?d=t+(f-l.x):k<20&&(d=t+(f+N-(l.x+l.width))),h=!0,console.log("[FACE SNAP] Bottom snap applied");continue}if(Math.abs(b-(l.y+l.height))<20&&!h){r=e+(b-(l.y+l.height));const E=Math.abs(l.x-f),k=Math.abs(l.x+l.width-(f+N));E<20?d=t+(f-l.x):k<20&&(d=t+(f+N-(l.x+l.width))),h=!0,console.log("[FACE SNAP] Top snap applied");continue}}return console.log("Final result: snapped =",h),{x:d,y:r}},Ot=(t,e,s,o,n=null,i=0,a=!1)=>{const c=ie({x:t,y:e,width:s,height:o,rotation:i});return g.value.some(l=>{if(l.id===n||P.value&&y.value.has(l.id))return!1;const d=ie(l),r=Math.min(c.x+c.width,d.x+d.width)-Math.max(c.x,d.x),h=Math.min(c.y+c.height,d.y+d.height)-Math.max(c.y,d.y),v=.5,x=r>v&&h>v;return x&&console.log("[COLLISION] Detected with",l.id,"- overlap:",`(${r.toFixed(1)}, ${h.toFixed(1)})`,"tolerance:",v),x})},Tn=()=>{console.log("[TEST] Creating test locker data with Adjacent/Connected thresholds..."),console.log("[TEST] ADJACENT: ≤30px + same direction, CONNECTED: 40-43px (any direction)");const t=[{id:"test-L1",number:"L1",x:100,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L2",number:"L2",x:165,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L3",number:"L3",x:230,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L4",number:"L4",x:312,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L5",number:"L5",x:377,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L6",number:"L6",x:442,y:100,width:40,height:60,rotation:90,color:"#BD10E0"}];return console.log("[TEST] Expected result: ALL in 1 major group (connected through L3↔L4)"),console.log("[TEST] Expected minor groups: [L1,L2,L3] (adjacent, 0°), [L4,L5,L6] (adjacent, 90°)"),console.log("[TEST] Key distances:"),console.log("[TEST]   L1↔L2: 25px (adjacent, same dir)"),console.log("[TEST]   L2↔L3: 25px (adjacent, same dir)"),console.log("[TEST]   L3↔L4: 42px (connected, diff dir)"),console.log("[TEST]   L4↔L5: 25px (adjacent, same dir)"),console.log("[TEST]   L5↔L6: 25px (adjacent, same dir)"),t},Dn=()=>{console.log("=== TESTING WITH KNOWN DATA ===");const t=[...g.value];g.value=Tn();const e=wo();return g.value=t,console.log("=== TEST COMPLETE ==="),e},ht=t=>{const e=t.x||t.left||0,s=t.y||t.top||0,o=t.width||60,n=t.height||t.depth||40,i=(t.rotation||0)*Math.PI/180,a=e+o/2,c=s+n/2;return[{x:-o/2,y:-n/2},{x:o/2,y:-n/2},{x:o/2,y:n/2},{x:-o/2,y:n/2}].map(d=>({x:a+d.x*Math.cos(i)-d.y*Math.sin(i),y:c+d.x*Math.sin(i)+d.y*Math.cos(i)}))},Yt=(t,e)=>{const s=ht(t),o=ht(e);let n=1/0;for(const i of s)for(const a of o){const c=Math.sqrt(Math.pow(i.x-a.x,2)+Math.pow(i.y-a.y,2));n=Math.min(n,c)}return n},xo=(t,e,s)=>{const o=ht(t),n=ht(e);let i=0;for(const a of o)for(const c of n)Math.sqrt(Math.pow(a.x-c.x,2)+Math.pow(a.y-c.y,2))<s&&i++;return i},It=(t,e)=>{const s=xo(t,e,To),o=Ge(t.rotation||0),n=Ge(e.rotation||0),i=o===n;return s>=2&&i},Vt=(t,e)=>{const s=xo(t,e,To);if(s>=1)return!0;if(s>=2){const o=Ge(t.rotation||0),n=Ge(e.rotation||0);return o!==n}return!1},wo=t=>{const e=[],s=new Set,o=t||g.value;return o.forEach(n=>{if(s.has(n.id))return;const i=[n];s.add(n.id);const a=[n];for(;a.length>0;){const c=a.shift();o.forEach(l=>{if(s.has(l.id))return;const d=It(c,l),r=Vt(c,l);(d||r)&&(i.push(l),s.add(l.id),a.push(l))})}e.push(i)}),e.forEach((n,i)=>{console.log(`  Group ${i+1}: ${n.map(a=>a.number||a.id).join(", ")}`)}),e},$n=async t=>{try{const s={LOCKR_KND_CD:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,LOCKR_KND_NM:t.name,X:0,Y:0,WIDTH:Q.value,HEIGHT:ee.value,COLOR:t.color||"#f0f9ff"};await Ro(s);const o=Ce.value.find(n=>n.LOCKR_KND_NM===t.name);o&&Be(o),Ye.value=!1}catch(e){console.error("Failed to save zone:",e),alert("Failed to save zone. Please try again.")}},Nn=async t=>{var e;try{const s={id:`locker-${Date.now()}`,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:`custom-${Date.now()}`,zoneId:((e=Y.value)==null?void 0:e.id)||null,x:0,y:0,rotation:0};await kt(s);try{const n=await fetch(`${U}/types`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LOCKR_TYPE_CD:`custom-${Date.now()}`,LOCKR_TYPE_NM:t.name,WIDTH:t.width,HEIGHT:t.height,DEPTH:t.depth,COLOR:t.color||"#3b82f6"})});n.ok?console.log("[Locker Registration] Type saved to backend successfully"):console.error("Failed to save locker type to backend:",await n.text())}catch(n){console.error("Error saving locker type to backend:",n)}const o={id:s.id,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:s.type};me.value.push(o),Ie.value=!1,console.log("[Locker Registration] New locker saved:",{id:s.id,name:s.name,dimensions:{width:s.width,depth:s.depth,height:s.height},type:s.type})}catch(s){console.error("Failed to save locker:",s),alert("Failed to save locker. Please try again.")}},_n=()=>{console.log("[Debug] All locker dimensions:"),g.value.forEach(t=>{console.log(`${t.type||t.name}:`,{id:t.id,width:t.width,height:t.height,depth:t.depth,actualHeight:t.actualHeight,position:{x:t.x,y:t.y}})}),console.log("[Snap System] Configuration:",{threshold:20,lockerCount:g.value.length,viewMode:L.value})},ft=(t,e)=>{if(!w.value)return;const s=Math.max(0,Math.min(w.value.x+t,Q.value-w.value.width)),o=Math.max(0,Math.min(w.value.y+e,ee.value-w.value.height));D.updateLocker(w.value.id,{x:s,y:o})},Xt=t=>{(t.ctrlKey||t.metaKey)&&(yt.value=!0);const e=t.target;if(e.tagName==="INPUT"||e.tagName==="TEXTAREA"){console.log("[Keyboard] Ignored - typing in input field");return}if(Ie.value||Ye.value){console.log("[Keyboard] Ignored - modal is open");return}if((t.ctrlKey||t.metaKey)&&t.shiftKey&&t.key==="F"){t.preventDefault();const s=An();s>0?(console.log(`[Keyboard] Fixed ${s} overlapping lockers`),alert(`Fixed ${s} overlapping lockers`)):(console.log("[Keyboard] No overlaps detected"),alert("No overlapping lockers found"));return}if((t.ctrlKey||t.metaKey)&&t.key==="a"){t.preventDefault(),g.value.forEach(s=>{y.value.add(s.id)}),g.value.length>0&&(w.value=g.value[0]),console.log("[Multi-Select] Selected all lockers");return}if(t.key==="r"||t.key==="R"){t.preventDefault(),w.value;return}if((t.ctrlKey||t.metaKey)&&t.key==="c"){if(L.value==="front"){console.log("[Copy] Disabled in front view mode");return}t.preventDefault(),y.value.size>0?(Ee.value=Array.from(y.value).map(s=>{const o=g.value.find(n=>n.id===s);return o?{...o}:null}).filter(Boolean),console.log("[Multi-Select] Copied",Ee.value.length,"lockers")):w.value&&(Ee.value=[{...w.value}],console.log("[Copy] Locker copied:",w.value.id));return}if((t.ctrlKey||t.metaKey)&&t.key==="v"&&Ee.value&&Ee.value.length>0&&Y.value){if(L.value==="front"){console.log("[Paste] Disabled in front view mode");return}t.preventDefault(),y.value.clear(),Ee.value.forEach((s,o)=>{const n={...s,id:`locker-${Date.now()}-${Math.random()}`,number:Rt(),x:s.x+20,y:s.y+20,zoneId:Y.value.id},i=D.addLocker(n);y.value.add(i.id),o===0&&(w.value=i)}),console.log("[Multi-Select] Pasted",Ee.value.length,"lockers");return}if((t.key==="Delete"||t.key==="Backspace")&&(w.value||y.value.size>0)&&(t.preventDefault(),vo()),(t.key==="g"||t.key==="G")&&(t.preventDefault(),ze.value=!ze.value,console.log(`[Alignment] Guides ${ze.value?"ON":"OFF"}`)),t.ctrlKey&&t.key==="z"&&(t.preventDefault(),D.undo()),t.ctrlKey&&t.key==="y"&&(t.preventDefault(),D.redo()),t.key==="Escape"&&(y.value.clear(),w.value=null,D.selectLocker(null)),w.value){const s=t.shiftKey?20:1;t.key==="ArrowLeft"?(t.preventDefault(),ft(-s,0)):t.key==="ArrowRight"?(t.preventDefault(),ft(s,0)):t.key==="ArrowUp"?(t.preventDefault(),ft(0,-s)):t.key==="ArrowDown"&&(t.preventDefault(),ft(0,s))}};vt(()=>g.value,t=>{if(w.value){const e=t.find(s=>s.id===w.value.id);e&&(w.value=e)}},{deep:!0}),vt(()=>L.value,async(t,e)=>{if(e&&t!==e){if(console.log(`[ViewMode Change] ${e} → ${t}, reloading lockers...`),await ce(),t==="front"&&e==="floor")console.log("[ViewMode Change] Transitioning from floor to front - recalculating positions..."),le(()=>{try{_e(),console.log("[ViewMode Change] Front view transformation completed")}catch(s){console.error("[ViewMode Change] Front view transformation failed:",s),ro()}});else if(t==="front"&&e==="front"){console.log("[ViewMode Change] Zone change in front view - checking for missing coordinates...");const s=g.value.filter(o=>o.frontViewX===null||o.frontViewX===void 0||o.frontViewY===null||o.frontViewY===void 0);s.length>0?(console.log(`[ViewMode Change] Found ${s.length} lockers with missing front view coordinates`),console.log("[ViewMode Change] Missing coordinates for lockers:",s.map(o=>o.number).join(", ")),console.log("[ViewMode Change] Recalculating positions for ALL lockers in zone using grouping logic"),le(()=>{try{_e(),console.log("[ViewMode Change] Zone-wide recalculation completed")}catch(o){console.error("[ViewMode Change] Zone-wide recalculation failed:",o)}})):console.log("[ViewMode Change] All lockers have saved positions - using DB coordinates")}}else e||console.log("[ViewMode Watcher] Initial mount - skipping reload (onMounted will handle it)")});const Sn=ae(()=>Pe.value||P.value?"grabbing":xe.value?"crosshair":yt.value&&y.value.size>0?"copy":y.value.size>0?"move":"default"),Rn=ae(()=>{const t=fe/F.value,e=Le/F.value,s=W.value.x,o=W.value.y;return`${s} ${o} ${t} ${e}`});vt(y,t=>{},{immediate:!0,deep:!0}),vt(lt,t=>{},{deep:!0}),Vn(async()=>{console.log("Component mounted, loading data..."),L.value="floor",console.log("[onMounted] Initial view mode set to:",L.value),ye.value=!0,Fe.value=!0;try{if(await Promise.all([Mt(),Zt()]),console.log("[onMounted] About to load lockers with view mode:",L.value),await ce(),await le(),ye.value=!1,Fe.value=!1,console.log("All data loading completed"),L.value==="floor"&&g.value.length>0&&setTimeout(()=>{De()},100),L.value==="front"){const t=g.value.filter(e=>e.frontViewX===null||e.frontViewX===void 0||e.frontViewY===null||e.frontViewY===void 0);t.length>0&&(console.log(`[onMounted] Found ${t.length} lockers with missing front view coordinates`),console.log("[onMounted] Auto-calculating positions for lockers:",t.map(e=>e.number).join(", ")),le(()=>{try{_e(),console.log("[onMounted] Auto-calculation completed")}catch(e){console.error("[onMounted] Auto-calculation failed:",e)}}))}Ce.value.length>0&&!Y.value&&(Be(Ce.value[0]),console.log("[Data Loading] Auto-selected first zone:",Ce.value[0].name))}catch(t){console.error("Error loading data:",t),ye.value=!1,Fe.value=!1}window.addEventListener("resize",Ct),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt),document.addEventListener("click",Se),D.zones.length>0&&Be(D.zones[0]),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt)});const Pt=t=>{!t.ctrlKey&&!t.metaKey&&(yt.value=!1)};return Xn(()=>{document.removeEventListener("keydown",Xt),document.removeEventListener("keyup",Pt),document.removeEventListener("click",Se),window.removeEventListener("resize",Ct)}),(t,e)=>{var s;return M(),T("div",Gn,[ye.value||Fe.value?(M(),T("div",Un,e[36]||(e[36]=[u("div",{class:"loading-spinner"},[u("div",{class:"spinner"}),u("p",null,"Loading locker data...")],-1)]))):(M(),T("div",Wn,[u("div",Zn,[u("aside",qn,[e[41]||(e[41]=u("h2",{class:"sidebar-title"},"락커 선택창",-1)),ye.value?(M(),T("div",Jn,e[37]||(e[37]=[u("p",null,"🔄 락커 타입을 불러오는 중...",-1)]))):Wt.value&&At.value.length===0?(M(),T("div",Qn,e[38]||(e[38]=[u("p",null,"📦 등록된 락커가 없습니다",-1),u("p",{class:"empty-hint"},"락커를 등록해주세요",-1)]))):At.value.length>0?(M(),T("div",es,[(M(!0),T(re,null,de(At.value,o=>{var n;return M(),T("div",{key:o.id,class:"locker-type-item-wrapper"},[u("div",{class:Re(["locker-type-item",{active:((n=Oe.value)==null?void 0:n.id)===o.id}]),onClick:i=>jo(o),onDblclick:i=>Uo(o),onContextmenu:se(i=>Bo(i,o),["prevent"]),style:{cursor:"pointer"}},[u("div",os,[(M(),T("svg",{width:(o.width||40)*2,height:(o.depth||o.width||40)*2,viewBox:`0 0 ${(o.width||40)*2} ${(o.depth||o.width||40)*2}`,class:"type-preview"},[u("rect",{x:"2",y:"2",width:Math.max((o.width||40)*2-4,1),height:Math.max((o.depth||o.width||40)*2-4,1),fill:o.color?`${o.color}20`:"#FFFFFF",stroke:"#9ca3af","stroke-width":.5*2,rx:2*2,ry:2*2,"shape-rendering":"crispEdges"},null,8,ss),u("line",{x1:10,y1:(o.depth||o.width||40)*2-5,x2:(o.width||40)*2-10,y2:(o.depth||o.width||40)*2-5,stroke:o.color||"#1e40af","stroke-width":"4",opacity:"0.9","stroke-linecap":"square",class:"front-indicator"},null,8,is)],8,ns))]),u("div",as,[u("span",ls,_(o.name||"Unknown"),1),u("span",rs,_(o.width)+"x"+_(o.depth||o.width)+"x"+_(o.height)+"cm ",1)])],42,ts),u("button",{class:"delete-type-button",onClick:se(i=>oo(o),["stop"]),title:"이 락커 타입 삭제"},e[39]||(e[39]=[u("svg",{width:"16",height:"16",viewBox:"0 0 16 16"},[u("path",{d:"M4 4 L12 12 M12 4 L4 12",stroke:"#ef4444","stroke-width":"2","stroke-linecap":"round"})],-1)]),8,cs)])}),128))])):V("",!0),Ke.value.length>0?(M(),T("div",ds,[e[40]||(e[40]=u("div",{class:"section-title"},"삭제된 타입",-1)),(M(!0),T(re,null,de(Ke.value,o=>(M(),T("div",{key:o,class:"deleted-type-item"},[u("span",null,_(Zo(o)),1),u("button",{onClick:n=>Wo(o),class:"restore-btn"},"복원",8,us)]))),128))])):V("",!0),u("button",{class:"register-locker-btn",onClick:e[0]||(e[0]=o=>Ie.value=!0)}," 락커 등록 ")]),u("main",hs,[u("div",fs,[u("div",vs,[(M(!0),T(re,null,de(Ce.value,o=>{var n,i;return M(),T("button",{key:o.id,class:Re(["zone-tab",{active:((n=Y.value)==null?void 0:n.id)===o.id}]),onClick:a=>Be(o),onContextmenu:a=>Ho(a,o)},[ue(_(o.name)+" ",1),((i=Y.value)==null?void 0:i.id)===o.id?(M(),T("span",ps)):V("",!0)],42,gs)}),128))]),u("div",ms,[u("button",{class:"zone-add-btn",onClick:e[1]||(e[1]=o=>Ye.value=!0)}," + 구역 추가 "),u("div",ys,[u("button",{class:Re(["mode-btn",{active:L.value==="floor"}]),onClick:e[2]||(e[2]=o=>ao("floor")),title:"평면배치모드 (P)"},e[42]||(e[42]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-475b1ce0><rect x="3" y="3" width="18" height="18" rx="2" data-v-475b1ce0></rect><rect x="7" y="7" width="4" height="4" data-v-475b1ce0></rect><rect x="13" y="7" width="4" height="4" data-v-475b1ce0></rect><rect x="7" y="13" width="4" height="4" data-v-475b1ce0></rect><rect x="13" y="13" width="4" height="4" data-v-475b1ce0></rect></svg><span data-v-475b1ce0>평면배치</span>',2)]),2),u("button",{class:Re(["mode-btn",{active:L.value==="front"}]),onClick:e[3]||(e[3]=o=>ao("front")),title:"정면배치모드 (F)"},e[43]||(e[43]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-475b1ce0><rect x="3" y="3" width="18" height="18" rx="2" data-v-475b1ce0></rect><line x1="3" y1="15" x2="21" y2="15" stroke-dasharray="2 2" data-v-475b1ce0></line><rect x="7" y="7" width="4" height="6" data-v-475b1ce0></rect><rect x="13" y="7" width="4" height="6" data-v-475b1ce0></rect></svg><span data-v-475b1ce0>정면배치</span>',2)]),2),u("button",{class:"mode-btn",onClick:En,title:"그룹핑 결과 확인"},e[44]||(e[44]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("circle",{cx:"12",cy:"12",r:"3"}),u("path",{d:"M12 1v6m0 6v6"}),u("path",{d:"m21 12-6-3-6 3-6-3"})],-1),u("span",null,"그룹핑 확인",-1)])),L.value==="floor"||L.value==="front"?(M(),T("div",xs,[u("button",{class:"zoom-btn",onClick:De,title:"모든 락커가 화면에 맞춤 (클릭)"},[e[45]||(e[45]=u("svg",{width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("rect",{x:"3",y:"3",width:"18",height:"18",rx:"2"}),u("path",{d:"M7 7h.01M7 12h.01M7 17h.01M12 7h.01M12 12h.01M12 17h.01M17 7h.01M17 12h.01M17 17h.01"})],-1)),u("span",null,_(Math.round(F.value*100))+"%",1)]),e[46]||(e[46]=u("div",{class:"zoom-hints"},[u("span",{class:"hint"},"Ctrl+스크롤: 줌"),u("span",{class:"hint"},"휠클릭+드래그: 이동")],-1))])):V("",!0),u("button",{class:"mode-btn debug-btn",onClick:e[4]||(e[4]=o=>ot.value=!0),title:"락커 데이터 상세 확인"},e[47]||(e[47]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("path",{d:"m9 12 2 2 4-4"}),u("path",{d:"M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"}),u("path",{d:"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"})],-1),u("span",null,"디버그 정보",-1)]))])])]),u("div",ws,[(M(),T("svg",{ref_key:"canvasRef",ref:mt,class:"canvas",width:"100%",height:"100%",viewBox:Rn.value,style:gt({cursor:Sn.value,margin:0,padding:0}),preserveAspectRatio:"none",onWheel:se(qo,["prevent"]),onMousedown:Jo,onMousemove:Qo,onMouseup:no,onMouseleave:no,onClick:en},[e[49]||(e[49]=Ft('<defs data-v-475b1ce0><pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse" data-v-475b1ce0><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e5e5e5" stroke-width="0.5" data-v-475b1ce0></path></pattern><filter id="buttonShadow" x="-50%" y="-50%" width="200%" height="200%" data-v-475b1ce0><feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" data-v-475b1ce0></feDropShadow></filter></defs><rect width="100%" height="100%" fill="url(#grid)" class="canvas-background" data-v-475b1ce0></rect>',2)),Y.value?(M(),T("rect",{key:0,x:"0",y:"0",width:Q.value,height:ee.value,fill:"none",stroke:"black","stroke-width":"1"},null,8,bs)):V("",!0),L.value==="front"?(M(),T("g",Cs,[u("line",{x1:0,y1:we,x2:qe,y2:we,stroke:"#94a3b8","stroke-width":"2","stroke-dasharray":"10,5"}),u("text",{x:W.value.x+20/F.value,y:we+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500"}," 바닥선 ",8,Es),u("text",{x:W.value.x+(fe-80)/F.value,y:we+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500","text-anchor":"end"}," 바닥선 ",8,Ms)])):V("",!0),(M(!0),T(re,null,de(Fo.value,o=>{var n,i;return M(),We(Kn,{key:o.id,locker:o,"is-selected":((n=w.value)==null?void 0:n.id)===o.id,"is-multi-selected":y.value.has(o.id),"should-hide-individual-outline":Ko.value.has(o.id)&&!P.value,"is-dragging":P.value&&y.value.has(o.id),"adjacent-sides":Xo(o.id),"view-mode":L.value,"is-transitioning-to-floor":_t.value,"show-number":!0,"show-rotate-handle":((i=w.value)==null?void 0:i.id)===o.id,"zoom-level":F.value,onClick:(a,c)=>tn(a,c),onContextmenu:se(xn,["prevent"]),onSelect:e[5]||(e[5]=a=>w.value=g.value.find(c=>c.id===a)),onDragstart:nn,onRotatestart:sn,onRotate:an,onRotateend:ln},null,8,["locker","is-selected","is-multi-selected","should-hide-individual-outline","is-dragging","adjacent-sides","view-mode","is-transitioning-to-floor","show-rotate-handle","zoom-level","onClick"])}),128)),lt.value.length>0&&!P.value?(M(),T("g",ks,[(M(!0),T(re,null,de(lt.value.filter(o=>o.length>1),(o,n)=>{var i,a,c,l;return M(),T("rect",{key:`group-${n}`,x:(((i=at(o))==null?void 0:i.minX)||0)-5,y:(((a=at(o))==null?void 0:a.minY)||0)-5,width:(((c=at(o))==null?void 0:c.width)||0)+10,height:(((l=at(o))==null?void 0:l.height)||0)+10,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"unified-selection-outline","pointer-events":"none"},e[48]||(e[48]=[u("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,As)}),128))])):V("",!0),w.value&&!P.value&&Z.value?(M(),T("g",Ts,[u("g",{transform:`translate(${Qt().x}, ${Qt().y}) rotate(${w.value.rotation||0}, ${w.value.width/2}, ${w.value.height/2})`},null,8,Ds)])):V("",!0),ze.value?(M(),T("g",$s,[(M(!0),T(re,null,de(eo.value,o=>(M(),T("line",{key:`h-${o.position}`,x1:0,y1:o.position,x2:Q.value,y2:o.position,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,Ns))),128)),(M(!0),T(re,null,de(to.value,o=>(M(),T("line",{key:`v-${o.position}`,x1:o.position,y1:0,x2:o.position,y2:ee.value,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,_s))),128))])):V("",!0),xe.value&&X.value.x!=null&&X.value.y!=null&&H.value.x!=null&&H.value.y!=null&&Math.abs((H.value.x||0)-(X.value.x||0))>5?(M(),T("rect",{key:5,x:Math.min(X.value.x||0,H.value.x||0),y:Math.min(X.value.y||0,H.value.y||0),width:Math.abs((H.value.x||0)-(X.value.x||0)),height:Math.abs((H.value.y||0)-(X.value.y||0)),fill:"rgba(0, 122, 255, 0.1)",stroke:"#007AFF","stroke-width":"1","stroke-dasharray":"5 5","pointer-events":"none",class:"selection-box"},null,8,Ss)):V("",!0)],44,Ls))])])])])),Ye.value?(M(),We(Hn,{key:2,onClose:e[6]||(e[6]=o=>Ye.value=!1),onSave:$n})):V("",!0),Ie.value?(M(),We(zn,{key:3,onClose:e[7]||(e[7]=o=>Ie.value=!1),onSave:Nn})):V("",!0),wt.value?(M(),T("div",{key:4,style:gt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:1e3}),class:"context-menu",onClick:e[8]||(e[8]=se(()=>{},["stop"]))},[L.value==="front"?(M(),T(re,{key:0},[u("div",{class:"context-menu-item",onClick:Ln},e[50]||(e[50]=[u("i",{class:"fas fa-layer-group"},null,-1),ue(" 단수 입력 ",-1)])),u("div",{class:"context-menu-item",onClick:Cn},e[51]||(e[51]=[u("i",{class:"fas fa-sort-numeric-up"},null,-1),ue(" 번호 부여 ",-1)])),u("div",{class:"context-menu-item",onClick:kn},e[52]||(e[52]=[u("i",{class:"fas fa-eraser"},null,-1),ue(" 번호 삭제 ",-1)]))],64)):V("",!0),u("div",{class:"context-menu-item",onClick:wn},e[53]||(e[53]=[u("i",{class:"fas fa-trash"},null,-1),ue(" 락커 삭제 ",-1)]))],4)):V("",!0),tt.value?(M(),T("div",Rs,[u("div",{class:"modal-content",onClick:e[11]||(e[11]=se(()=>{},["stop"]))},[e[55]||(e[55]=u("h3",null,"단수 입력",-1)),u("div",Os,[e[54]||(e[54]=u("label",null,"단수:",-1)),he(u("input",{ref_key:"floorInputRef",ref:Bt,"onUpdate:modelValue":e[9]||(e[9]=o=>ve.value=o),type:"number",min:"1",max:"9",placeholder:"1-9 사이 입력",class:"form-control",onInput:bn,onKeyup:bo(po,["enter"])},null,544),[[Lo,ve.value,void 0,{number:!0}]])]),u("div",Ys,[u("button",{class:"btn btn-secondary",onClick:e[10]||(e[10]=o=>tt.value=!1)},"취소"),u("button",{class:"btn btn-primary",onClick:po},"확인")])])])):V("",!0),nt.value?(M(),T("div",Is,[u("div",{class:"modal-content number-assign-modal",onClick:e[23]||(e[23]=se(()=>{},["stop"]))},[e[68]||(e[68]=u("h3",null,"번호 부여",-1)),u("div",Vs,[e[59]||(e[59]=u("div",{style:{display:"flex","justify-content":"space-between","margin-bottom":"10px"}},[u("label",null,"시작번호:"),u("label",{style:{"margin-right":"100px"}},"번호생성옵션:")],-1)),u("div",Xs,[he(u("input",{ref_key:"startNumberInputRef",ref:jt,"onUpdate:modelValue":e[12]||(e[12]=o=>st.value=o),type:"number",min:1,placeholder:"시작 번호",class:"form-control number-input",style:{width:"120px"},onKeyup:bo(mo,["enter"])},null,544),[[Lo,st.value,void 0,{number:!0}]]),u("div",Ps,[u("label",Fs,[he(u("input",{type:"radio","onUpdate:modelValue":e[13]||(e[13]=o=>J.value=o),value:"all"},null,512),[[Ze,J.value]]),e[56]||(e[56]=u("span",null,"전체",-1))]),u("label",Ks,[he(u("input",{type:"radio","onUpdate:modelValue":e[14]||(e[14]=o=>J.value=o),value:"odd"},null,512),[[Ze,J.value]]),e[57]||(e[57]=u("span",null,"홀수",-1))]),u("label",Hs,[he(u("input",{type:"radio","onUpdate:modelValue":e[15]||(e[15]=o=>J.value=o),value:"even"},null,512),[[Ze,J.value]]),e[58]||(e[58]=u("span",null,"짝수",-1))])])])]),u("div",zs,[e[62]||(e[62]=u("div",{class:"form-labels-row"},[u("label",{class:"section-label"},"생성방향:")],-1)),u("div",Bs,[u("div",js,[u("label",Gs,[he(u("input",{type:"radio","onUpdate:modelValue":e[16]||(e[16]=o=>ke.value=o),value:"horizontal"},null,512),[[Ze,ke.value]]),e[60]||(e[60]=u("span",null,"가로",-1))]),u("label",Us,[he(u("input",{type:"radio","onUpdate:modelValue":e[17]||(e[17]=o=>ke.value=o),value:"vertical"},null,512),[[Ze,ke.value]]),e[61]||(e[61]=u("span",null,"세로",-1))])])])]),u("div",Ws,[e[65]||(e[65]=u("label",{class:"section-label"},"추가옵션:",-1)),u("div",Zs,[u("div",qs,[u("label",Js,[e[63]||(e[63]=u("span",{style:{"margin-right":"8px"}},"역방향",-1)),he(u("input",{type:"checkbox","onUpdate:modelValue":e[18]||(e[18]=o=>Ae.value=o),onChange:e[19]||(e[19]=o=>console.log("역방향:",Ae.value)),style:{"margin-right":"5px"}},null,544),[[Co,Ae.value]]),u("span",Qs,"("+_(Ae.value?"활성":"비활성")+")",1)])]),u("div",null,[u("label",ei,[e[64]||(e[64]=u("span",{style:{"margin-right":"8px"}},"아래에서부터",-1)),he(u("input",{type:"checkbox","onUpdate:modelValue":e[20]||(e[20]=o=>Te.value=o),onChange:e[21]||(e[21]=o=>console.log("아래에서부터:",Te.value)),style:{"margin-right":"5px"}},null,544),[[Co,Te.value]]),u("span",ti,"("+_(Te.value?"활성":"비활성")+")",1)])])])]),be.value?(M(),T("div",oi,[u("div",ni,[e[66]||(e[66]=u("div",{class:"loading-spinner"},null,-1)),u("span",si,_(ge.value),1)])])):V("",!0),u("div",ii,[u("button",{class:"btn btn-secondary",onClick:e[22]||(e[22]=o=>nt.value=!1),disabled:be.value}," 취소 ",8,ai),u("button",{class:"btn btn-primary",onClick:mo,disabled:be.value},[be.value?(M(),T("span",ri,e[67]||(e[67]=[u("i",{class:"fas fa-spinner fa-spin"},null,-1),ue(" 처리중... ",-1)]))):(M(),T("span",ci,"번호 부여"))],8,li)])])])):V("",!0),Ve.value?(M(),T("div",{key:7,class:"modal-overlay",onClick:e[26]||(e[26]=o=>Ve.value=!1)},[u("div",{class:"modal-content grouping-popup",onClick:e[25]||(e[25]=se(()=>{},["stop"]))},[e[69]||(e[69]=u("h3",null,"대그룹 분석 결과",-1)),u("div",di,[u("pre",null,_(xt.value),1)]),u("div",ui,[u("button",{class:"btn btn-primary",onClick:e[24]||(e[24]=o=>Ve.value=!1)},"확인")])])])):V("",!0),ot.value?(M(),T("div",{key:8,class:"modal-overlay",onClick:e[30]||(e[30]=o=>ot.value=!1)},[u("div",{class:"modal-content debug-popup",onClick:e[29]||(e[29]=se(()=>{},["stop"]))},[e[76]||(e[76]=u("h3",null,"🔍 락커 데이터 디버깅 정보",-1)),u("div",hi,[e[74]||(e[74]=u("h4",null,"📊 전체 통계",-1)),u("div",fi,[u("div",vi,[e[70]||(e[70]=u("span",{class:"label"},"Store 전체:",-1)),u("span",gi,_(Kt(D).lockers.length)+"개",1)]),u("div",pi,[e[71]||(e[71]=u("span",{class:"label"},"현재 구역:",-1)),u("span",mi,_(g.value.length)+"개",1)]),u("div",yi,[e[72]||(e[72]=u("span",{class:"label"},"뷰모드:",-1)),u("span",xi,_(L.value),1)]),u("div",wi,[e[73]||(e[73]=u("span",{class:"label"},"선택 구역:",-1)),u("span",Li,_(((s=Y.value)==null?void 0:s.name)||"None"),1)])])]),u("div",bi,[u("h4",null,"🏢 Store 전체 락커 ("+_(Kt(D).lockers.length)+"개)",1),u("div",Ci,[(M(!0),T(re,null,de(Kt(D).lockers,o=>(M(),T("div",{key:o.id,class:Re(["locker-item",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",Ei,[u("span",Mi,_(o.number),1),u("span",ki,_(o.parentLockrCd?"자식":"부모"),1)]),u("div",Ai,[u("span",null,"ID: "+_(o.id),1),u("span",null,"Zone: "+_(o.zoneId),1),u("span",null,"Parent: "+_(o.parentLockrCd||"None"),1),u("span",null,"Height: "+_(o.actualHeight||o.height)+"px",1)])],2))),128))])]),u("div",Ti,[u("h4",null,"👁️ 현재 표시 락커 ("+_(g.value.length)+"개)",1),u("div",Di,[(M(!0),T(re,null,de(g.value,o=>(M(),T("div",{key:o.id,class:Re(["locker-item current",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",$i,[u("span",Ni,_(o.number),1),u("span",_i,_(o.parentLockrCd?"자식":"부모"),1),e[75]||(e[75]=u("span",{class:"render-status"},"표시중",-1))]),u("div",Si,[u("span",null,"위치: ("+_(o.x)+", "+_(o.y)+")",1),u("span",null,"크기: "+_(o.width)+"x"+_(o.height),1),u("span",null,"실제높이: "+_(o.actualHeight)+"px",1),u("span",null,"회전: "+_(o.rotation)+"°",1)])],2))),128))])]),u("div",Ri,[u("button",{class:"btn btn-secondary",onClick:e[27]||(e[27]=o=>ce())},"🔄 새로고침"),u("button",{class:"btn btn-primary",onClick:e[28]||(e[28]=o=>ot.value=!1)},"닫기")])])])):V("",!0),(M(),We(Eo,{to:"body"},[Qe.value?(M(),T("div",{key:0,class:"zone-context-menu",style:gt({position:"fixed",left:Lt.value.x+"px",top:Lt.value.y+"px",zIndex:9999}),onClick:e[33]||(e[33]=se(()=>{},["stop"]))},[u("div",{class:"zone-context-menu-item",onClick:e[31]||(e[31]=o=>t.editZone(bt.value))},e[77]||(e[77]=[u("span",{class:"zone-context-menu-icon"},"✏️",-1),ue(" 구역 수정 ",-1)])),u("div",{class:"zone-context-menu-item",onClick:e[32]||(e[32]=o=>zo(bt.value))},e[78]||(e[78]=[u("span",{class:"zone-context-menu-icon"},"🗑️",-1),ue(" 구역 삭제 ",-1)]))],4)):V("",!0)])),(M(),We(Eo,{to:"body"},[et.value?(M(),T("div",{key:0,class:"context-menu",style:gt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:9999}),onClick:e[35]||(e[35]=se(()=>{},["stop"]))},[u("div",{class:"context-menu-item",onClick:e[34]||(e[34]=o=>oo(zt.value))},e[79]||(e[79]=[u("span",{class:"context-menu-icon"},"🗑️",-1),ue(" 타입 삭제 ",-1)]))],4)):V("",!0)]))])}}}),Pi=Pn(Oi,[["__scopeId","data-v-475b1ce0"]]);export{Pi as default};
