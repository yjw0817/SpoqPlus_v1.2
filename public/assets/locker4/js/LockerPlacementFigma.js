var Vn=Object.defineProperty;var Kn=(D,u,f)=>u in D?Vn(D,u,{enumerable:!0,configurable:!0,writable:!0,value:f}):D[u]=f;var Dt=(D,u,f)=>Kn(D,typeof u!="symbol"?u+"":u,f);import{d as Xn,r as x,c as oe,a as St,b as Nt,e as O,o as A,n as Re,w as he,f as l,g as Q,t as j,h as ct,_ as Rt,i as fe,v as Ue,j as zn,F as be,k as $e,l as Bn,m as Ot,p as At,q as Hn,s as ze,u as Un,x as wt,y as Oe,z as xt,A as Mo,B as eo,T as $o}from"./index.js";function Te(){return typeof window<"u"&&window.LockerConfig?window.LockerConfig:null}function to(){return Te()!==null}function jn(){const D=Te();return D?D.apiUrl:"/api"}function Gn(){const D=Te();return(D==null?void 0:D.csrfToken)||""}function Wn(){const D=Te();return(D==null?void 0:D.csrfHeader)||"X-CSRF-TOKEN"}function To(){const D=Te();return{companyCode:(D==null?void 0:D.companyCode)||"001",officeCode:(D==null?void 0:D.officeCode)||"001"}}function Zn(){const D=Te();return(D==null?void 0:D.user)||{id:"",name:"",role:"",isLoggedIn:!1}}function qn(){var u;const D=Te();return((u=D==null?void 0:D.features)==null?void 0:u.enableDebugMode)||!1}function Jn(){qn()&&(console.log("[Locker4] Configuration:",Te()),console.log("[Locker4] Environment:",to()?"CodeIgniter":"Standalone"),console.log("[Locker4] API URL:",jn()),console.log("[Locker4] User:",Zn()))}typeof window<"u"&&window.addEventListener("DOMContentLoaded",()=>{Jn()});const Do={1:{width:40,height:40,depth:40},2:{width:50,height:60,depth:50},3:{width:60,height:80,depth:60}},So={1:"#3b82f6",2:"#10b981",3:"#f59e0b",4:"#8b5cf6",5:"#ef4444",6:"#14b8a6",7:"#f97316",8:"#6366f1"};class Qn{constructor(){Dt(this,"baseUrl");Dt(this,"headers");Dt(this,"useCodeIgniter");if(this.useCodeIgniter=to(),this.useCodeIgniter){const u=Te();this.baseUrl=u?u.baseUrl+"/api":"/api"}else this.baseUrl="http://localhost:3333/api";if(this.headers={"Content-Type":"application/json"},console.log("[LockerApi] Using API:",this.baseUrl),console.log("[LockerApi] CodeIgniter environment:",this.useCodeIgniter),this.useCodeIgniter){const u=Gn(),f=Wn();u&&f&&(this.headers[f]=u)}}dbToAppFormat(u){const f=String(u.LOCKR_TYPE_CD||"1"),T=Do[f]||Do[1]||{width:40,height:40,depth:40},w=So[f]||So[1];return{id:`locker-${u.LOCKR_CD}`,number:u.LOCKR_LABEL||"",x:u.X||0,y:u.Y||0,width:T.width||40,height:T.height||40,depth:T.depth||40,color:w,status:this.mapDbStatusToApp(u.LOCKR_STAT),rotation:u.ROTATION||0,zoneId:u.LOCKR_KND,typeId:u.LOCKR_TYPE_CD,lockrCd:u.LOCKR_CD,compCd:u.COMP_CD,bcoffCd:u.BCOFF_CD,lockrLabel:u.LOCKR_LABEL,lockrNo:u.LOCKR_NO,lockrKnd:u.LOCKR_KND,lockrTypeCd:u.LOCKR_TYPE_CD,doorDirection:u.DOOR_DIRECTION,groupNum:u.GROUP_NUM,lockrGendrSet:u.LOCKR_GENDR_SET,parentLockerId:(()=>{const G=u.PARENT_LOCKR_CD?`locker-${u.PARENT_LOCKR_CD}`:null;return u.LOCKR_LABEL&&u.LOCKR_LABEL.includes("-T"),G})(),parentLockrCd:u.PARENT_LOCKR_CD,childLockerIds:[],tierLevel:u.TIER_LEVEL||0,frontViewX:u.FRONT_VIEW_X,frontViewY:u.FRONT_VIEW_Y,frontViewNumber:u.LOCKR_NO?`${u.LOCKR_NO}`:void 0,memSno:u.MEM_SNO,memNm:u.MEM_NM,lockrUseSDate:u.LOCKR_USE_S_DATE,lockrUseEDate:u.LOCKR_USE_E_DATE,lockrStat:u.LOCKR_STAT,buyEventSno:u.BUY_EVENT_SNO,isVisible:!0,isAnimating:!1,hasError:!1,assignedTo:u.MEM_NM?{name:u.MEM_NM,expiryDate:u.LOCKR_USE_E_DATE?new Date(u.LOCKR_USE_E_DATE):new Date}:void 0,memo:u.MEMO,updateBy:u.UPDATE_BY,updateDt:u.UPDATE_DT}}appToDbFormat(u){const f=u.parentLockrCd||(u.parentLockerId?parseInt(u.parentLockerId.replace("locker-","")):null);return{LOCKR_LABEL:u.lockrLabel||u.number,X:u.x!==void 0?Math.round(u.x):0,Y:u.y!==void 0?Math.round(u.y):0,FRONT_VIEW_X:u.frontViewX?Math.round(u.frontViewX):void 0,FRONT_VIEW_Y:u.frontViewY?Math.round(u.frontViewY):void 0,ROTATION:u.rotation||0,DOOR_DIRECTION:u.doorDirection,GROUP_NUM:u.groupNum,LOCKR_GENDR_SET:u.lockrGendrSet,LOCKR_STAT:u.lockrStat||this.mapAppStatusToDb(u.status),LOCKR_KND:u.lockrKnd||u.zoneId,LOCKR_TYPE_CD:u.lockrTypeCd||u.typeId,PARENT_LOCKR_CD:f,TIER_LEVEL:u.tierLevel||0,LOCKR_NO:u.lockrNo,MEM_SNO:u.memSno,MEM_NM:u.memNm,LOCKR_USE_S_DATE:u.lockrUseSDate,LOCKR_USE_E_DATE:u.lockrUseEDate,BUY_EVENT_SNO:u.buyEventSno,MEMO:u.memo,UPDATE_BY:u.updateBy,COMP_CD:u.compCd||"001",BCOFF_CD:u.bcoffCd||"001"}}mapDbStatusToApp(u){return{"00":"available","01":"occupied","02":"occupied","03":"maintenance","04":"maintenance","05":"expired"}[u]||"available"}mapAppStatusToDb(u){return{available:"00",occupied:"01",expired:"05",maintenance:"03"}[u]||"00"}async handleResponse(u){if(u.status===401&&this.useCodeIgniter)throw window.location.href="/login",new Error("Authentication required");if(!u.ok)throw new Error(`HTTP error! status: ${u.status}`);return u.json()}async getLockers(u,f){try{if(this.useCodeIgniter){const N=To();u=u||N.companyCode,f=f||N.officeCode}const T=new URLSearchParams;u&&T.append("COMP_CD",u),f&&T.append("BCOFF_CD",f);const w=`${this.baseUrl}/lockrs?${T}`;console.log("[LockerApi] Fetching lockers from:",w);const G=await fetch(w,{method:"GET",headers:this.headers,credentials:"omit"}),S=await this.handleResponse(G),R=S.lockers||S;console.log("[LockerApi] Received",R.length,"lockers from backend");const Y=R.map((N,W)=>this.dbToAppFormat(N));return Y.forEach(N=>{if(N.parentLockerId){const W=Y.find(k=>k.id===N.parentLockerId);W&&(W.childLockerIds||(W.childLockerIds=[]),W.childLockerIds.push(N.id))}}),Y}catch(T){return console.error("[API] Failed to fetch lockers:",T),[]}}async getAllLockers(){return this.getLockers()}async saveLocker(u){try{const f=this.appToDbFormat(u),T=u.id.includes("temp")||u.id.includes("new");if(this.useCodeIgniter){const Y=To();f.COMP_CD=f.COMP_CD||Y.companyCode,f.BCOFF_CD=f.BCOFF_CD||Y.officeCode}const w=T?`${this.baseUrl}/lockrs`:`${this.baseUrl}/lockrs/${this.extractDbId(u.id)}`,G=await fetch(w,{method:T?"POST":"PUT",headers:this.headers,body:JSON.stringify(f),credentials:"omit"});if(!G.ok)throw new Error(`HTTP error! status: ${G.status}`);const R=await G.json();return this.dbToAppFormat(R)}catch(f){return console.error("[API] Failed to save locker:",f),null}}async deleteLocker(u){try{const f=this.extractDbId(u),T=`${this.baseUrl}/lockrs/${f}`;return(await fetch(T,{method:"DELETE",headers:this.headers,credentials:"omit"})).ok}catch(f){return console.error("[API] Failed to delete locker:",f),!1}}async batchSaveLockers(u){let f=0;for(const T of u)await this.saveLocker(T)&&f++;return f}async testConnection(){try{return(await fetch(`${this.baseUrl}/health`,{method:"GET",headers:this.headers})).ok}catch(u){return console.error("[API] Database connection test failed:",u),!1}}async addTiers(u,f,T,w,G){try{console.log("[API DEBUG] addTiers called with:",{parentLockrCd:u,tierCount:f,parentFrontViewX:T,parentFrontViewY:w,startTierLevel:G}),console.log("[API DEBUG] baseUrl:",this.baseUrl);const S=`${this.baseUrl}/lockrs/${u}/tiers`;console.log("[API DEBUG] Request URL:",S);const R=await fetch(S,{method:"POST",headers:this.headers,body:JSON.stringify({tierCount:f,parentFrontViewX:T,parentFrontViewY:w,startTierLevel:G})});if(!R.ok)throw new Error(`HTTP error! status: ${R.status}`);const Y=await R.json();return(Y.tiers||Y).map((k,ae)=>this.dbToAppFormat(k))}catch(S){return console.error("[API] Failed to add tiers:",S),[]}}async getChildren(u){try{const f=await fetch(`${this.baseUrl}/lockrs/${u}/children`,{method:"GET",headers:this.headers});if(!f.ok)throw new Error(`HTTP error! status: ${f.status}`);const T=await f.json();return(T.children||T).map(G=>this.dbToAppFormat(G))}catch(f){return console.error("[API] Failed to get children:",f),[]}}async updateLocker(u,f){try{const T=this.appToDbFormat(f),w=await fetch(`${this.baseUrl}/lockrs/${u}`,{method:"PUT",headers:this.headers,body:JSON.stringify(T)});if(!w.ok)throw new Error(`HTTP error! status: ${w.status}`);const G=await w.json();return this.dbToAppFormat(G)}catch(T){return console.error("[API] Failed to update locker:",T),null}}async createLocker(u){try{const f=this.appToDbFormat(u),T=await fetch(`${this.baseUrl}/lockrs`,{method:"POST",headers:this.headers,body:JSON.stringify(f)});if(!T.ok)throw new Error(`HTTP error! status: ${T.status}`);const w=await T.json();return this.dbToAppFormat(w)}catch(f){return console.error("[API] Failed to create locker:",f),null}}extractDbId(u){const f=u.match(/\d+/);return f?parseInt(f[0]):0}}const rt=new Qn,es=Xn("locker",()=>{const D=x([]),u=x([]),f=x([{id:"1",name:"소형",width:40,depth:40,height:40,color:"#3b82f6"},{id:"2",name:"중형",width:50,depth:50,height:60,color:"#10b981"},{id:"3",name:"대형",width:60,depth:60,height:80,color:"#f59e0b"}]),T=x(null),w=x("floor"),G=x("flat"),S=x(1),R=x([]),Y=x(-1),N=x(!0),W=x(!1),k=x(null),ae=x("disconnected"),J=oe(()=>D.value.find(p=>p.id===T.value)),Ie=oe(()=>{const p={total:D.value.length,available:0,occupied:0,expired:0,maintenance:0};return D.value.forEach(z=>{p[z.status]++}),p}),je=oe(()=>D.value.filter(p=>p.floor===S.value||!p.floor)),ye=()=>{R.value=R.value.slice(0,Y.value+1),R.value.push(JSON.parse(JSON.stringify(D.value))),Y.value++,R.value.length>50&&(R.value.shift(),Y.value--)},Ge=async p=>{const z=`temp-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,K={...p,rotation:p.rotation||0,id:z};if(ye(),D.value.push(K),console.log("[Store] Added locker with rotation:",K.rotation),N.value){W.value=!0;try{const P=await rt.saveLocker(K);if(P){const se=D.value.findIndex(te=>te.id===z);se!==-1&&(D.value[se]=P),console.log("[Store] Locker saved to database:",P.id)}else console.warn("[Store] Failed to save to database, keeping local copy")}catch(P){console.error("[Store] Database save error:",P)}finally{W.value=!1}}return K},Fe=async(p,z,K=!1)=>{const P=D.value.findIndex(se=>se.id===p);if(P!==-1){if(ye(),"rotation"in z&&(isNaN(z.rotation)||z.rotation===void 0)&&(console.warn("[Store] Invalid rotation value, using existing or 0"),z.rotation=D.value[P].rotation||0),D.value[P]={...D.value[P],...z},N.value&&!p.includes("temp")&&!K){W.value=!0;try{await rt.saveLocker(D.value[P])||console.warn("[Store] Failed to sync update to database")}catch(se){console.error("[Store] Database update error:",se)}finally{W.value=!1}}return D.value[P]}return null},De=p=>{ye();const z=new Map(p.map(K=>[K.id,K.updates]));D.value=D.value.map(K=>{const P=z.get(K.id);return P?("rotation"in P&&(isNaN(P.rotation)||P.rotation===void 0)&&(P.rotation=K.rotation||0),{...K,...P}):K}),console.log(`[Store] Batch updated ${p.length} lockers simultaneously`)},Pe=p=>D.value.find(z=>z.id===p)||null,We=async p=>{const z=D.value.findIndex(K=>K.id===p);if(z!==-1&&(ye(),D.value.splice(z,1),N.value&&!p.includes("temp"))){W.value=!0;try{await rt.deleteLocker(p)||console.warn("[Store] Failed to delete from database")}catch(K){console.error("[Store] Database delete error:",K)}finally{W.value=!1}}},Ze=()=>{Y.value>0&&(Y.value--,D.value=JSON.parse(JSON.stringify(R.value[Y.value])))},Ye=()=>{Y.value<R.value.length-1&&(Y.value++,D.value=JSON.parse(JSON.stringify(R.value[Y.value])))},qe=p=>{T.value=p},et=p=>{const z={...p,id:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`};return u.value.push(z),z},Se=p=>{w.value=p},me=p=>{G.value=p,console.log(`[Store] Placement mode changed to: ${p}`)},Ve=p=>{S.value=p},we=p=>{const z=(p.rotation||0)*Math.PI/180,K=Math.cos(z),P=Math.sin(z),se=p.x+p.width/2,te=p.y+p.height/2,ve=[{x:-p.width/2,y:-p.height/2},{x:p.width/2,y:-p.height/2},{x:p.width/2,y:p.height/2},{x:-p.width/2,y:p.height/2}].map(le=>({x:le.x*K-le.y*P+se,y:le.x*P+le.y*K+te})),ee=ve.map(le=>le.x),ie=ve.map(le=>le.y);return{left:Math.min(...ee),right:Math.max(...ee),top:Math.min(...ie),bottom:Math.max(...ie),width:Math.max(...ee)-Math.min(...ee),height:Math.max(...ie)-Math.min(...ie)}},L=(p,z,K,P=!1)=>{const se=K||p.zoneId,te=D.value.filter(ve=>ve.zoneId===se),ue=P?1:0;for(const ve of te){if(ve.id===z||ve.id===p.id)continue;const ee=we({...p,rotation:p.rotation||0}),ie=we(ve);P&&console.log("[Rotation Collision Check]",{rotating:{id:p.id||z,bounds:ee,rotation:p.rotation},checking:{id:ve.id,bounds:ie,rotation:ve.rotation}});const le=Math.max(ee.left,ie.left),tt=Math.min(ee.right,ie.right),Je=Math.max(ee.top,ie.top),It=Math.min(ee.bottom,ie.bottom),Le=tt-le,xe=It-Je;if(Le>ue&&xe>ue)return console.log("[Collision] Detected overlap:",{overlapWidth:Le,overlapHeight:xe,tolerance:ue,isRotating:P}),!0}return!1},V=()=>{u.value=[{id:"zone-1",name:"남자 탈의실",x:0,y:0,width:800,height:600,color:"#f0f9ff"},{id:"zone-2",name:"여자 탈의실",x:0,y:0,width:800,height:600,color:"#fef3c7"},{id:"zone-3",name:"혼용 탈의실",x:0,y:0,width:800,height:600,color:"#fee2e2"}];const p=40;[{id:"L1",zoneId:"zone-1",x:40,y:100,status:"available"},{id:"L2",zoneId:"zone-1",x:80,y:100,status:"occupied"},{id:"L3",zoneId:"zone-1",x:120,y:100,status:"available"},{id:"L4",zoneId:"zone-1",x:40,y:140,status:"expired"},{id:"L5",zoneId:"zone-1",x:80,y:140,status:"maintenance"},{id:"L6",zoneId:"zone-2",x:40,y:100,status:"available"},{id:"L7",zoneId:"zone-2",x:80,y:100,status:"occupied"},{id:"L8",zoneId:"zone-2",x:120,y:100,status:"available"},{id:"L9",zoneId:"zone-3",x:40,y:100,status:"available"},{id:"L10",zoneId:"zone-3",x:80,y:100,status:"occupied"}].forEach((K,P)=>{D.value.push({id:`locker-${P}`,number:K.id,x:K.x,y:K.y,width:p,depth:p,height:p,status:K.status,rotation:0,zoneId:K.zoneId,typeId:"1"})}),console.log("[Store] Test data initialized with adjacent lockers (no gaps)")},H=async()=>{if(console.log("[STORE] 🔥 loadLockersFromDatabase() called!"),console.log(`[STORE] isOnlineMode: ${N.value}`),console.log("[STORE] Stack trace:",new Error().stack),!!N.value){W.value=!0;try{console.log("[STORE] Calling lockerApi.getAllLockers()");const p=await rt.getAllLockers();console.log(`[STORE] Got ${p.length} lockers from API`),p.length>0?(D.value=p,k.value=new Date,ae.value="connected",console.log(`[Store] ✅ Loaded ${p.length} lockers from database`)):(console.log("[Store] No lockers found in database"),ae.value="connected")}catch(p){console.error("[Store] Failed to load from database:",p),ae.value="error"}finally{W.value=!1}}},ne=async p=>(N.value=p,p?await rt.testConnection()?(ae.value="connected",await H(),!0):(ae.value="error",N.value=!1,console.error("[Store] Cannot connect to database"),!1):(ae.value="disconnected",console.log("[Store] Switched to offline mode"),!0)),Z=async()=>{if(N.value){W.value=!0;try{const p=await rt.batchSaveLockers(D.value);console.log(`[Store] Synced ${p}/${D.value.length} lockers`),k.value=new Date}catch(p){console.error("[Store] Sync failed:",p)}finally{W.value=!1}}};return{lockers:D,zones:u,lockerTypes:f,selectedLockerId:T,viewMode:w,placementMode:G,currentFloor:S,selectedLocker:J,lockersByStatus:Ie,currentFloorLockers:je,addLocker:Ge,updateLocker:Fe,batchUpdateLockers:De,deleteLocker:We,selectLocker:qe,addZone:et,setViewMode:Se,setPlacementMode:me,setCurrentFloor:Ve,initTestData:V,undo:Ze,redo:Ye,checkCollision:L,getRotatedBounds:we,getLockerById:Pe,isOnlineMode:St(N),isSyncing:St(W),lastSyncTime:St(k),connectionStatus:St(ae),loadLockersFromDatabase:H,toggleOnlineMode:ne,syncToDatabase:Z}}),ts=["data-locker-id","transform"],os=["d"],ns=["x","y","width","height","fill","stroke","stroke-width","rx","ry","opacity"],ss=["y1","x2","y2","stroke"],as=["d","fill"],is=["x","y","dominant-baseline","font-size","fill"],ls=["x","y","font-size"],rs={key:5,class:"rotation-handle"},cs=["x1","x2"],ds=["cx"],us={key:0},hs=["x"],fs=["x"],vs=["cx"],ce=2,gs=Nt({__name:"LockerSVG",props:{locker:{},isSelected:{type:Boolean},isMultiSelected:{type:Boolean},isDragging:{type:Boolean},viewMode:{},isTransitioningToFloor:{type:Boolean},showNumber:{type:Boolean},showRotateHandle:{type:Boolean},hasError:{type:Boolean},shouldHideIndividualOutline:{type:Boolean},adjacentSides:{},zoomLevel:{}},emits:["click","select","dragstart","rotatestart","rotate","rotateend"],setup(D,{emit:u}){const f=D,T=oe(()=>f.viewMode==="front"&&f.locker.frontViewX!==void 0?f.locker.frontViewX:f.locker.x),w=oe(()=>f.viewMode==="front"&&f.locker.frontViewY!==void 0?f.locker.frontViewY:f.locker.y),G=u,S=x(!1),R=x(!1),Y=x(0),N=x(0),W=x(!1),k=x(0),ae=oe(()=>{const H=J.value.width+10,ne=J.value.height+10;if(f.isDragging&&f.adjacentSides&&f.adjacentSides.length>0){const Z=[],p={topLeft:"-5,-5",topRight:`${-5+H},-5`,bottomRight:`${-5+H},${-5+ne}`,bottomLeft:`-5,${-5+ne}`};return f.adjacentSides.includes("top")||Z.push(`M ${p.topLeft} L ${p.topRight}`),f.adjacentSides.includes("right")||Z.push(`M ${p.topRight} L ${p.bottomRight}`),f.adjacentSides.includes("bottom")||Z.push(`M ${p.bottomRight} L ${p.bottomLeft}`),f.adjacentSides.includes("left")||Z.push(`M ${p.bottomLeft} L ${p.topLeft}`),Z.join(" ")}return`M -5,-5 L ${-5+H},-5 L ${-5+H},${-5+ne} L -5,${-5+ne} Z`}),J=oe(()=>{if(!f.locker)return console.warn("[LockerSVG] props.locker is undefined, using defaults"),{width:40*ce,height:40*ce};const L=(f.locker.width||40)*ce,V=(f.locker.depth||40)*ce,H=(f.locker.height||40)*ce,ne=(f.locker.actualHeight||40)*ce;if(f.viewMode==="floor")return{width:L,height:V||H||L};{const Z=H||ne||60*ce;return{width:L,height:Z}}}),Ie=oe(()=>f.viewMode==="front"?3*ce:2*ce),je=oe(()=>{if(f.hasError||f.locker.hasError)return"#fee2e2";let L="#FFFFFF";if(f.locker.color)L=f.locker.color+"20";else switch(f.locker.status){case"available":L="#FFFFFF";break;case"occupied":L="#FFF7ED";break;case"expired":L="#FEF2F2";break;case"maintenance":L="#F9FAFB";break;default:L="#FFFFFF"}return f.isSelected?f.locker.color?f.locker.color+"30":L==="#FFFFFF"?"#E6F4FF":L:S.value?f.locker.color?f.locker.color+"25":L==="#FFFFFF"?"#F0F8FF":L:L}),ye=oe(()=>{if(f.hasError||f.locker.hasError)return"#ef4444";if(f.viewMode==="front")return"#9ca3af";let L="#D1D5DB";if(f.locker.color)L=f.locker.color;else switch(f.locker.status){case"available":L="#D1D5DB";break;case"occupied":L="#FB923C";break;case"expired":L="#EF4444";break;case"maintenance":L="#6B7280";break;default:L="#D1D5DB"}return f.isSelected||f.isMultiSelected?L:S.value&&f.locker.color||L}),Ge=oe(()=>{const L=f.zoomLevel||1;return f.hasError||f.locker.hasError?2*ce/L:f.isSelected||f.isMultiSelected||S.value?1*ce/L:.5*ce/L}),Fe=oe(()=>f.viewMode==="front"?4*ce:10*ce),De=oe(()=>{if(f.hasError||f.locker.hasError)return"#dc2626";if(f.locker.color)return f.locker.color;switch(f.locker.status){case"available":return"#6b7280";case"occupied":return"#ea580c";case"expired":return"#dc2626";case"maintenance":return"#374151";default:return"#6b7280"}}),Pe=oe(()=>{const V=J.value.height-7*ce,H=J.value.width,ne=7*ce,Z=Ie.value;return`
    M 0 ${V}
    L ${0+H} ${V}
    L ${0+H} ${V+ne-Z}
    Q ${0+H} ${V+ne} ${0+H-Z} ${V+ne}
    L ${0+Z} ${V+ne}
    Q 0 ${V+ne} 0 ${V+ne-Z}
    L 0 ${V}
    Z
  `}),We=oe(()=>{if(f.viewMode==="front")return"#374151";switch(f.locker.status){case"available":return"#374151";case"occupied":return"#92400E";case"expired":return"#991B1B";case"maintenance":return"#374151";default:return"#374151"}}),Ze=oe(()=>f.viewMode==="front"&&f.locker.tierLevel&&f.locker.tierLevel>0),Ye=oe(()=>f.isTransitioningToFloor&&f.locker.tierLevel&&f.locker.tierLevel>0),qe=()=>f.locker?f.viewMode==="floor"?f.locker.parentLockerId?"":f.locker.number||"":f.locker.lockrLabel||f.locker.frontViewNumber||f.locker.number||"":"",et=L=>{L.stopPropagation(),G("click",f.locker,L),G("select",f.locker.id),console.log("Locker clicked:",f.locker.id,"Ctrl:",L.ctrlKey,"Shift:",L.shiftKey)},Se=L=>{L.preventDefault(),G("dragstart",f.locker,L)},me=(L,V,H)=>{const ne=L.clientX-V,Z=L.clientY-H;let p=Math.atan2(Z,ne)*(180/Math.PI)+90;return p<0&&(p+=360),p},Ve=(L,V)=>{const H=(L%360+360)%360;let Z=(V%360+360)%360-H;return Z>180?Z-=360:Z<-180&&(Z+=360),Z},we=L=>{L.stopPropagation(),L.preventDefault(),R.value=!0,Y.value=f.locker.rotation||0,k.value=f.locker.rotation||0;const V=L.currentTarget.closest("g[data-locker-id]");if(!V)return;const H=V.getBoundingClientRect(),ne=H.left+H.width/2,Z=H.top+H.height/2;N.value=me(L,ne,Z);let p=N.value;const z=P=>{if(!R.value)return;const se=me(P,ne,Z),te=Ve(p,se);p=se,k.value+=te;let ue=k.value;if(P.shiftKey)ue=Math.round(ue/15)*15,W.value=!0;else if(P.altKey)W.value=!1;else{const ve=[0,45,90,135,180,225,270,315],ee=8;W.value=!1;const ie=(ue%360+360)%360;for(const le of ve)if(Math.abs(ie-le)<ee||le===0&&Math.abs(ie-360)<ee){const Je=Math.floor(ue/360);le===0?ie>180?ue=(Je+1)*360:ue=Je*360:ue=Je*360+le,W.value=!0;break}}G("rotate",f.locker.id,ue)},K=()=>{R.value&&(R.value=!1,W.value=!1,document.removeEventListener("mousemove",z),document.removeEventListener("mouseup",K),G("rotateend",f.locker.id))};document.addEventListener("mousemove",z),document.addEventListener("mouseup",K),G("rotatestart",f.locker,L)};return(L,V)=>(A(),O("g",{"data-locker-id":L.locker.id,transform:`translate(${T.value}, ${w.value}) rotate(${L.locker.rotation||0}, ${J.value.width/2}, ${J.value.height/2})`,onClick:he(et,["stop"]),onMousedown:he(Se,["prevent"]),onMouseenter:V[0]||(V[0]=H=>S.value=!0),onMouseleave:V[1]||(V[1]=H=>S.value=!1),class:Re(["locker-svg",{"locker-selected":L.isSelected,"locker-hovered":S.value,"locker-dragging":L.isDragging}]),style:{cursor:"move"}},[l("g",{class:Re({"child-locker-content":Ze.value,"child-locker-fade-out":Ye.value})},[(L.isSelected||L.isMultiSelected)&&!L.shouldHideIndividualOutline&&!L.isDragging?(A(),O("path",{key:0,d:ae.value,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"selection-outline"},V[2]||(V[2]=[l("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,os)):Q("",!0),l("rect",{x:L.viewMode==="front"?0:1,y:L.viewMode==="front"?0:1,width:L.viewMode==="front"?J.value.width:J.value.width-2,height:L.viewMode==="front"?J.value.height:J.value.height-2,fill:je.value,stroke:ye.value,"stroke-width":Ge.value,rx:Ie.value,ry:Ie.value,"shape-rendering":"crispEdges",opacity:R.value?.8:1,style:{transition:"opacity 0.2s ease"}},null,8,ns),L.viewMode==="floor"?(A(),O("line",{key:1,x1:10,y1:J.value.height-4,x2:J.value.width-10,y2:J.value.height-4,stroke:L.locker.color||"#1e40af","stroke-width":"4",opacity:"0.9","stroke-linecap":"square",class:"front-indicator"},null,8,ss)):Q("",!0),L.viewMode==="front"&&L.showNumber!==!1&&qe()?(A(),O("path",{key:2,d:Pe.value,fill:De.value,"shape-rendering":"crispEdges"},null,8,as)):Q("",!0),L.showNumber!==!1&&qe()?(A(),O("text",{key:3,x:J.value.width/2,y:L.viewMode==="front"?J.value.height-3*ce:J.value.height/2,"text-anchor":"middle","dominant-baseline":(L.viewMode==="front","middle"),"font-size":Fe.value,fill:L.viewMode==="front"?"#ffffff":We.value,"font-weight":"600",class:"locker-number",style:{"user-select":"none","pointer-events":"none"}},j(qe()),9,is)):Q("",!0),L.viewMode==="front"&&f.locker.lockrNo?(A(),O("text",{key:4,x:4*ce,y:6*ce,"text-anchor":"start","dominant-baseline":"middle","font-size":Fe.value,fill:"#374151","font-weight":"600",class:"locker-number-top",style:{"user-select":"none","pointer-events":"none"}},j(f.locker.lockrNo),9,ls)):Q("",!0),L.isSelected&&L.showRotateHandle?(A(),O("g",rs,[l("line",{x1:J.value.width/2,y1:0,x2:J.value.width/2,y2:-25,stroke:"#0768AE","stroke-width":"2",opacity:"0.8"},null,8,cs),l("circle",{cx:J.value.width/2,cy:-25,r:"8",fill:"#0768AE",stroke:"#ffffff","stroke-width":"2",style:ct({cursor:R.value?"grabbing":"grab"}),onMousedown:he(we,["stop"])},null,44,ds),R.value?(A(),O("g",us,[l("rect",{x:J.value.width/2-25,y:-50,width:"50",height:"20",rx:"10",fill:"white",stroke:"#0768AE","stroke-width":"1",opacity:"0.95"},null,8,hs),l("text",{x:J.value.width/2,y:-36,"text-anchor":"middle","font-size":"12",fill:"#0768AE","font-weight":"600"},j(Math.round(((L.locker.rotation||0)%360+360)%360))+"° ",9,fs),W.value?(A(),O("circle",{key:0,cx:J.value.width/2,cy:-25,r:"10",fill:"none",stroke:"#10b981","stroke-width":"2",opacity:"0.8"},V[3]||(V[3]=[l("animate",{attributeName:"r",values:"8;12;8",dur:"0.3s",begin:"0s"},null,-1)]),8,vs)):Q("",!0)])):Q("",!0)])):Q("",!0)],2)],42,ts))}}),ps=Rt(gs,[["__scopeId","data-v-cb315f51"]]),ms={class:"modal-overlay"},ys={class:"modal-container"},ws={class:"modal-header"},xs={class:"modal-body"},bs={class:"form-group"},Ls={class:"form-group"},Cs={class:"color-options"},ks=["onClick"],Es={class:"modal-footer"},Ms=["disabled"],$s=Nt({__name:"ZoneModal",emits:["close","save"],setup(D,{emit:u}){const f=u,T=x(""),w=x("#f0f9ff"),G=["#f0f9ff","#fef3c7","#fee2e2","#d1fae5","#f3e8ff","#fce7f3"],S=()=>{if(!T.value.trim()){alert("구역 이름을 입력해주세요.");return}f("save",{name:T.value.trim(),color:w.value})};return(R,Y)=>(A(),O("div",ms,[l("div",ys,[l("div",ws,[Y[4]||(Y[4]=l("h2",{class:"modal-title"},"구역 추가",-1)),l("button",{class:"close-btn",onClick:Y[0]||(Y[0]=N=>R.$emit("close"))},Y[3]||(Y[3]=[l("svg",{width:"20",height:"20",viewBox:"0 0 20 20",fill:"currentColor"},[l("path",{d:"M4 4 L16 16 M16 4 L4 16",stroke:"currentColor","stroke-width":"2"})],-1)]))]),l("div",xs,[l("div",bs,[Y[5]||(Y[5]=l("label",{for:"zone-name",class:"form-label"},"구역 이름",-1)),fe(l("input",{id:"zone-name","onUpdate:modelValue":Y[1]||(Y[1]=N=>T.value=N),type:"text",class:"form-input",placeholder:"예: 남자 탈의실",onKeyup:zn(S,["enter"])},null,544),[[Ue,T.value]])]),l("div",Ls,[Y[6]||(Y[6]=l("label",{class:"form-label"},"구역 색상 (선택)",-1)),l("div",Cs,[(A(),O(be,null,$e(G,N=>l("button",{key:N,class:Re(["color-option",{selected:w.value===N}]),style:ct({backgroundColor:N}),onClick:W=>w.value=N},null,14,ks)),64))])])]),l("div",Es,[l("button",{class:"btn-cancel",onClick:Y[2]||(Y[2]=N=>R.$emit("close"))}," 취소 "),l("button",{class:"btn-save",onClick:S,disabled:!T.value}," 추가 ",8,Ms)])])]))}}),Ts=Rt($s,[["__scopeId","data-v-12568931"]]),Ds={class:"modal-overlay"},Ss={class:"modal-header"},As={class:"modal-body"},_s={class:"form-group"},Os={class:"form-row"},Ns={class:"form-group"},Rs={class:"form-group"},Is={class:"form-group"},Fs={class:"form-group"},Ps={class:"form-group"},Ys={class:"modal-footer"},Vs=Nt({__name:"LockerRegistrationModal",emits:["close","save"],setup(D,{emit:u}){const f=u,T=x({name:"",width:40,depth:40,height:60,description:"",color:"#4A90E2"}),w=()=>{if(!T.value.name||!T.value.width||!T.value.height||!T.value.depth){alert("필수 정보를 입력해주세요");return}f("save",{...T.value})};return(G,S)=>(A(),O("div",Ds,[l("div",{class:"modal-content",onKeydown:S[9]||(S[9]=he(()=>{},["stop"])),onKeyup:S[10]||(S[10]=he(()=>{},["stop"]))},[l("div",Ss,[S[11]||(S[11]=l("h2",null,"락커 등록",-1)),l("button",{class:"close-btn",onClick:S[0]||(S[0]=R=>G.$emit("close"))},"×")]),l("div",As,[l("div",_s,[S[12]||(S[12]=l("label",null,"락커 타입 이름",-1)),fe(l("input",{"onUpdate:modelValue":S[1]||(S[1]=R=>T.value.name=R),type:"text",placeholder:"예: 소형, 중형, 대형",required:""},null,512),[[Ue,T.value.name]])]),l("div",Os,[l("div",Ns,[S[13]||(S[13]=l("label",null,"가로 (Width)",-1)),fe(l("input",{"onUpdate:modelValue":S[2]||(S[2]=R=>T.value.width=R),type:"number",min:"20",max:"200",placeholder:"cm",required:""},null,512),[[Ue,T.value.width,void 0,{number:!0}]])]),l("div",Rs,[S[14]||(S[14]=l("label",null,"깊이 (Depth)",-1)),fe(l("input",{"onUpdate:modelValue":S[3]||(S[3]=R=>T.value.depth=R),type:"number",min:"20",max:"200",placeholder:"cm",required:""},null,512),[[Ue,T.value.depth,void 0,{number:!0}]])]),l("div",Is,[S[15]||(S[15]=l("label",null,"높이 (Height)",-1)),fe(l("input",{"onUpdate:modelValue":S[4]||(S[4]=R=>T.value.height=R),type:"number",min:"20",max:"300",placeholder:"cm",required:""},null,512),[[Ue,T.value.height,void 0,{number:!0}]])])]),l("div",Fs,[S[16]||(S[16]=l("label",null,"설명 (선택)",-1)),fe(l("textarea",{"onUpdate:modelValue":S[5]||(S[5]=R=>T.value.description=R),rows:"3",placeholder:"락커 타입에 대한 설명",onKeydown:S[6]||(S[6]=R=>{console.log("[Modal Textarea] Keydown:",R.key,R.keyCode),R.key==="Backspace"&&console.log("[Modal Textarea] Backspace pressed - should work normally")})},null,544),[[Ue,T.value.description]])]),l("div",Ps,[S[18]||(S[18]=l("label",null,"색상 구분",-1)),fe(l("select",{"onUpdate:modelValue":S[7]||(S[7]=R=>T.value.color=R)},S[17]||(S[17]=[Ot('<option value="#4A90E2" data-v-fa6437c9>파란색</option><option value="#7ED321" data-v-fa6437c9>초록색</option><option value="#F5A623" data-v-fa6437c9>주황색</option><option value="#BD10E0" data-v-fa6437c9>보라색</option><option value="#9013FE" data-v-fa6437c9>남색</option>',5)]),512),[[Bn,T.value.color]])])]),l("div",Ys,[l("button",{class:"btn-cancel",onClick:S[8]||(S[8]=R=>G.$emit("close"))},"취소"),l("button",{class:"btn-save",onClick:w},"등록")])],32)]))}}),Ks=Rt(Vs,[["__scopeId","data-v-fa6437c9"]]),Xs={class:"locker-placement"},zs={key:0,class:"loading-overlay"},Bs={key:1,class:"main-content"},Hs={class:"container"},Us={class:"sidebar"},js={key:0,class:"loading-state"},Gs={key:1,class:"empty-state"},Ws={key:2,class:"locker-types"},Zs=["onClick","onDblclick","onContextmenu"],qs={class:"type-visual"},Js=["width","height","viewBox"],Qs=["width","height","fill"],ea=["y1","x2","y2","stroke"],ta={class:"type-info"},oa={class:"type-name"},na={class:"type-size"},sa=["onClick"],aa={key:3,class:"deleted-types-section"},ia=["onClick"],la={class:"canvas-area"},ra={class:"zone-tabs"},ca={class:"zone-tab-group"},da=["onClick","onContextmenu"],ua={key:0,class:"tab-indicator"},ha={class:"zone-controls"},fa={class:"mode-toggle-inline"},va={key:0,class:"zoom-controls"},ga={class:"canvas-wrapper"},pa=["viewBox"],ma=["width","height"],ya={key:1},wa=["x","y","font-size"],xa=["x","y","font-size"],ba={key:2,class:"unified-outlines"},La=["x","y","width","height"],Ca={key:3},ka=["transform"],Ea={key:4,class:"alignment-guides"},Ma=["y1","x2","y2"],$a=["x1","x2","y2"],Ta=["x","y","width","height"],Da={class:"form-group"},Sa={class:"modal-buttons"},Aa={class:"form-group"},_a={style:{display:"flex","justify-content":"space-between","align-items":"flex-start"}},Oa={class:"radio-group-horizontal",style:{flex:"1","margin-left":"20px"}},Na={class:"radio-label"},Ra={class:"radio-label"},Ia={class:"radio-label"},Fa={class:"form-section"},Pa={class:"form-options-row"},Ya={class:"radio-group-horizontal"},Va={class:"radio-label"},Ka={class:"radio-label"},Xa={class:"form-section"},za={style:{"margin-top":"10px"}},Ba={key:0,class:"progress-section"},Ha={class:"progress-indicator"},Ua={class:"progress-text"},ja={class:"modal-buttons"},Ga=["disabled"],Wa=["disabled"],Za={key:0},qa={key:1},Ja={class:"grouping-results"},Qa={class:"modal-buttons"},ei={class:"debug-section"},ti={class:"debug-stats"},oi={class:"stat-item"},ni={class:"value"},si={class:"stat-item"},ai={class:"value"},ii={class:"stat-item"},li={class:"value"},ri={class:"stat-item"},ci={class:"value"},di={class:"debug-section"},ui={class:"locker-list"},hi={class:"locker-header"},fi={class:"locker-name"},vi={class:"locker-type"},gi={class:"locker-details"},pi={class:"debug-section"},mi={class:"locker-list"},yi={class:"locker-header"},wi={class:"locker-name"},xi={class:"locker-type"},bi={class:"locker-details"},Li={class:"modal-buttons"},Ao=1,_o=1,Be=1100,bt=3100,_t=1440,Ne=1550,He=720,Oo=5,No=55,Ci=Nt({__name:"LockerPlacementFigma",setup(D){const u=es(),f=x(null),T=x(null),w=x(null),G=x(!1),S=x(null),R=x(!1),Y=x(!1),N=x(!1),W=x({x:0,y:0}),k=x("floor"),ae=x(!0),J=x(!1),Ie=x([]),je=x({isSelecting:!1,startX:0,startY:0,endX:0,endY:0}),ye=x(!1),Ge=x(""),Fe=x(!1),De=x({x:0,y:0}),Pe=x(!1),We=x({x:0,y:0}),Ze=x(null),Ye=x(!1),qe=x({x:0,y:0}),et=x(null),Se=x(!1),me=x(1),Ve=x(!1),we=x(!1),L=x(1),V=x("all"),H=x("horizontal"),ne=x(!1),Z=x(!1),p=x(!1),z=x(""),K=()=>k.value==="floor"?Ao:_o,P=x(bt),se=x(_t);x(1550),x(700);const te=x(1),ue=Math.max(Ne/bt,He/_t),ve=Math.min(bt/Ne,_t/He),ee=x({x:0,y:0}),ie=x(!1),le=x({x:0,y:0}),tt=()=>{if(Ke.value||dt.value)return;const t=document.querySelector(".canvas-wrapper");if(t){const e=t.getBoundingClientRect();e.width,e.height}},Je=(t,e)=>{const s=K();return{x:t*s,y:e*s}},It=(t,e)=>{const s=K();return{width:t*s,height:e*s}},Le=oe(()=>u.zones),xe=x([]);x(!1);const Ke=x(!0),dt=x(!0),oo=x(!1),Ft=x(null);x(null);const ge=(()=>{if(to()){const t=Te();return t?`${t.baseUrl}/api`:"/api"}return"http://localhost:3333/api"})(),Pt=async()=>{try{const t=await fetch(`${ge}/zones`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.zones){const s=e.zones.map(o=>({id:o.LOCKR_KND_CD,name:o.LOCKR_KND_NM,x:o.X,y:o.Y,width:o.WIDTH,height:o.HEIGHT,color:o.COLOR,floor:o.FLOOR,...o}));u.zones=s}else console.warn("[API] No zones data in response:",e),u.zones=[]}catch(t){console.error("[API] Failed to load zones:",t.message),u.zones=[]}},Ae=async()=>{try{const e=k.value==="floor"?`${ge}/lockrs?parentOnly=true`:`${ge}/lockrs`,s=await fetch(e);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const o=await s.json();if(o.lockers&&o.lockers.forEach(n=>{const i=n.PARENT_LOCKR_CD===null?"PARENT":`CHILD of ${n.PARENT_LOCKR_CD}`}),o.success&&o.lockers){const n=o.lockers.map(a=>{const i=xe.value.find(m=>m.id===a.LOCKR_TYPE_CD),d=(i==null?void 0:i.width)||40,r=(i==null?void 0:i.height)||60,h=(i==null?void 0:i.depth)||40,c=a.PARENT_LOCKR_CD?`locker-${a.PARENT_LOCKR_CD}`:null;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X!==null&&a.X!==void 0?a.X:void 0,y:a.Y!==null&&a.Y!==void 0?a.Y:void 0,width:d,height:h,depth:h,actualHeight:r,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockerId:c,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});u.lockers=n,u.lockers.forEach(a=>{const d=!a.parentLockrCd?"PARENT":`CHILD of ${a.parentLockrCd}`}),n.forEach(a=>{a.number==="L3"||a.number==="L4"||a.number==="L1"||a.number==="L2"||a.number})}else if(o.lockers){const n=o.lockers.map(a=>{const i=xe.value.find(r=>r.id===a.LOCKR_TYPE_CD),d=(i==null?void 0:i.height)||60;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X||0,y:a.Y||0,width:(i==null?void 0:i.width)||40,height:(i==null?void 0:i.depth)||40,depth:(i==null?void 0:i.depth)||40,actualHeight:d,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});u.lockers=n}else console.warn("[API] No lockers data in response:",o),u.lockers=[]}catch(t){console.error("[API] Failed to load lockers:",t.message),u.lockers=[]}},no=async()=>{try{Ke.value=!0;const t=await fetch(`${ge}/types`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.success){const s=(e.types||[]).map(o=>({id:o.LOCKR_TYPE_CD,name:o.LOCKR_TYPE_NM,width:o.WIDTH,height:o.HEIGHT,depth:o.DEPTH,color:o.COLOR||"#3b82f6",type:o.LOCKR_TYPE_CD}));xe.value=s}}catch(t){console.error("Failed to load locker types:",t),xe.value=[]}finally{Ke.value=!1,oo.value=!0}},Ro=async t=>{try{const e=await fetch(`${ge}/zones`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save zone");const s=await e.json();if(s.success)return await Pt(),s}catch(e){throw console.error("[API] Zone save failed:",e),Ft.value="Failed to save zone",e}},Yt=async t=>{try{const e=await fetch(`${ge}/lockrs`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save locker");const s=await e.json();if(s.success)return await Ae(),s}catch(e){throw console.error("[API] Locker save failed:",e),Ft.value="Failed to save locker",e}},so=async(t,e)=>{try{const s=await fetch(`${ge}/lockrs/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!s.ok){const n=await s.text();throw new Error(`Failed to update locker placement: ${s.status} - ${n}`)}const o=await s.json();if(o.success)return o}catch(s){throw console.error("[API] Locker placement update failed:",s),Ft.value="Failed to update locker placement",s}},Io=async t=>{try{const e=await fetch(`${ge}/lockrs/batch-numbers`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({updates:t})});if(!e.ok){const o=await e.text();throw new Error(`Failed to batch update locker numbers: ${e.status} - ${o}`)}const s=await e.json();if(s.success)return s;throw new Error(`Batch update failed: ${s.message||"Unknown error"}`)}catch(e){throw console.error("[API] Batch locker number update failed:",e),e}},Fo=async t=>{try{const e=t.map(s=>{var i;const o=b.value.find(d=>d.id===s.id),n=Math.round(s.x*100)/100,a=Math.round(s.y*100)/100;if(o&&o.lockrCd)return so(o.lockrCd,{X:n,Y:a});if(o){const d={LOCKR_KND:(i=f.value)==null?void 0:i.id,LOCKR_TYPE_CD:o.type||"1",X:n,Y:a,LOCKR_LABEL:o.number,ROTATION:o.rotation||0,LOCKR_STAT:"00"};return Yt(d).then(r=>(r&&r.lockrCd&&(o.lockrCd=r.lockrCd),r))}});await Promise.all(e)}catch(e){console.error("[API] Failed to save some locker positions:",e)}},ut=x([]),Lt=t=>{if(t.length<=1)return null;const e=2,s=t.map(d=>{const r=k.value==="front"?d.actualHeight||d.height||60:d.depth||d.height||40,h=k.value==="front"&&d.frontViewX!==void 0?d.frontViewX:d.x,c=k.value==="front"&&d.frontViewY!==void 0?d.frontViewY:d.y;return{left:h,right:h+d.width*e,top:c,bottom:c+r*e,locker:d}}),o=Math.min(...s.map(d=>d.left)),n=Math.max(...s.map(d=>d.right)),a=Math.min(...s.map(d=>d.top)),i=Math.max(...s.map(d=>d.bottom));return{minX:o,maxX:n,minY:a,maxY:i,width:n-o,height:i-a}},Po=(t,e,s=5)=>{const n=k.value==="front"?t.actualHeight||t.height||60:t.depth||t.height||40,a=k.value==="front"?e.actualHeight||e.height||60:e.depth||e.height||40,i=_=>k.value==="front"?{x:_.frontViewX!==void 0?_.frontViewX:_.x,y:_.frontViewY!==void 0?_.frontViewY:_.y}:{x:_.x,y:_.y},d=i(t),r=i(e),h={left:d.x,right:d.x+t.width*2,top:d.y,bottom:d.y+n*2},c={left:r.x,right:r.x+e.width*2,top:r.y,bottom:r.y+a*2},v=s,m=Math.min(Math.abs(h.right-c.left),Math.abs(c.right-h.left)),g=Math.min(Math.abs(h.bottom-c.top),Math.abs(c.bottom-h.top))<=v,C=h.left<c.right&&c.left<h.right,I=m<=v,y=h.top<c.bottom&&c.top<h.bottom;return g&&C||I&&y},Yo=t=>{const e=[],s=new Set,o=(n,a)=>{s.has(n.id)||(s.add(n.id),a.push(n),t.forEach(i=>{!s.has(i.id)&&Po(n,i)&&o(i,a)}))};return t.forEach(n=>{if(!s.has(n.id)){const a=[];o(n,a),e.push(a)}}),e},Vo=t=>{if(!M.value.has(t))return[];const e=b.value.find(h=>h.id===t);if(!e)return[];const s=[],o=10,n=Ee(e),a=(e.rotation||0)%360,i={0:{top:"top",right:"right",bottom:"bottom",left:"left"},90:{top:"left",right:"top",bottom:"right",left:"bottom"},180:{top:"bottom",right:"left",bottom:"top",left:"right"},270:{top:"right",right:"bottom",bottom:"left",left:"top"}},d=Math.round(a/90)*90%360,r=i[d]||i[0];return ao.value.forEach(h=>{if(h.id===t)return;const c=Ee(h);N.value&&console.log(`[Adjacent Check] ${t} vs ${h.id}:`,{locker:{id:t,rotation:a,bounds:n},other:{id:h.id,rotation:h.rotation,bounds:c},mapping:r}),Math.abs(n.y-(c.y+c.height))<o&&n.x<c.x+c.width&&n.x+n.width>c.x&&(s.push(r.top),N.value&&console.log("  -> TOP adjacent (physical top touches other's bottom)")),Math.abs(n.y+n.height-c.y)<o&&n.x<c.x+c.width&&n.x+n.width>c.x&&s.push(r.bottom),Math.abs(n.x-(c.x+c.width))<o&&n.y<c.y+c.height&&n.y+n.height>c.y&&s.push(r.left),Math.abs(n.x+n.width-c.x)<o&&n.y<c.y+c.height&&n.y+n.height>c.y&&s.push(r.right)}),[...new Set(s)]},Vt=oe(()=>xe.value.filter(t=>!ut.value.includes(t.id))),b=oe(()=>{if(!f.value)return[];let t=u.lockers.filter(e=>e.zoneId===f.value.id);return k.value==="floor"&&(t=t.filter(e=>!e.parentLockrCd)),t.forEach(e=>{!e.parentLockrCd||`${e.parentLockrCd}`}),t}),Ko=oe(()=>b.value.map((e,s)=>{let o,n,a;const i=e.actualHeight||e.height||60;if(k.value==="floor"){const r=Je(e.x,e.y);o=r.x,n=r.y,a=It(e.width,e.height||e.depth||40).height}else{const r=K();if(e.frontViewX!==void 0&&e.frontViewX!==null&&e.frontViewY!==void 0&&e.frontViewY!==null)o=e.frontViewX*r,n=e.frontViewY*r,a=i*r;else if(e.x!==void 0&&e.x!==null&&e.y!==void 0&&e.y!==null){const h=400+s*80,c=200;o=h,n=c,a=i*r}else o=100+s*100,n=100,a=i*r}const d=e.width*K();return{...e,displayX:o,displayY:n,displayWidth:d,displayHeight:a,actualHeight:e.actualHeight||i||60,logicalX:e.x,logicalY:e.y,logicalWidth:e.width,logicalHeight:e.height||e.depth||40}})),Xo=oe(()=>{const t=Ko.value.map(e=>{if(k.value==="front"){const s=e.actualHeight||e.height||60,o=e.displayX/K(),n=e.displayY/K(),a=e.frontViewRotation!==void 0?e.frontViewRotation:0;return e.x===o&&e.y===n&&e.height===s&&e.rotation===a?e:{...e,x:o,y:n,height:s,actualHeight:s,rotation:a}}return e});if(k.value==="front")return t;if(w.value){const e=t.findIndex(s=>s.id===w.value.id);if(e>-1){const[s]=t.splice(e,1);t.push(s)}}return t}),ao=oe(()=>b.value.filter(t=>M.value.has(t.id))),Ct=oe(()=>Yo(ao.value)),zo=oe(()=>{const t=new Set;return Ct.value.forEach(e=>{e.length>1&&e.forEach(s=>t.add(s.id))}),t});x(!1),x([]);const io=()=>{if(!w.value)return{x:0,y:0};const t=b.value.find(e=>e.id===w.value.id);return t?k.value==="front"?{x:t.frontViewX!==void 0?t.frontViewX:t.x,y:t.frontViewY!==void 0?t.frontViewY:t.y}:{x:t.x,y:t.y}:{x:w.value.x,y:w.value.y}},Ce=t=>{if(!t)return{width:0,height:0};const e=2;return k.value==="floor"?{width:(t.width||40)*e,height:(t.depth||t.height||40)*e}:{width:(t.width||40)*e,height:(t.actualHeight||t.height||60)*e}},ht=x(!1),kt=x(!1),Qe=x([]),M=x(new Set),Kt=x(null),Xe=x(!1),re=x({x:0,y:0}),de=x({x:0,y:0}),ke=x([]),Xt=x(!1),ot=x(!1);x([]);const ft=x(!1),lo=x([]),ro=x([]),vt=async t=>{f.value=t,w.value=null,k.value==="front"&&(console.log("[Zone Change] Loading lockers for zone in front view mode..."),await Ae(),ze(()=>{b.value.some(s=>s.frontViewX==null||s.frontViewY==null)?(console.log("[Zone Change] Found lockers without front view coordinates, recalculating..."),it()):console.log("[Zone Change] All lockers have front view coordinates")})),setTimeout(()=>{nt()},100)},Bo=(t,e)=>{t.preventDefault(),t.stopPropagation(),Ze.value=e,We.value={x:t.clientX,y:t.clientY},Pe.value=!0;const s=()=>{Pe.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},Ho=async t=>{var e;try{const s=b.value.filter(d=>d.LOCKR_KND===t.id||d.zoneId===t.id||d.LOCKR_KND===t.LOCKR_KND_CD);if(s.length>0){alert(`구역 삭제 불가

이 구역에 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`구역 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=t.LOCKR_KND_CD||t.id,n=`${ge}/zones/${o}`,a=await fetch(n,{method:"DELETE"});if(!a.ok){const d=await a.json();throw new Error(d.message||"Failed to delete zone")}(await a.json()).success&&(await Pt(),((e=f.value)==null?void 0:e.id)===t.id&&(Le.value.length>0?vt(Le.value[0]):f.value=null),alert("구역이 성공적으로 삭제되었습니다."))}catch(s){console.error("[API] Zone deletion failed:",s),alert(`구역 삭제 중 오류가 발생했습니다:
${s.message}`)}finally{Pe.value=!1}},Uo=(t,e)=>{t.preventDefault(),et.value=e,qe.value={x:t.clientX,y:t.clientY},Ye.value=!0;const s=()=>{Ye.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},co=async t=>{var e;try{const s=b.value.filter(a=>a.LOCKR_TYPE_CD===t.id||a.type===t.id);if(s.length>0){alert(`타입 삭제 불가

이 타입으로 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`락커 타입 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=await fetch(`${ge}/types/${t.id}`,{method:"DELETE"});if(!o.ok){const a=await o.json();throw new Error(a.message||"Failed to delete locker type")}(await o.json()).success&&(await no(),((e=T.value)==null?void 0:e.id)===t.id&&(T.value=null),Ye.value=!1)}catch(s){console.error("Failed to delete locker type:",s),alert("락커 타입 삭제에 실패했습니다.")}},jo=t=>{T.value=t},Go=(t,e,s,o)=>{let n=t,a=e;n=Math.round(n/20)*20,a=Math.round(a/20)*20;let i=0;const d=50;for(;i<d;){if(!Gt(n,a,s,o,null,0,!1))return{x:n,y:a};n+=20,n>P.value-s-100&&(n=t,a+=20,a>se.value-o-100&&(a=100,t+=20,n=t)),i++}return console.warn("[Direct Add] Could not find collision-free position, using default"),{x:t,y:e}},Wo=async t=>{if(k.value!=="floor"){alert("평면배치모드에서만 락커를 추가할 수 있습니다.");return}if(!f.value){alert("구역을 선택해주세요.");return}T.value=t;const e=100,s=Math.round(se.value/3),o=Go(e,s,t.width,t.depth||t.width),n=Co(o.x,o.y,t.width,t.depth||t.width),a={id:`locker-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,name:t.name,x:n.x,y:n.y,width:t.width,height:t.depth||t.width,depth:t.depth||t.width,actualHeight:t.height,color:t.color,rotation:0,type:t.name,status:"available",number:jt(),zoneId:f.value.id};let i=null;try{const r={LOCKR_KND:f.value.id,LOCKR_TYPE_CD:t.id||t.type,X:a.x,Y:a.y,LOCKR_LABEL:a.number,ROTATION:a.rotation||0,LOCKR_STAT:"00"},h=await Yt(r);h&&h.lockrCd&&(await Ae(),nt(),i=b.value.find(c=>c.x===a.x&&c.y===a.y&&c.number===a.number))}catch(r){console.error("[Database] Failed to save locker:",r),i=u.addLocker(a)}i&&(w.value=i,M.value.clear(),M.value.add(i.id),ae.value=!0),Fn();const d=window.event;if(d&&d.currentTarget){const r=d.currentTarget;r.classList.add("pulse-animation"),setTimeout(()=>r.classList.remove("pulse-animation"),300)}},Zo=t=>{const e=ut.value.indexOf(t);e>-1&&ut.value.splice(e,1)},qo=t=>{const e=xe.value.find(s=>s.type===t);return e?e.name:t},gt=t=>{const e=S.value;if(!e)return{x:0,y:0};const s=e.createSVGPoint();s.x=t.clientX,s.y=t.clientY;const o=s.matrixTransform(e.getScreenCTM().inverse());return K(),{x:Math.round(o.x*100)/100,y:Math.round(o.y*100)/100}},Jo=t=>{if(k.value!=="floor"&&k.value!=="front"||!t.ctrlKey)return;t.preventDefault();const s=t.currentTarget.getBoundingClientRect(),o=(t.clientX-s.left)/s.width,n=(t.clientY-s.top)/s.height,a=Ne/te.value,i=He/te.value,d=ee.value.x+o*a,r=ee.value.y+n*i,h=t.deltaY>0?.9:1.1,c=Math.min(Math.max(te.value*h,ue),ve);if(c!==te.value){const v=Ne/c,m=He/c,$={x:d-o*v,y:r-n*m};ee.value=zt($,c),te.value=c}},zt=(t,e)=>{const s=Ne/e,o=He/e,n=0,a=0,i=Math.max(0,bt-s),d=Math.max(0,_t-o);return{x:Math.max(n,Math.min(i,t.x)),y:Math.max(a,Math.min(d,t.y))}},nt=()=>{if(b.value.length===0){te.value=1,ee.value={x:0,y:0};return}let t=1/0,e=1/0,s=-1/0,o=-1/0;const n=2;if(b.value.forEach(E=>{if(E.parentLockerId)return;let _,B,F,U;if(k.value==="floor")_=E.x,B=E.y,F=E.x+(E.width||40)*n,U=E.y+(E.depth||E.height||40)*n;else if(k.value==="front")_=E.frontViewX!==void 0?E.frontViewX:E.x,B=E.frontViewY!==void 0?E.frontViewY:E.y,F=_+(E.width||40)*n,U=B+(E.actualHeight||E.height||60)*n;else return;t=Math.min(t,_),e=Math.min(e,B),s=Math.max(s,F),o=Math.max(o,U)}),t===1/0||e===1/0){te.value=1,ee.value={x:0,y:0};return}const a=s-t,i=o-e,d=.3,r=a*(1+d),h=i*(1+d),c=Ne/r,v=He/h;let m=Math.min(c,v);m=m*.729,m=Math.max(ue,Math.min(m,ve));const $=(t+s)/2,g=(e+o)/2,C=Ne/(2*m),I=He/(2*m);te.value=m;const y={x:$-C,y:g-I};ee.value=zt(y,m),console.log("[AutoFit]",k.value,"mode - Zoom:",m,"Pan:",ee.value,"Bounds:",{minX:t,minY:e,maxX:s,maxY:o})},Qo=t=>{if((k.value==="floor"||k.value==="front")&&t.button===1){t.preventDefault(),ie.value=!0,le.value={x:t.clientX,y:t.clientY};return}const e=gt(t),s=e.x,o=e.y,n=t.target;!(n.closest("[data-locker-id]")||n.tagName==="rect"&&!n.classList.contains("canvas-background")||n.tagName==="text"||n.tagName==="g"&&n.querySelector("text"))&&(n.tagName==="svg"||n.classList.contains("canvas-background")||n.getAttribute("fill")==="url(#grid)"||n.classList.contains("selection-box"))&&!N.value&&(Xe.value=!0,re.value={x:s,y:o},de.value={x:s,y:o},M.value.clear(),w.value=null,t.preventDefault(),t.stopPropagation())},en=t=>{if((k.value==="floor"||k.value==="front")&&ie.value){const n=(t.clientX-le.value.x)/te.value,a=(t.clientY-le.value.y)/te.value,i={x:ee.value.x-n,y:ee.value.y-a};ee.value=zt(i,te.value),le.value={x:t.clientX,y:t.clientY};return}const e=gt(t),s=e.x,o=e.y;Xe.value?(de.value={x:s,y:o},Math.sqrt(Math.pow(s-re.value.x,2)+Math.pow(o-re.value.y,2))>Oo&&ho()):N.value&&un(t)},uo=t=>{if((k.value==="floor"||k.value==="front")&&ie.value){ie.value=!1;return}if(!(ht.value||kt.value)){if(Xe.value){const e=gt(t),s=e.x,o=e.y;Math.sqrt(Math.pow(s-re.value.x,2)+Math.pow(o-re.value.y,2))>Oo?(ho(),Xt.value=!0,M.value.size>0&&(ae.value=!0),setTimeout(()=>{Xt.value=!1},100)):ht.value||(M.value.clear(),w.value=null),Xe.value=!1,re.value={x:0,y:0},de.value={x:0,y:0}}N.value&&hn()}},ho=()=>{if(!re.value||!de.value||re.value.x==null||re.value.y==null||de.value.x==null||de.value.y==null){console.warn("[Rectangle Select] Invalid coordinates, skipping selection update");return}const t=Math.min(re.value.x,de.value.x),e=Math.max(re.value.x,de.value.x),s=Math.min(re.value.y,de.value.y),o=Math.max(re.value.y,de.value.y);if(M.value.clear(),b.value.forEach(n=>{let a,i,d,r;if(k.value==="front"){const c=n.frontViewX!==void 0?n.frontViewX:n.x,v=n.frontViewY!==void 0?n.frontViewY:n.y,m=Ce(n);a=c,i=c+m.width,d=v,r=v+m.height}else{const c=Ce(n);a=n.x,i=n.x+c.width,d=n.y,r=n.y+c.height}!(i<t||a>e||r<s||d>o)&&M.value.add(n.id)}),M.value.size>0){const n=Array.from(M.value)[0];w.value=b.value.find(a=>a.id===n),ae.value=!0}else w.value=null},tn=()=>{if(N.value||je.value.isSelecting||ot.value){console.log("[Modal] Floor modal close prevented - operation in progress");return}Se.value=!1},on=()=>{if(N.value||je.value.isSelecting||ot.value){console.log("[Modal] Number modal close prevented - operation in progress");return}we.value=!1},nn=t=>{if(Xt.value||ot.value||kt.value)return;const e=t.target,s=e.tagName==="svg"||e.classList.contains("canvas-background")||e.tagName==="rect"&&e.getAttribute("fill")==="url(#grid)"||e.classList.contains("canvas");if(s&&!t.ctrlKey&&!t.shiftKey&&!t.metaKey){w.value=null,M.value.clear(),u.selectLocker(null),ae.value=!1;return}if(s&&(t.shiftKey||t.ctrlKey)){const o=S.value.getBoundingClientRect();je.value={isSelecting:!0,startX:t.clientX-o.left,startY:t.clientY-o.top,endX:t.clientX-o.left,endY:t.clientY-o.top},console.log("[Selection] Drag selection started");return}},sn=(t,e)=>{var s;if(console.log("[Selection] Attempting to select in mode:",k.value,"Locker:",t.id),ot.value){console.log("[Select] Ignored - drag just finished");return}if(Xe.value){console.log("[Select] Ignored - drag selection in progress");return}if(!N.value){if(e&&(e.ctrlKey||e.metaKey)){if(M.value.has(t.id)){if(M.value.delete(t.id),((s=w.value)==null?void 0:s.id)===t.id){const o=Array.from(M.value);w.value=o.length>0?b.value.find(n=>n.id===o[0]):null}}else M.value.add(t.id),w.value=t;ae.value=!0,console.log(`[Selection] Toggle select ${t.id}, total: ${M.value.size}`)}else e&&e.shiftKey&&Kt.value?(an(Kt.value,t),ae.value=!0):(M.value.clear(),M.value.add(t.id),w.value=t,console.log("[Selection UI] Rotation applied:",{lockerRotation:t.rotation||0,buttonPositions:{left:{x:t.width/2-15,y:-30},right:{x:t.width/2+15,y:-30},delete:{x:t.width+15,y:-15}},rotationCenter:{x:t.width/2,y:t.height/2}}));Kt.value=t,u.selectLocker(t.id),ae.value=!0,console.log("[Select] Selection updated - Count:",M.value.size,"IDs:",Array.from(M.value),"ShowUI:",ae.value)}},an=(t,e)=>{const s=b.value.findIndex(i=>i.id===t.id),o=b.value.findIndex(i=>i.id===e.id);if(s===-1||o===-1)return;const n=Math.min(s,o),a=Math.max(s,o);M.value.clear();for(let i=n;i<=a;i++)M.value.add(b.value[i].id);w.value=e,console.log(`[Selection] Range select from ${t.id} to ${e.id}, total: ${M.value.size}`)},ln=(t,e)=>{if(k.value==="front")return;if(!t||Xe.value){console.log("[Drag] Ignored - drag selection in progress");return}N.value=!0,ae.value=!1;const s=e.ctrlKey||e.metaKey;console.log("[Multi-Select] Copying with drag:",s),console.log("[Drag] Started - hiding selection UI");let o=t;if(s){const r=new Map;if(Array.from(M.value).forEach(h=>{const c=b.value.find(v=>v.id===h);if(c){const v={...c,id:`locker-${Date.now()}-${Math.random()}`,number:"",x:c.x+20,y:c.y+20},m=u.addLocker(v);u.updateLocker(m.id,{lockrNo:jt()}),r.set(c.id,m.id)}}),r.size>0){if(r.has(t.id)){const h=r.get(t.id);o=b.value.find(c=>c.id===h)}M.value.clear(),r.forEach(h=>{M.value.add(h)}),w.value=o,console.log("[Multi-Select] Created copies:",r.size,"New leader:",o.id)}}!s&&!M.value.has(t.id)&&(M.value.clear(),M.value.add(t.id),w.value=t),N.value=!0;const n=gt(e);ke.value=Array.from(M.value).map(r=>{const h=b.value.find(I=>I.id===r),c=Math.round(h.x*100)/100,v=Math.round(h.y*100)/100,m=Math.round(o.x*100)/100,$=Math.round(o.y*100)/100,g=c-m,C=v-$;return{id:h.id,initialX:c,initialY:v,relativeX:g,relativeY:C,isLeader:h.id===o.id}});const a=Math.round(o.x*100)/100,i=Math.round(o.y*100)/100;W.value={x:n.x-a,y:n.y-i};const d=M.value.size;d>1?console.log("[Group Drag] Started with",d,"lockers, leader:",o.id):console.log("[Drag] Start dragging locker:",t.id),e.preventDefault()},st=x(null),rn=(t,e)=>{if(t){if(M.value.has(t.id)||(w.value=t,M.value.add(t.id)),ht.value=!0,M.value.size>1){const s=Array.from(M.value),o=b.value.filter(r=>s.includes(r.id)),n={minX:Math.min(...o.map(r=>r.x)),maxX:Math.max(...o.map(r=>r.x+r.width)),minY:Math.min(...o.map(r=>r.y)),maxY:Math.max(...o.map(r=>r.y+(r.height||r.depth||40)))},a=(n.minX+n.maxX)/2,i=(n.minY+n.maxY)/2,d=new Map;o.forEach(r=>{const h=Ce(r),c=r.x+h.width/2,v=r.y+h.height/2;d.set(r.id,{relativeX:c-a,relativeY:v-i,width:h.width,height:h.height,initialRotation:r.rotation||0})}),st.value={centerX:a,centerY:i,lockerStates:d,leaderId:t.id}}else st.value=null;N.value=!1}},cn=(t,e)=>{if(M.value.size>1&&st.value){const s=st.value,o=b.value.find(c=>c.id===t);if(!o||!s)return;o._lastRotation===void 0&&(o._lastRotation=o.rotation||0,console.log("=== ROTATION INIT ==="),console.log("  Initial rotation set to:",o._lastRotation));let n=e-o._lastRotation;for(console.log("=== ROTATION DEBUG ==="),console.log("  newRotation:",e),console.log("  lastRotation:",o._lastRotation),console.log("  raw delta:",n);n>180;)n-=360,console.log("  → Adjusted delta (>180):",n);for(;n<-180;)n+=360,console.log("  → Adjusted delta (<-180):",n);const a=o._rotationDirection||0,i=Math.sign(n);a!==0&&i!==0&&a!==i&&console.log("  Direction change detected! prev:",a,"current:",i),o._rotationDirection=i,o._lastRotation=e,console.log("  Final delta:",n);const d=s.centerX,r=s.centerY;Array.from(M.value).forEach(c=>{const v=b.value.find(_=>_.id===c);if(!v)return;const m=s.lockerStates.get(c);if(!m)return;const $=e-(s.lockerStates.get(s.leaderId).initialRotation||0),g=$*Math.PI/180,C=Math.cos(g),I=Math.sin(g),y=m.relativeX*C-m.relativeY*I+d,E=m.relativeX*I+m.relativeY*C+r;v.x=y-m.width/2,v.y=E-m.height/2,v.id===s.leaderId?(v.rotation=e,console.log(`[ROTATION DIRECTION] Leader locker ${v.id} rotation: ${v.rotation}`)):(v.rotation=m.initialRotation+$,console.log(`[ROTATION DIRECTION] Follower locker ${v.id} rotation: ${v.rotation}`)),fo(v.id,v.rotation)})}else{const s=b.value.find(o=>o.id===t);s&&(s.rotation=e,console.log(`[ROTATION DIRECTION] Single locker ${s.id} rotation: ${s.rotation}`),fo(t,s.rotation))}},dn=t=>{if(M.value.size>1)Array.from(M.value).forEach(n=>{const a=b.value.find(i=>i.id===n);if(a){const i=Math.round(a.rotation/45)*45;a.rotation=i,console.log(`[ROTATION END] Snapped locker ${n} from ${a.rotation} to ${i}`)}});else{const o=b.value.find(n=>n.id===t);if(o){const n=o.rotation,a=Math.round(n/45)*45;o.rotation=a,console.log(`[ROTATION END] Snapped locker ${t} from ${n} to ${a}`)}}kt.value=!0,ht.value=!1,setTimeout(()=>{kt.value=!1},200);const s=b.value.find(o=>o.id===t);if(s&&(delete s._lastRotation,delete s._lastRawRotation,delete s._rotationDirection),st.value&&(st.value=null),M.value.size>1){const o=Array.from(M.value);b.value.filter(a=>o.includes(a.id)).forEach(a=>{Bt(a.id,a.rotation)})}else{const o=b.value.find(n=>n.id===t);o&&Bt(t,o.rotation)}},fo=(()=>{let t=null;return(e,s)=>{clearTimeout(t),t=setTimeout(()=>{Bt(e,s)},200)}})(),Bt=async(t,e)=>{try{if(u.getLockerById(t)){let o=e%360;o>180?o-=360:o<-180&&(o+=360);const n=ht.value;await u.updateLocker(t,{rotation:o},n)}}catch(s){console.error("[Rotation] Failed to save rotation:",s)}},un=t=>{if(!N.value||ke.value.length===0)return;const e=gt(t),s=ke.value.find(C=>C.isLeader);if(!s)return;const o=b.value.find(C=>C.id===s.id);if(!o)return;const n=e.x-W.value.x,a=e.y-W.value.y,i=Ce(o),d=Mt(n),r=Mt(a),h=Co(d,r,i.width,i.height,s.id,o.rotation||0),c=h.x!==d||h.y!==r;c&&console.log("[SNAP DEBUG] Position was snapped from",{x:d,y:r},"to",h);const v=h.x-s.initialX,m=h.y-s.initialY,$=[];let g=!1;if(ke.value.forEach(C=>{const I=b.value.find(y=>y.id===C.id);if(I){const y=Ce(I);let E,_;C.isLeader?(E=h.x,_=h.y):(E=h.x+C.relativeX,_=h.y+C.relativeY);const B=P.value-y.width,F=se.value-y.height;E=Math.max(0,Math.min(E,B)),_=Math.max(0,Math.min(_,F)),Gt(E,_,y.width,y.height,I.id,I.rotation||0,c)&&(g=!0),$.push({id:I.id,x:E,y:_,dims:y})}}),!g)$.forEach(C=>{var E;const I=Math.round(C.x*100)/100,y=Math.round(C.y*100)/100;u.updateLocker(C.id,{x:I,y},!0),((E=w.value)==null?void 0:E.id)===C.id&&(w.value={...w.value,x:I,y})}),console.log("[Group Drag] Moving",M.value.size,"lockers. Leader:",s.id,"Delta:",{x:v.toFixed(1),y:m.toFixed(1)});else if(c&&g){console.log("[SNAP WARNING] Collision detected at snapped position, checking overlap amount...");let C=0;ke.value.forEach(I=>{const y=b.value.find(E=>E.id===I.id);if(y){const E=Ce(y);let _,B;I.isLeader?(_=h.x,B=h.y):(_=h.x+I.relativeX,B=h.y+I.relativeY);const F=Ee({x:_,y:B,width:E.width,height:E.height,rotation:y.rotation||0});b.value.forEach(U=>{if(U.id!==y.id&&!M.value.has(U.id)){const X=Ee(U),q=Math.min(F.x+F.width,X.x+X.width)-Math.max(F.x,X.x),pe=Math.min(F.y+F.height,X.y+X.height)-Math.max(F.y,X.y);q>0&&pe>0&&(C=Math.max(C,Math.min(q,pe)),console.log("[SNAP OVERLAP] With",U.id,"- X:",q.toFixed(1),"Y:",pe.toFixed(1)))}})}}),C<1?(console.log("[SNAP] Accepting snapped position with micro-overlap:",C.toFixed(2),"px"),$.forEach(I=>{var y;u.updateLocker(I.id,{x:I.x,y:I.y},!0),((y=w.value)==null?void 0:y.id)===I.id&&(w.value={...w.value,x:I.x,y:I.y})})):console.warn("[SNAP] Rejecting snapped position due to significant overlap:",C.toFixed(1),"px")}else{console.log("[COLLISION ADJUSTMENT DEBUG] Collision detected (non-snapped), finding valid position:",{snappedLeader:h,proposedPositions:$.length,hasCollision:g,wasSnapped:c});let C=h.x,I=h.y,y=!1;const E=[{dx:-20,dy:0},{dx:20,dy:0},{dx:0,dy:-20},{dx:0,dy:20},{dx:-20,dy:-20},{dx:20,dy:-20},{dx:-20,dy:20},{dx:20,dy:20}];for(const _ of E){const B=h.x+_.dx,F=h.y+_.dy;let U=!1;if(ke.value.forEach(X=>{const q=b.value.find(pe=>pe.id===X.id);if(q&&!U){const pe=Ce(q);let _e,Me;X.isLeader?(_e=B,Me=F):(_e=B+X.relativeX,Me=F+X.relativeY);const mt=P.value-pe.width,yt=se.value-pe.height;_e=Math.max(0,Math.min(_e,mt)),Me=Math.max(0,Math.min(Me,yt)),Gt(_e,Me,pe.width,pe.height,q.id,q.rotation||0,!1)&&(U=!0)}}),!U){C=B,I=F,y=!0;break}}y?(ke.value.forEach(_=>{var F;const B=b.value.find(U=>U.id===_.id);if(B){let U,X;_.isLeader?(U=C,X=I):(U=C+_.relativeX,X=I+_.relativeY);const q=Ce(B),pe=P.value-q.width,_e=se.value-q.height;U=Math.max(0,Math.min(U,pe)),X=Math.max(0,Math.min(X,_e)),u.updateLocker(B.id,{x:U,y:X},!0),((F=w.value)==null?void 0:F.id)===B.id&&(w.value={...w.value,x:U,y:X})}}),console.log("[COLLISION] Adjusted to valid position:",`(${C}, ${I})`)):console.warn("[COLLISION] No collision-free adjustment found, keeping original positions")}},hn=()=>{if(N.value){if(ot.value=!0,console.log("[Drag] Setting lockerDragJustFinished flag to true"),setTimeout(()=>{ot.value=!1,console.log("[Drag] Cleared lockerDragJustFinished flag")},150),ke.value.length>0){const t=ke.value.map(e=>{const s=b.value.find(o=>o.id===e.id);return{id:e.id,x:(s==null?void 0:s.x)||e.x,y:(s==null?void 0:s.y)||e.y}});Fo(t)}N.value=!1,ae.value=!0,W.value={x:0,y:0},ke.value=[],ft.value=!1,lo.value=[],ro.value=[],console.log("[Drag] End dragging - Current selection count:",M.value.size)}},fn=()=>{const t=[],e=new Set,s=b.value.filter(o=>!o.parentLockerId);for(let o=0;o<s.length;o++){const n=s[o],a=n.rotation||0;let i=null;if(a===0||a===360?i={minX:n.x,maxX:n.x+n.width,minY:n.y+(n.depth||n.height),maxY:n.y+(n.depth||n.height)+50}:a===90?i={minX:n.x+n.width,maxX:n.x+n.width+50,minY:n.y,maxY:n.y+(n.depth||n.height)}:a===180?i={minX:n.x,maxX:n.x+n.width,minY:n.y-50,maxY:n.y}:a===270&&(i={minX:n.x-50,maxX:n.x,minY:n.y,maxY:n.y+(n.depth||n.height)}),i)for(let d=0;d<s.length;d++){if(o===d)continue;const r=s[d];if(n.zoneId!==r.zoneId)continue;const h=r.depth||r.height,c=!(r.x+r.width<=i.minX||r.x>=i.maxX),v=!(r.y+h<=i.minY||r.y>=i.maxY);c&&v&&(e.add(n.id),e.add(r.id),t.push(`락커 ${n.number}의 문 앞이 락커 ${r.number}에 의해 막혀있습니다.`))}}t.length>0?console.log("[Door Blockage Check]:",{blocked:!0,errors:t,problematicLockers:Array.from(e)}):console.log("[Door Blockage Check]: All locker doors are accessible"),t.length>0&&(t.length=0,t.push("세로배치 모드 불가: 락커의 문 앞이 다른 락커에 의해 막혀있습니다."));for(let o=0;o<b.value.length;o++){const n=b.value[o];for(let a=o+1;a<b.value.length;a++){const i=b.value[a],d=Math.abs(n.x+n.width-i.x)<5||Math.abs(i.x+i.width-n.x)<5,r=Math.abs(n.y+(n.depth||n.height)-i.y)<5||Math.abs(i.y+(i.depth||i.height)-n.y)<5;if(d||r){if(d){const h=n.rotation%180===0,c=i.rotation%180===180;(n.x<i.x&&h&&c||i.x<n.x&&c&&h)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}if(r){const h=n.rotation%180===90,c=n.rotation%180===270,v=i.rotation%180===90,m=i.rotation%180===270;(n.y<i.y&&h&&m||i.y<n.y&&v&&c)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}}}}return console.log("[Placement Validation]:",{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}),{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}},vn=t=>{b.value.forEach(e=>{e.hasError=!1}),t.forEach(e=>{const s=b.value.find(o=>o.id===e);s&&(s.hasError=!0)})},Ht=x(!1),vo=t=>{console.log("[setViewMode] Switching to:",t),t==="floor"&&k.value==="front"&&(Ht.value=!0,setTimeout(()=>{Ht.value=!1},400)),k.value=t,t==="front"&&setTimeout(()=>{nt()},50),t==="floor"&&setTimeout(()=>{nt()},50),go(),console.log("[ViewMode] Switching to:",t,{previousScale:t==="floor"?_o:Ao,newScale:K(),viewMode:k.value}),ze(()=>{tt()})},go=()=>{if(k.value==="front"){const e=fn();if(e.isValid)console.log("[Validation PASSED] Front view validation successful");else{console.error("[Validation FAILED] Cannot switch to front view:",e.errors),console.error("[Validation FAILED] Problematic lockers:",e.problematicLockers),alert(`세로모드 진입 불가: 락커 배치가 규칙에 맞지 않습니다.
문제: `+e.errors.join(`
`)),vn(e.problematicLockers),k.value="floor";return}b.value.forEach(s=>s.hasError=!1)}console.log("[View Mode] Configuration:",{mode:k.value,floorY:Be,dimensions:k.value==="floor"?"width×depth":"width×height",interactions:k.value==="floor"?"enabled":"disabled"}),G.value=k.value==="front",k.value==="front"?(w.value=null,M.value.clear(),N.value=!1,ae.value=!1):(ae.value=!0,console.log("[Floor View] Interactions enabled, full editing mode"));const t=k.value==="floor"?"flat":"vertical";u.setPlacementMode(t)},po=()=>{const t=b.value;if(t.length===0)return;const e={minX:Math.min(...t.map(c=>c.x)),maxX:Math.max(...t.map(c=>c.x+c.width)),minY:Math.min(...t.map(c=>c.y)),maxY:Math.max(...t.map(c=>c.y+(c.depth||c.height)))},s=[],o=[],n=[],a=[],i=[];t.forEach(c=>{const v=Math.abs(c.y-e.minY)<30,m=Math.abs(c.y+(c.depth||c.height)-e.maxY)<30,$=Math.abs(c.x-e.minX)<30,g=Math.abs(c.x+c.width-e.maxX)<30;v&&!$&&!g?s.push(c):m&&!$&&!g?n.push(c):g&&!v&&!m?o.push(c):$&&!v&&!m?a.push(c):v&&g||m&&g?o.push(c):v&&$?s.push(c):m&&$?n.push(c):i.push(c)}),s.sort((c,v)=>c.x-v.x),o.sort((c,v)=>c.y-v.y),n.sort((c,v)=>v.x-c.x),a.sort((c,v)=>v.y-c.y);let d=[];s.length>0&&o.length>0&&n.length>0?(console.log("[U-Shape] Detected ㄷ pattern"),d=[...s,...o,...n],console.log("[U-Shape] Walking order:",{top:s.map(c=>`L${c.number}`).join("→"),right:o.map(c=>`L${c.number}`).join("→"),bottom:n.map(c=>`L${c.number}`).join("→"),total:d.map(c=>`L${c.number}`).join("→")})):a.length>0&&o.length>0?(console.log("[Back-to-Back] Detected two columns"),a.sort((c,v)=>c.y-v.y),o.sort((c,v)=>v.y-c.y),d=[...a,...o]):(console.log("[Simple Row] Single line of lockers"),d=[...t].sort((c,v)=>c.x-v.x)),a.length>0&&d.indexOf(a[0])===-1&&(console.log("[Left Column] Adding left side lockers"),d.push(...a)),i.length>0&&(console.log("[Middle] Adding uncategorized lockers:",i.length),d.push(...i));const r=t.length,h=d.length;if(r!==h){console.error("[Transform] Locker count mismatch!",{original:r,unfolded:h});const c=new Set(d.map(m=>m.id)),v=t.filter(m=>!c.has(m.id));console.log("[Missing] Lockers not included:",v.map(m=>`L${m.number}`)),d.push(...v)}Ie.value=d,console.log("[Front View] Transformation complete:",{totalLockers:d.length,sequence:d.map(c=>c.number||c.id).join(" -> ")})},pt=t=>{let e=t%360;return e<0&&(e+=360),e},mo=t=>Eo(),Et=t=>t.reduce((e,s)=>s.y<e.y||s.y===e.y&&s.x<e.x?s:e,t[0]),yo=t=>t.sort((e,s)=>{const o=Et(e),n=Et(s);return Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x}),Ut=t=>{const e=[],s=new Set;return t.forEach(o=>{if(s.has(o.id))return;const n=[],a=[o];for(;a.length>0;){const i=a.shift();s.has(i.id)||(s.add(i.id),n.push(i),t.forEach(d=>{s.has(d.id)||Zt(i,d)&&a.push(d)}))}n.length>0&&e.push(n)}),e.forEach((o,n)=>{console.log(`  Minor group ${n+1}: ${o.map(a=>a.number||a.id).join(", ")}`)}),e},gn=t=>{if(t.length<=1)return t[0]?t[0][0]:null;const e=new Map;for(const o of t){let n=0;for(const a of t){if(o===a)continue;let i=!1;for(const d of o){for(const r of a)if(qt(d,r)){i=!0;break}if(i)break}i&&n++}e.set(o,n)}const s=t.filter(o=>e.get(o)===1);if(s.length===0){console.log("[Clockwise Start] Complete loop detected, finding leftmost group");let o=t[0];for(const n of t){const a=at(n),i=at(o);a.x<i.x&&(o=n)}return console.log("[Clockwise Start] Selected leftmost group:",o.map(n=>n.number||n.id).join(",")),o[0]}if(s.length>=2){console.log("[Clockwise Start] Broken chain detected with",s.length,"endpoints");let o=s[0];for(const n of s){const a=at(n),i=at(o);(a.y>i.y||Math.abs(a.y-i.y)<10&&a.x<i.x)&&(o=n)}return console.log("[Clockwise Start] Selected endpoint:",o.map(n=>n.number||n.id).join(",")),o[0]}return console.log("[Clockwise Start] Fallback to first group"),t[0][0]},pn=(t,e)=>{for(const s of e)if(s.some(o=>o.id===t.id))return s;return null},at=t=>{const e=t.reduce((o,n)=>o+n.x,0),s=t.reduce((o,n)=>o+n.y,0);return{x:e/t.length,y:s/t.length}},mn=(t,e,s)=>{const o=[],n=at(t);for(const a of s){if(e.has(a))continue;let i=!1;for(const d of t){for(const r of a)if(qt(d,r)){i=!0;break}if(i)break}if(i){const d=at(a),r=d.x-n.x,h=d.y-n.y;let c=Math.atan2(h,r)*180/Math.PI;c<0&&(c+=360),o.push({group:a,angle:c})}}return o.length===0?null:(o.sort((a,i)=>a.angle-i.angle),o[0].group)},wo=t=>{if(console.log("[sortMinorGroups] Starting with",t.length,"groups"),t.length<=1)return t;const e=[],s=new Set;console.log("[sortMinorGroups] Finding clockwise start...");const o=gn(t);console.log("[sortMinorGroups] Start locker:",(o==null?void 0:o.number)||(o==null?void 0:o.id));const n=pn(o,t);if(!n)return console.log("[sortMinorGroups] No start group found, using fallback sorting"),t.sort((i,d)=>{const r=Et(i),h=Et(d);return Math.abs(r.y-h.y)>1?r.y-h.y:r.x-h.x});console.log("[sortMinorGroups] Start group:",n.map(i=>i.number||i.id).join(","));let a=n;for(;a&&!s.has(a);)console.log("[sortMinorGroups] Adding group:",a.map(i=>i.number||i.id).join(",")),e.push(a),s.add(a),a=mn(a,s,t);for(const i of t)s.has(i)||e.push(i);return e},xo=t=>{if(t.length===0)return[];const e=pt(t[0].rotation||0);let s=[...t];switch(console.log(`[Rotation] Processing minor group with rotation ${e}°:`,t.map(o=>`${o.number||o.id}`)),e){case 0:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 90:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 180:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:n.x-o.x);break;case 270:s.sort((o,n)=>Math.abs(o.x-n.x)>1?o.x-n.x:n.y-o.y);break}return console.log("[Rotation] After rotation, order:",s.map(o=>o.number||o.id)),s},yn=(t,e,s,o)=>{let n=null,a=null;s.forEach((m,$)=>{m.some(g=>g.id===t.id)&&(n=$),m.some(g=>g.id===e.id)&&(a=$)});const i=n!==null&&a!==null&&n===a;let d=!1;if(o){const m=o.get(t.id),$=o.get(e.id);d=m!==void 0&&$!==void 0&&m===$}const r=m=>{if(m.typeId==="custom-1755675491548")return"normal";if(m.typeId==="custom-1755675506519")return"tall";if(m.color==="#4A90E2")return"blue";if(m.color==="#BD10E0")return"purple";if(!m.typeId&&m.actualHeight){if(m.actualHeight===30)return"normal";if(m.actualHeight===90)return"tall"}return m.typeId||"default"},h=r(t),c=r(e),v=h===c;return i?{same:!0,sameType:v,sameMinorGroup:!0,sameMajorGroup:d,prevMinorGroup:n,currentMinorGroup:a,prevType:h,currentType:c}:{same:!1,sameType:v,sameMinorGroup:!1,sameMajorGroup:d,prevMinorGroup:n,currentMinorGroup:a,prevType:h,currentType:c}},wn=(t,e,s,o)=>{const n=yn(t,e,s,o);return console.log(`  Group spacing between ${t.number} and ${e.number}:`,n),n.sameMinorGroup?(console.log("  → Same minor group: 0px gap"),0):n.sameMajorGroup?(console.log("  → Same major group, different minor group: 10px gap"),10):(console.log("  → Different major group: 20px gap"),20)},it=()=>{console.trace("Called from:");const t=b.value.filter(y=>!y.parentLockrCd&&!y.parentLockerId);if(console.log(`[Transform] Processing ${t.length} parent lockers (${b.value.length-t.length} child lockers excluded from grouping)`),t.length===0)return;const e=mo(),s=yo(e),o=[],n=2;let a=0;const i=[],d=[],r=[],h=new Map;s.forEach((y,E)=>{console.log(`[Front View] Processing major group ${E+1}:`,y.map(F=>`${F.number||F.id}(rot:${F.rotation||0})`)),y.forEach(F=>{h.set(F.id,E)});const _=Ut(y),B=wo(_);r.push(...B),console.log(`  Found ${B.length} minor groups:`),B.forEach((F,U)=>{console.log(`    Minor Group ${U+1}:`,F.map(X=>`${X.number}(rot:${X.rotation||0})`))}),B.forEach((F,U)=>{console.log(`  Processing minor group ${U+1}:`,F.map(q=>`${q.number||q.id}(rot:${q.rotation||0})`)),xo(F).forEach(q=>{d.push(q)})})});let c=null;d.forEach((y,E)=>{if(o.push(y),c&&E>0){let F=0;!c.parentLockrCd&&!y.parentLockrCd&&(F=wn(c,y,r,h)),a+=F}const _=(y.width||40)*n,B=(y.actualHeight||y.height||60)*n;if(i.push({...y,frontViewX:a,frontViewY:Be-B,frontViewRotation:0}),y.parentLockrCd){const F=i.find(U=>U.lockrCd===y.parentLockrCd);if(F){let U=30;if(F.lockrTypeCd||F.typeId||F.type){const Me=F.lockrTypeCd||F.typeId||F.type,mt=xe.value.find(yt=>yt.id===Me||yt.type===Me||yt.LOCKR_TYPE_CD===Me);mt&&mt.height&&(U=mt.height,console.log(`[TIER HEIGHT] Using type height: ${U} for parent type: ${Me}`))}const X=U*n,q=y.tierLevel||1,pe=F.frontViewX,_e=F.frontViewY-X*q;i[i.length-1].frontViewX=pe,i[i.length-1].frontViewY=_e,i[i.length-1].frontViewRotation=0}else console.error(`[CHILD POSITION] Parent not found for ${y.number}, parentLockrCd: ${y.parentLockrCd}`),i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=Be-B,i[i.length-1].frontViewRotation=0,a+=_}else i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=Be-B,i[i.length-1].frontViewRotation=0,a+=_;c=y});const v=a,m=(P.value-v)/2;i.forEach(y=>{y.frontViewX+=m});const $=[],g=0;if(i.forEach(y=>{const E=(y.actualHeight||y.height||0)*2,_=y.frontViewY;if(_<g){console.warn(`[Boundary Check] 락커 ${y.number}이(가) 화면 위쪽 경계를 넘어갑니다:`,{lockerId:y.id,number:y.number,topEdge:_,height:E,canvasTop:g,isOverflowing:_<g});const B=b.value.find(F=>F.id===y.id);B&&$.push(B)}}),$.length>0){console.log(`[Boundary Check] 화면을 넘어가는 ${$.length}개의 락커를 삭제합니다:`,$.map(E=>`${E.number}(${E.id})`)),$.forEach(E=>{const _=b.value.findIndex(B=>B.id===E.id);_!==-1&&b.value.splice(_,1)});const y=$.map(async E=>{try{const _=await fetch(`${ge}/lockrs/${E.lockrCd}`,{method:"DELETE"});_.ok?console.log(`[Boundary Check] 백엔드에서 락커 ${E.number}(${E.lockrCd}) 삭제 완료`):console.error(`[Boundary Check] 백엔드에서 락커 ${E.number} 삭제 실패:`,await _.text())}catch(_){console.error(`[Boundary Check] 백엔드에서 락커 ${E.number} 삭제 중 오류:`,_)}});Promise.all(y).then(()=>{console.log("[Boundary Check] 모든 경계 초과 락커 삭제 완료, 락커 목록 다시 로드 및 위치 재계산"),Ae().then(()=>{ze(()=>{it()})})})}console.log("[Batch Update] Starting batch update for all lockers...");const C=[];i.forEach(y=>{C.push({id:y.id,updates:{frontViewX:y.frontViewX,frontViewY:y.frontViewY,frontViewRotation:y.frontViewRotation||0}})}),u.batchUpdateLockers(C),console.log(`[Batch Update] Updated ${C.length} lockers simultaneously`),console.log("[DB Save] Saving front view coordinates to database...");const I=C.map(async y=>{try{const E=b.value.find(_=>_.id===y.id);if(E&&E.lockrCd){const _={};y.updates.frontViewX!==void 0&&(_.FRONT_VIEW_X=y.updates.frontViewX),y.updates.frontViewY!==void 0&&(_.FRONT_VIEW_Y=y.updates.frontViewY);const B=await fetch(`${ge}/lockrs/${E.lockrCd}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(_)});B.ok?console.log(`[DB Save] Saved locker ${E.number} with FRONT_VIEW_X=${_.FRONT_VIEW_X}, FRONT_VIEW_Y=${_.FRONT_VIEW_Y}`):console.error(`[DB Save] Failed to save locker ${E.number}:`,await B.text())}}catch(E){console.error(`[DB Save] Failed to save locker ${y.id}:`,E)}});Promise.all(I).then(()=>{console.log("[DB Save] All front view coordinates saved to database")}).catch(y=>{console.error("[DB Save] Error saving some lockers:",y)}),Ie.value=o,console.log("[Front View] NEW Transformation complete:",{totalLockers:o.length,majorGroups:s.length,sequence:o.map(y=>y.number||y.id).join(" → "),deletedLockers:$.length})},bo=()=>{if(k.value!=="front"){Lo();return}const t=M.value.size>0?Array.from(M.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=t.map(a=>b.value.find(i=>i.id===a)).filter(Boolean);if(e.some(a=>!a.parentLockrCd||a.tierLevel===0)){alert("부모 락커는 삭제할 수 없습니다. 자식 락커(상단 락커)만 삭제 가능합니다.");return}const o=new Map;e.forEach(a=>{const i=a.parentLockrCd||"no-parent";o.has(i)||o.set(i,[]),o.get(i).push(a)}),console.log("[DELETE] Lockers grouped by parent:",Array.from(o.entries()).map(([a,i])=>({parent:a,lockers:i.map(d=>({id:d.id,number:d.number,tierLevel:d.tierLevel}))})));for(const[a,i]of o.entries()){const d=i.map(c=>c.tierLevel||0).filter((c,v,m)=>m.indexOf(c)===v).sort((c,v)=>v-c);console.log(`[DELETE] Parent ${a} tier levels:`,d);const r=Math.max(...d);if(!d.every((c,v)=>{const m=r-v,$=c===m;return console.log(`[DELETE] Parent ${a} tier validation:`,{tier:c,index:v,expected:m,isValid:$}),$})){alert(`삭제는 각 부모 그룹별로 가장 높은 tier부터 순서대로만 가능합니다. (부모: ${a})`);return}}const n=[];for(const[a,i]of o.entries()){const d=Math.max(...i.map(h=>h.tierLevel||0));console.log(`[DELETE] Parent ${a} selected max tier:`,d);const r=b.value.some(h=>h.parentLockrCd===a&&!i.find(c=>c.id===h.id)&&(h.tierLevel||0)>d);console.log(`[DELETE] Parent ${a} has upper tiers:`,r),r&&n.push({parentKey:a,selectedMaxTier:d,reason:"선택된 최상단 락커 위에 더 높은 tier 존재"})}if(n.length>0){console.log("[DELETE] Blocked groups:",n),alert("선택된 락커들 중 일부 그룹에서 최상단 락커 위에 더 높은 tier가 있습니다. 가장 높은 tier부터 삭제해주세요.");return}Lo(),w.value=null,console.log("[Delete] Deleted lockers:",t)},xn=t=>{const e=t.match(/locker-(\d+)/);return e?parseInt(e[1]):null},Lo=async()=>{const t=M.value.size>0?Array.from(M.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=[];for(const s of t){const o=b.value.find(n=>n.id===s);if(o&&(o.tierLevel===0||!o.parentLockerId)){const n=xn(s);if(n)try{const a=await fetch(`${ge}/lockrs/${n}/children`);if(a.ok){const i=await a.json(),d=i.children||i;d&&d.length>0&&e.push(o)}}catch(a){console.error("[DEBUG] Error checking children:",a)}}}if(e.length>0){alert("상단 락커가 존재합니다. 정면 배치모드에서 상단 락커를 먼저 삭제해주세요.");return}else{const s=t.length;if(!confirm(`삭제하시겠습니까? (${s}개 락커)`))return}t.forEach(s=>{u.deleteLocker(s)}),M.value.clear(),w.value=null,console.log("[Delete] Deleted lockers:",t)},bn=()=>{const e=(f.value?u.lockers.filter(o=>o.zoneId===f.value.id):b.value).map(o=>parseInt(String(o.lockrNo||0))).filter(o=>o>0).sort((o,n)=>o-n);if(e.length===0)return[];const s=[];for(let o=1;o<e[e.length-1];o++)e.includes(o)||s.push(`L${o}`);return s},Ln=t=>{M.value.size===0&&!w.value||(t.preventDefault(),Fe.value=!0,De.value={x:t.clientX,y:t.clientY})},lt=()=>{Fe.value=!1},Cn=()=>{bo(),lt()},kn=()=>{lt(),Se.value=!0,me.value=1},En=async()=>{const t=Number(me.value);if(isNaN(t)||t<1||t>9){alert("단수는 1부터 9까지 숫자만 입력 가능합니다.");return}if(k.value!=="front"){alert("단수 추가는 정면배치모드(Front View)에서만 가능합니다.");return}console.log("[AddFloors] Loading latest locker data from database..."),await Ae(),console.log("[AddFloors] Latest data loaded, processing tier addition...");const e=Array.from(M.value).map(o=>b.value.find(n=>n.id===o)).filter(Boolean),s=e.map(async o=>{let n=o,a=null;if(o.parentLockerId||o.parentLockrCd){if(a=b.value.find(h=>h.id===o.parentLockerId||h.lockrCd===o.parentLockrCd),!a){console.error(`[AddFloors] Parent not found for child locker ${o.number}`);return}n=a,console.log(`[AddFloors] Selected locker is CHILD (${o.number}), using parent (${n.number})`)}else console.log(`[AddFloors] Selected locker is PARENT (${n.number})`);console.log("[AddFloors] Finding existing children for parent:",{parentId:n.id,parentLockrCd:n.lockrCd,parentNumber:n.number});const i=b.value.filter(h=>{const c=h.parentLockrCd&&h.parentLockrCd===n.lockrCd||h.parentLockerId&&h.parentLockerId===n.id;return c&&console.log("[AddFloors] Found existing child:",{childId:h.id,childNumber:h.number,parentLockrCd:h.parentLockrCd,parentLockerId:h.parentLockerId,tierLevel:h.tierLevel||0}),c}),d=i.reduce((h,c)=>Math.max(h,c.tierLevel||0),0),r=d>0?d+1:1;console.log("[AddFloors] Tier level calculation:",{existingChildrenCount:i.length,maxExistingTier:d,startTierLevel:r,algorithm:d>0?`Children exist -> Start from tier ${r}`:"No children -> Start from tier 1"}),console.log(`[AddFloors] Adding ${t} tiers to parent locker:`,{number:n.number,parentLockrCd:n.lockrCd,existingChildren:i.length,existingChildrenDetails:i.map(h=>({number:h.number,tierLevel:h.tierLevel})),maxExistingTier:d,startTierLevel:r,frontViewX:n.frontViewX,frontViewY:n.frontViewY});try{const h={tierCount:t,startTierLevel:r,parentFrontViewX:n.frontViewX,parentFrontViewY:n.frontViewY};console.log("[AddFloors] Sending to backend:",h);const v=await(await fetch(`${ge}/lockrs/${n.lockrCd}/tiers`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(h)})).json();if(v.success)console.log(`[AddFloors] Successfully added ${v.count} tiers starting from level ${r}`);else throw console.error("[AddFloors] Failed to add tiers:",v.error),new Error(v.error)}catch(h){throw console.error("[AddFloors] Error adding tiers:",h),h}});try{await Promise.all(s),console.log("[AddFloors] All tiers added successfully")}catch(o){console.error("[AddFloors] Some tiers failed to add:",o),alert("티어 추가 중 오류가 발생했습니다: "+o.message);return}Se.value=!1,console.log(`[Context Menu] Added ${t} tiers to ${e.length} lockers`),Ae().then(()=>{ze(()=>{console.log("[AddFloors] Applying front view transformation for new tiers...");try{it(),console.log("[AddFloors] Front view transformation completed for new tiers")}catch(o){console.error("[AddFloors] Front view transformation failed:",o),po()}})}),go()},Mn=t=>{const e=t.target,o=e.value.replace(/[^0-9]/g,"");if(o!==""){const n=parseInt(o);n>9?(e.value="9",me.value=9):n<1?(e.value="1",me.value=1):(e.value=o,me.value=n)}else e.value="",me.value=1},$n=()=>{lt();const t=f.value?u.lockers.filter(o=>o.zoneId===f.value.id):b.value,e=new Set(t.map(o=>o.lockrNo).filter(o=>o&&o>0));let s=1;for(;e.has(s);)s++;console.log("[Number Dialog] 기존 번호:",Array.from(e).sort((o,n)=>o-n)),console.log(`[Number Dialog] 첫 번째 빈 번호: ${s}`),we.value=!0,L.value=s,H.value="horizontal",ne.value=!1,Z.value=!1},Tn=()=>{console.log("[Grouping Analysis] Starting analysis..."),console.log("[TEST] Running test with known data first..."),Nn();const t=b.value.filter(s=>!s.parentLockrCd);if(t.length===0){Ge.value="분석할 락커가 없습니다.",ye.value=!0;return}console.log("[REAL DATA] Now analyzing actual lockers...");let e=`세로배치 순서별 그룹 분석
`;e+=`━━━━━━━━━━━━━━━━━━━━━
`;try{const s=mo(t),o=yo(s);if(o.forEach((n,a)=>{e+=`대그룹 ${a+1} (${n.length}개 락커):
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;const i=Ut(n),d=wo(i);if(d.forEach((r,h)=>{const v=xo(r).map($=>{const g=t.find(C=>C.id===$.id);return`${(g==null?void 0:g.number)||$.id}(${(g==null?void 0:g.rotation)||0}°)`}).join(", ");let m="";if(r.length===1?m="단독":m="인접 (같은방향)",e+=`  소그룹 ${a+1}-${h+1}: ${v} - ${m}
`,r.length>1){e+=`    소그룹 내 거리:
`;for(let $=0;$<r.length-1;$++)for(let g=$+1;g<r.length;g++)if(Zt(r[$],r[g])){const C=Wt(r[$],r[g]),I=r[$].number||r[$].id,y=r[g].number||r[g].id;e+=`      ${I} ↔ ${y}: ${C.toFixed(2)}px
`}}}),d.length>1){e+=`  소그룹 간 거리:
`;for(let r=0;r<d.length-1;r++)for(let h=r+1;h<d.length;h++){let c=1/0,v={l1:"",l2:""};for(const m of d[r])for(const $ of d[h]){const g=Wt(m,$);g<c&&(c=g,v.l1=m.number||m.id,v.l2=$.number||$.id)}e+=`    소그룹 ${a+1}-${r+1} ↔ 소그룹 ${a+1}-${h+1}: ${c.toFixed(2)}px (${v.l1} - ${v.l2})
`}}e+=`
`}),o.length>1){e+=`대그룹 간 거리:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;for(let n=0;n<o.length-1;n++)for(let a=n+1;a<o.length;a++){let i=1/0,d={l1:"",l2:""};for(const r of o[n])for(const h of o[a]){const c=Wt(r,h);c<i&&(i=c,d.l1=r.number||r.id,d.l2=h.number||h.id)}e+=`  대그룹 ${n+1} ↔ 대그룹 ${a+1}: ${i.toFixed(2)}px (${d.l1} - ${d.l2})
`}e+=`
`}e+=`요약:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`,e+=`총 대그룹: ${s.length}개
`,e+=`총 소그룹: ${o.reduce((n,a)=>n+Ut(a).length,0)}개
`,e+=`
💡 이 순서는 세로배치 시 실제 표시 순서와 동일합니다.`}catch(s){console.error("[Grouping Analysis] Error:",s),e+=`분석 중 오류가 발생했습니다.
`,e+=s.message}Ge.value=e,ye.value=!0},jt=()=>{const t=f.value?u.lockers.filter(o=>o.zoneId===f.value.id):b.value;console.log("[findNextAvailableLabel] Total lockers in zone:",t.length);const e=t.map(o=>{const n=o.number||o.lockrLabel||"",a=n.toString().match(/^L(\d+)$/),i=a?parseInt(a[1]):0;return i>0&&console.log(`[findNextAvailableLabel] Found label ${n} -> number ${i}`),i}).filter(o=>o>0).sort((o,n)=>o-n);if(console.log("[findNextAvailableLabel] Assigned numbers:",e),e.length===0)return console.log("[findNextAvailableLabel] No existing labels, returning L1"),"L1";for(let o=1;o<e[e.length-1];o++)if(!e.includes(o))return console.log(`[findNextAvailableLabel] Found gap at ${o}, returning L${o}`),`L${o}`;const s=e[e.length-1]+1;return console.log(`[findNextAvailableLabel] No gaps found, returning L${s}`),`L${s}`},Dn=(t,e)=>{if(t.length===0)return[];const s=20;if(e){const o=new Map;return t.forEach(n=>{const a=n.frontViewY||n.y;let i=null;for(let[d]of o)if(Math.abs(a-d)<=s){i=d;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewX||a.x)-(i.frontViewX||i.x)))}else{const o=new Map;return t.forEach(n=>{const a=n.frontViewX||n.x;let i=null;for(let[d]of o)if(Math.abs(a-d)<=s){i=d;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewY||a.y)-(i.frontViewY||i.y)))}},Sn=async()=>{p.value=!0,z.value="번호 할당을 준비중입니다...";try{const t=f.value?u.lockers.filter(g=>g.zoneId===f.value.id):b.value,e=new Set(t.map(g=>g.lockrNo).filter(g=>g&&g>0));console.log("[Number Assignment] Step 1 - 기존 번호들:",Array.from(e).sort((g,C)=>g-C));const s=Array.from(M.value).map(g=>b.value.find(C=>C.id===g)).filter(Boolean);s.length>0&&(console.log("[Number Assignment] 샘플 락커 전체 데이터:",s[0]),console.log("[Number Assignment] 샘플 락커 주요 필드:",{id:s[0].id,lockrNo:s[0].lockrNo,lockrNoType:typeof s[0].lockrNo,number:s[0].number,numberType:typeof s[0].number,lockrCd:s[0].lockrCd,LOCKR_NO:s[0].LOCKR_NO,LOCKR_NO_Type:typeof s[0].LOCKR_NO}));const o=[],n=[];if(s.forEach((g,C)=>{const I=g.lockrNo||g.LOCKR_NO||g.number,y=Number(I),E=!isNaN(y)&&y>0;C<3&&console.log(`[Number Assignment] 락커 ${C+1} 상세:`,{id:g.id.slice(-4),lockrNo:g.lockrNo,LOCKR_NO:g.LOCKR_NO,number:g.number,converted:y,hasNumber:E}),E?(g.lockrNo=y,o.push(g)):n.push(g)}),console.log(`[Number Assignment] Step 2 - 선택된 락커: 총 ${s.length}개`),console.log(`  - 번호 있음: ${o.length}개`,o.map(g=>`L${g.lockrNo}`)),console.log(`  - 번호 없음: ${n.length}개`),n.length===0){alert("선택한 모든 락커에 이미 번호가 부여되어 있습니다."),p.value=!1;return}const a=H.value==="horizontal";let i=Dn(n,a);Z.value&&i.reverse(),ne.value&&i.forEach(g=>g.reverse());const d=i.flat();console.log("[Number Assignment] Step 2 - 정렬 완료:",d.map((g,C)=>`${C+1}번째: ${g.id.slice(-4)}`));const r=L.value||1;let h=r;const c=[],v=[];V.value==="odd"&&h%2===0?(h++,console.log(`[Number Assignment] 홀수 모드: 시작번호를 ${r}에서 ${h}로 조정`)):V.value==="even"&&h%2===1&&(h++,console.log(`[Number Assignment] 짝수 모드: 시작번호를 ${r}에서 ${h}로 조정`)),console.log(`[Number Assignment] Step 3 - 시작번호: ${h}, 할당할 락커 수: ${d.length}, 모드: ${V.value}`),z.value=`락커 번호를 할당중입니다... (0/${d.length})`;let m=0;for(const g of d){for(;e.has(h);)console.log(`  - ${h}번은 이미 사용중, 다음 번호 확인`),V.value==="all"?h++:h+=2;console.log(`  - ${g.id.slice(-4)} 락커에 ${h}번 할당`),u.updateLocker(g.id,{lockrNo:h}),g.lockrCd&&c.push({lockrCd:g.lockrCd,LOCKR_NO:h}),v.push(`${m+1}. ${g.id.slice(-4)} → L${h}`),e.add(h),V.value==="all"?h++:h+=2,m++,z.value=`락커 번호를 할당중입니다... (${m}/${d.length})`}if(console.log("[Number Assignment] Step 3 완료 - 할당 내역:",v),c.length>0)try{z.value=`데이터베이스에 ${c.length}개 락커 번호를 저장중입니다...`,console.log(`[Number Assignment] Step 4 - DB 배치 업데이트 시작: ${c.length}개`),await Io(c),console.log("[Number Assignment] Step 4 완료 - DB 업데이트 성공"),z.value="번호 할당이 완료되었습니다!"}catch(g){console.error("[Number Assignment] DB 업데이트 실패:",g),z.value="데이터베이스 저장에 실패했습니다.",alert("데이터베이스 저장 중 오류가 발생했습니다. 다시 시도해주세요.");return}console.log("[Number Assignment] 전체 프로세스 완료"),console.log(`  - 총 ${n.length}개 락커에 번호 할당 완료`),console.log(`  - ${o.length}개 락커는 기존 번호 유지`);const $=bn();$.length>0&&console.log("[Number Assignment] 번호 갭 발견:",$),setTimeout(()=>{we.value=!1},500)}catch(t){console.error("[Number Assignment] Assignment failed:",t),z.value="번호 할당 중 오류가 발생했습니다.",alert("번호 할당 중 오류가 발생했습니다. 다시 시도해주세요.")}finally{p.value=!1}},An=async()=>{if(lt(),confirm("선택된 락커의 번호를 삭제하시겠습니까?")){const t=Array.from(M.value).map(async e=>{try{u.updateLocker(e,{lockrNo:void 0});const s=b.value.find(o=>o.id===e);s&&s.lockrCd&&await so(s.lockrCd,{LOCKR_NO:0})}catch(s){console.error(`[Number Deletion] Failed to delete number for locker ${e}:`,s)}});await Promise.all(t)}},_n=()=>{console.log("[Overlap Fix] Starting overlap detection and fix...");let t=0;for(let e=0;e<b.value.length;e++){const s=b.value[e],o=Ee(s);for(let n=e+1;n<b.value.length;n++){const a=b.value[n],i=Ee(a),d=Math.min(o.x+o.width,i.x+i.width)-Math.max(o.x,i.x),r=Math.min(o.y+o.height,i.y+i.height)-Math.max(o.y,i.y),h=.5;if(d>h&&r>h){let c=a.x,v=a.y;if(Math.abs(d)<Math.abs(r))if(i.x<o.x+o.width/2){const C=Math.max(Math.abs(d)+4,4);c=a.x-C}else{const C=Math.max(Math.abs(d)+4,4);c=a.x+C}else if(i.y<o.y+o.height/2){const C=Math.max(Math.abs(r)+4,4);v=a.y-C}else{const C=Math.max(Math.abs(r)+4,4);v=a.y+C}c=Mt(c),v=Mt(v);const m=Ce(a);c=Math.max(0,Math.min(c,P.value-m.width)),v=Math.max(0,Math.min(v,se.value-m.height));const $=a.x,g=a.y;u.updateLocker(a.id,{x:c,y:v}),t++,console.log(`[Overlap Fix] Moved ${a.id} from (${$}, ${g}) to (${c}, ${v})`)}}}return t>0?console.log(`[Overlap Fix] Fixed ${t} overlapping lockers`):console.log("[Overlap Fix] No overlaps detected"),t},Ee=t=>{let e,s;if(t.type||t.id){const g=Ce(t);e=g.width,s=g.height}else e=t.width,s=t.height;const o=(t.rotation||0)*Math.PI/180;if(o===0)return{x:t.x,y:t.y,width:e,height:s,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s};const n=e/2,a=s/2,i=Math.cos(o),d=Math.sin(o),h=[{x:0,y:0},{x:e,y:0},{x:e,y:s},{x:0,y:s}].map(g=>{const C=g.x-n,I=g.y-a,y=C*i-I*d,E=C*d+I*i;return{x:t.x+n+y,y:t.y+a+E}}),c=Math.min(...h.map(g=>g.x)),v=Math.max(...h.map(g=>g.x)),m=Math.min(...h.map(g=>g.y)),$=Math.max(...h.map(g=>g.y));return{x:c,y:m,width:v-c,height:$-m,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s}},Mt=(t,e=20)=>Math.round(t/e)*e,Co=(t,e,s,o,n,a=0)=>{const r=Ee({x:t,y:e,width:s,height:o,rotation:a});let h=t,c=e,v=!1;console.log("=== SNAP PRIORITY DEBUG ==="),console.log("Checking corner snap first (priority 1)");for(const m of b.value){if(m.id===n)continue;const $=Ee(m),g=$.x,C=$.y,I=$.width,y=$.height,E=[{existingX:g+I,existingY:C+y,dragX:r.x,dragY:r.y,type:"corner-bottom-right-to-top-left"},{existingX:g,existingY:C+y,dragX:r.x+r.width,dragY:r.y,type:"corner-bottom-left-to-top-right"},{existingX:g+I,existingY:C,dragX:r.x,dragY:r.y+r.height,type:"corner-top-right-to-bottom-left"},{existingX:g,existingY:C,dragX:r.x+r.width,dragY:r.y+r.height,type:"corner-top-left-to-bottom-right"}];for(const X of E){const q=Math.sqrt(Math.pow(X.existingX-X.dragX,2)+Math.pow(X.existingY-X.dragY,2));if(q<20){console.log(`[CORNER SNAP] ${X.type}, distance: ${q.toFixed(1)}`),h=t+(X.existingX-X.dragX),c=e+(X.existingY-X.dragY),v=!0;break}}if(v){console.log("Corner snap succeeded - skipping face-to-face snap");break}if(console.log("No corner snap - checking face-to-face snap (priority 2)"),Math.abs(g+I-r.x)<20&&!v){h=t+(g+I-r.x);const X=Math.abs(r.y-C),q=Math.abs(r.y+r.height-(C+y));X<20?c=e+(C-r.y):q<20&&(c=e+(C+y-(r.y+r.height))),v=!0,console.log("[FACE SNAP] Right snap applied");continue}if(Math.abs(g-(r.x+r.width))<20&&!v){h=t+(g-(r.x+r.width));const X=Math.abs(r.y-C),q=Math.abs(r.y+r.height-(C+y));X<20?c=e+(C-r.y):q<20&&(c=e+(C+y-(r.y+r.height))),v=!0,console.log("[FACE SNAP] Left snap applied");continue}if(Math.abs(C+y-r.y)<20&&!v){c=e+(C+y-r.y);const X=Math.abs(r.x-g),q=Math.abs(r.x+r.width-(g+I));X<20?h=t+(g-r.x):q<20&&(h=t+(g+I-(r.x+r.width))),v=!0,console.log("[FACE SNAP] Bottom snap applied");continue}if(Math.abs(C-(r.y+r.height))<20&&!v){c=e+(C-(r.y+r.height));const X=Math.abs(r.x-g),q=Math.abs(r.x+r.width-(g+I));X<20?h=t+(g-r.x):q<20&&(h=t+(g+I-(r.x+r.width))),v=!0,console.log("[FACE SNAP] Top snap applied");continue}}return console.log("Final result: snapped =",v),{x:h,y:c}},Gt=(t,e,s,o,n=null,a=0,i=!1)=>{const d=Ee({x:t,y:e,width:s,height:o,rotation:a});return b.value.some(r=>{if(r.id===n||N.value&&M.value.has(r.id))return!1;const h=Ee(r),c=Math.min(d.x+d.width,h.x+h.width)-Math.max(d.x,h.x),v=Math.min(d.y+d.height,h.y+h.height)-Math.max(d.y,h.y),m=.5,$=c>m&&v>m;return $&&console.log("[COLLISION] Detected with",r.id,"- overlap:",`(${c.toFixed(1)}, ${v.toFixed(1)})`,"tolerance:",m),$})},On=()=>{console.log("[TEST] Creating test locker data with Adjacent/Connected thresholds..."),console.log("[TEST] ADJACENT: ≤30px + same direction, CONNECTED: 40-43px (any direction)");const t=[{id:"test-L1",number:"L1",x:100,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L2",number:"L2",x:165,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L3",number:"L3",x:230,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L4",number:"L4",x:312,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L5",number:"L5",x:377,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L6",number:"L6",x:442,y:100,width:40,height:60,rotation:90,color:"#BD10E0"}];return console.log("[TEST] Expected result: ALL in 1 major group (connected through L3↔L4)"),console.log("[TEST] Expected minor groups: [L1,L2,L3] (adjacent, 0°), [L4,L5,L6] (adjacent, 90°)"),console.log("[TEST] Key distances:"),console.log("[TEST]   L1↔L2: 25px (adjacent, same dir)"),console.log("[TEST]   L2↔L3: 25px (adjacent, same dir)"),console.log("[TEST]   L3↔L4: 42px (connected, diff dir)"),console.log("[TEST]   L4↔L5: 25px (adjacent, same dir)"),console.log("[TEST]   L5↔L6: 25px (adjacent, same dir)"),t},Nn=()=>{console.log("=== TESTING WITH KNOWN DATA ===");const t=[...b.value];b.value=On();const e=Eo();return b.value=t,console.log("=== TEST COMPLETE ==="),e},$t=t=>{const e=t.x||t.left||0,s=t.y||t.top||0,o=t.width||60,n=t.height||t.depth||40,a=(t.rotation||0)*Math.PI/180,i=e+o/2,d=s+n/2;return[{x:-o/2,y:-n/2},{x:o/2,y:-n/2},{x:o/2,y:n/2},{x:-o/2,y:n/2}].map(h=>({x:i+h.x*Math.cos(a)-h.y*Math.sin(a),y:d+h.x*Math.sin(a)+h.y*Math.cos(a)}))},Wt=(t,e)=>{const s=$t(t),o=$t(e);let n=1/0;for(const a of s)for(const i of o){const d=Math.sqrt(Math.pow(a.x-i.x,2)+Math.pow(a.y-i.y,2));n=Math.min(n,d)}return n},ko=(t,e,s)=>{const o=$t(t),n=$t(e);let a=0;for(const i of o)for(const d of n)Math.sqrt(Math.pow(i.x-d.x,2)+Math.pow(i.y-d.y,2))<s&&a++;return a},Zt=(t,e)=>{const s=ko(t,e,No),o=pt(t.rotation||0),n=pt(e.rotation||0),a=o===n;return s>=2&&a},qt=(t,e)=>{const s=ko(t,e,No);if(s>=1)return!0;if(s>=2){const o=pt(t.rotation||0),n=pt(e.rotation||0);return o!==n}return!1},Eo=()=>{const t=[],e=new Set;return b.value.forEach(s=>{console.log(`  ${s.number||s.id}: x=${s.x}, y=${s.y}, width=${s.width}, height=${s.height||s.depth}, rotation=${s.rotation||0}°`)}),b.value.forEach(s=>{if(e.has(s.id))return;const o=[s];e.add(s.id);const n=[s];for(;n.length>0;){const a=n.shift();b.value.forEach(i=>{if(e.has(i.id))return;const d=Zt(a,i),r=qt(a,i);(d||r)&&(o.push(i),e.add(i.id),n.push(i))})}t.push(o)}),t.forEach((s,o)=>{console.log(`  Group ${o+1}: ${s.map(n=>n.number||n.id).join(", ")}`)}),t},Rn=async t=>{try{const s={LOCKR_KND_CD:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,LOCKR_KND_NM:t.name,X:0,Y:0,WIDTH:P.value,HEIGHT:se.value,COLOR:t.color||"#f0f9ff"};await Ro(s);const o=Le.value.find(n=>n.LOCKR_KND_NM===t.name);o&&vt(o),R.value=!1}catch(e){console.error("Failed to save zone:",e),alert("Failed to save zone. Please try again.")}},In=async t=>{var e;try{const s={id:`locker-${Date.now()}`,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:`custom-${Date.now()}`,zoneId:((e=f.value)==null?void 0:e.id)||null,x:0,y:0,rotation:0};await Yt(s);try{const n=await fetch(`${ge}/types`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LOCKR_TYPE_CD:`custom-${Date.now()}`,LOCKR_TYPE_NM:t.name,WIDTH:t.width,HEIGHT:t.height,DEPTH:t.depth,COLOR:t.color||"#3b82f6"})});n.ok?console.log("[Locker Registration] Type saved to backend successfully"):console.error("Failed to save locker type to backend:",await n.text())}catch(n){console.error("Error saving locker type to backend:",n)}const o={id:s.id,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:s.type};xe.value.push(o),Y.value=!1,console.log("[Locker Registration] New locker saved:",{id:s.id,name:s.name,dimensions:{width:s.width,depth:s.depth,height:s.height},type:s.type})}catch(s){console.error("Failed to save locker:",s),alert("Failed to save locker. Please try again.")}},Fn=()=>{console.log("[Debug] All locker dimensions:"),b.value.forEach(t=>{console.log(`${t.type||t.name}:`,{id:t.id,width:t.width,height:t.height,depth:t.depth,actualHeight:t.actualHeight,position:{x:t.x,y:t.y}})}),console.log("[Snap System] Configuration:",{threshold:20,lockerCount:b.value.length,viewMode:k.value})},Tt=(t,e)=>{if(!w.value)return;const s=Math.max(0,Math.min(w.value.x+t,P.value-w.value.width)),o=Math.max(0,Math.min(w.value.y+e,se.value-w.value.height));u.updateLocker(w.value.id,{x:s,y:o})},Jt=t=>{(t.ctrlKey||t.metaKey)&&(J.value=!0);const e=t.target;if(e.tagName==="INPUT"||e.tagName==="TEXTAREA"){console.log("[Keyboard] Ignored - typing in input field");return}if(Y.value||R.value){console.log("[Keyboard] Ignored - modal is open");return}if((t.ctrlKey||t.metaKey)&&t.shiftKey&&t.key==="F"){t.preventDefault();const s=_n();s>0?(console.log(`[Keyboard] Fixed ${s} overlapping lockers`),alert(`Fixed ${s} overlapping lockers`)):(console.log("[Keyboard] No overlaps detected"),alert("No overlapping lockers found"));return}if((t.ctrlKey||t.metaKey)&&t.key==="a"){t.preventDefault(),b.value.forEach(s=>{M.value.add(s.id)}),b.value.length>0&&(w.value=b.value[0]),console.log("[Multi-Select] Selected all lockers");return}if(t.key==="r"||t.key==="R"){t.preventDefault(),w.value;return}if((t.ctrlKey||t.metaKey)&&t.key==="c"){if(k.value==="front"){console.log("[Copy] Disabled in front view mode");return}t.preventDefault(),M.value.size>0?(Qe.value=Array.from(M.value).map(s=>{const o=b.value.find(n=>n.id===s);return o?{...o}:null}).filter(Boolean),console.log("[Multi-Select] Copied",Qe.value.length,"lockers")):w.value&&(Qe.value=[{...w.value}],console.log("[Copy] Locker copied:",w.value.id));return}if((t.ctrlKey||t.metaKey)&&t.key==="v"&&Qe.value&&Qe.value.length>0&&f.value){if(k.value==="front"){console.log("[Paste] Disabled in front view mode");return}t.preventDefault(),M.value.clear(),Qe.value.forEach((s,o)=>{const n={...s,id:`locker-${Date.now()}-${Math.random()}`,number:jt(),x:s.x+20,y:s.y+20,zoneId:f.value.id},a=u.addLocker(n);M.value.add(a.id),o===0&&(w.value=a)}),console.log("[Multi-Select] Pasted",Qe.value.length,"lockers");return}if((t.key==="Delete"||t.key==="Backspace")&&(w.value||M.value.size>0)&&(t.preventDefault(),bo()),(t.key==="g"||t.key==="G")&&(t.preventDefault(),ft.value=!ft.value,console.log(`[Alignment] Guides ${ft.value?"ON":"OFF"}`)),t.ctrlKey&&t.key==="z"&&(t.preventDefault(),u.undo()),t.ctrlKey&&t.key==="y"&&(t.preventDefault(),u.redo()),t.key==="Escape"&&(M.value.clear(),w.value=null,u.selectLocker(null)),w.value){const s=t.shiftKey?20:1;t.key==="ArrowLeft"?(t.preventDefault(),Tt(-s,0)):t.key==="ArrowRight"?(t.preventDefault(),Tt(s,0)):t.key==="ArrowUp"?(t.preventDefault(),Tt(0,-s)):t.key==="ArrowDown"&&(t.preventDefault(),Tt(0,s))}};At(()=>b.value,t=>{if(w.value){const e=t.find(s=>s.id===w.value.id);e&&(w.value=e)}},{deep:!0}),At(()=>k.value,async(t,e)=>{if(e&&t!==e){if(console.log(`[ViewMode Change] ${e} → ${t}, reloading lockers...`),await Ae(),t==="front"&&e==="floor")console.log("[ViewMode Change] Transitioning from floor to front - recalculating positions..."),ze(()=>{try{it(),console.log("[ViewMode Change] Front view transformation completed")}catch(s){console.error("[ViewMode Change] Front view transformation failed:",s),po()}});else if(t==="front"&&e==="front"){console.log("[ViewMode Change] Zone change in front view - checking for missing coordinates...");const s=b.value.filter(o=>o.frontViewX===null||o.frontViewX===void 0||o.frontViewY===null||o.frontViewY===void 0);s.length>0?(console.log(`[ViewMode Change] Found ${s.length} lockers with missing front view coordinates`),console.log("[ViewMode Change] Missing coordinates for lockers:",s.map(o=>o.number).join(", ")),console.log("[ViewMode Change] Recalculating positions for ALL lockers in zone using grouping logic"),ze(()=>{try{it(),console.log("[ViewMode Change] Zone-wide recalculation completed")}catch(o){console.error("[ViewMode Change] Zone-wide recalculation failed:",o)}})):console.log("[ViewMode Change] All lockers have saved positions - using DB coordinates")}}else e||console.log("[ViewMode Watcher] Initial mount - skipping reload (onMounted will handle it)")});const Pn=oe(()=>ie.value||N.value?"grabbing":Xe.value?"crosshair":J.value&&M.value.size>0?"copy":M.value.size>0?"move":"default"),Yn=oe(()=>{const t=Ne/te.value,e=He/te.value,s=ee.value.x,o=ee.value.y;return`${s} ${o} ${t} ${e}`});At(M,t=>{},{immediate:!0,deep:!0}),At(Ct,t=>{},{deep:!0}),Hn(async()=>{console.log("Component mounted, loading data..."),k.value="floor",console.log("[onMounted] Initial view mode set to:",k.value),Ke.value=!0,dt.value=!0;try{if(await Promise.all([Pt(),no()]),console.log("[onMounted] About to load lockers with view mode:",k.value),await Ae(),await ze(),Ke.value=!1,dt.value=!1,console.log("All data loading completed"),k.value==="floor"&&b.value.length>0&&setTimeout(()=>{nt()},100),k.value==="front"){const t=b.value.filter(e=>e.frontViewX===null||e.frontViewX===void 0||e.frontViewY===null||e.frontViewY===void 0);t.length>0&&(console.log(`[onMounted] Found ${t.length} lockers with missing front view coordinates`),console.log("[onMounted] Auto-calculating positions for lockers:",t.map(e=>e.number).join(", ")),ze(()=>{try{it(),console.log("[onMounted] Auto-calculation completed")}catch(e){console.error("[onMounted] Auto-calculation failed:",e)}}))}Le.value.length>0&&!f.value&&(vt(Le.value[0]),console.log("[Data Loading] Auto-selected first zone:",Le.value[0].name))}catch(t){console.error("Error loading data:",t),Ke.value=!1,dt.value=!1}window.addEventListener("resize",tt),document.addEventListener("keydown",Jt),document.addEventListener("keyup",Qt),document.addEventListener("click",lt),u.zones.length>0&&vt(u.zones[0]),document.addEventListener("keydown",Jt),document.addEventListener("keyup",Qt)});const Qt=t=>{!t.ctrlKey&&!t.metaKey&&(J.value=!1)};return Un(()=>{document.removeEventListener("keydown",Jt),document.removeEventListener("keyup",Qt),document.removeEventListener("click",lt),window.removeEventListener("resize",tt)}),(t,e)=>{var s;return A(),O("div",Xs,[Ke.value||dt.value?(A(),O("div",zs,e[34]||(e[34]=[l("div",{class:"loading-spinner"},[l("div",{class:"spinner"}),l("p",null,"Loading locker data...")],-1)]))):(A(),O("div",Bs,[l("div",Hs,[l("aside",Us,[e[39]||(e[39]=l("h2",{class:"sidebar-title"},"락커 선택창",-1)),Ke.value?(A(),O("div",js,e[35]||(e[35]=[l("p",null,"🔄 락커 타입을 불러오는 중...",-1)]))):oo.value&&Vt.value.length===0?(A(),O("div",Gs,e[36]||(e[36]=[l("p",null,"📦 등록된 락커가 없습니다",-1),l("p",{class:"empty-hint"},"락커를 등록해주세요",-1)]))):Vt.value.length>0?(A(),O("div",Ws,[(A(!0),O(be,null,$e(Vt.value,o=>{var n;return A(),O("div",{key:o.id,class:"locker-type-item-wrapper"},[l("div",{class:Re(["locker-type-item",{active:((n=T.value)==null?void 0:n.id)===o.id}]),onClick:a=>jo(o),onDblclick:a=>Wo(o),onContextmenu:he(a=>Uo(a,o),["prevent"]),style:{cursor:"pointer"}},[l("div",qs,[(A(),O("svg",{width:(o.width||40)*2,height:(o.depth||o.width||40)*2,viewBox:`0 0 ${(o.width||40)*2} ${(o.depth||o.width||40)*2}`,class:"type-preview"},[l("rect",{x:"2",y:"2",width:Math.max((o.width||40)*2-4,1),height:Math.max((o.depth||o.width||40)*2-4,1),fill:o.color?`${o.color}20`:"#FFFFFF",stroke:"#9ca3af","stroke-width":.5*2,rx:2*2,ry:2*2,"shape-rendering":"crispEdges"},null,8,Qs),l("line",{x1:10,y1:(o.depth||o.width||40)*2-5,x2:(o.width||40)*2-10,y2:(o.depth||o.width||40)*2-5,stroke:o.color||"#1e40af","stroke-width":"4",opacity:"0.9","stroke-linecap":"square",class:"front-indicator"},null,8,ea)],8,Js))]),l("div",ta,[l("span",oa,j(o.name||"Unknown"),1),l("span",na,j(o.width)+"x"+j(o.depth||o.width)+"x"+j(o.height)+"cm ",1)])],42,Zs),l("button",{class:"delete-type-button",onClick:he(a=>co(o),["stop"]),title:"이 락커 타입 삭제"},e[37]||(e[37]=[l("svg",{width:"16",height:"16",viewBox:"0 0 16 16"},[l("path",{d:"M4 4 L12 12 M12 4 L4 12",stroke:"#ef4444","stroke-width":"2","stroke-linecap":"round"})],-1)]),8,sa)])}),128))])):Q("",!0),ut.value.length>0?(A(),O("div",aa,[e[38]||(e[38]=l("div",{class:"section-title"},"삭제된 타입",-1)),(A(!0),O(be,null,$e(ut.value,o=>(A(),O("div",{key:o,class:"deleted-type-item"},[l("span",null,j(qo(o)),1),l("button",{onClick:n=>Zo(o),class:"restore-btn"},"복원",8,ia)]))),128))])):Q("",!0),l("button",{class:"register-locker-btn",onClick:e[0]||(e[0]=o=>Y.value=!0)}," 락커 등록 ")]),l("main",la,[l("div",ra,[l("div",ca,[(A(!0),O(be,null,$e(Le.value,o=>{var n,a;return A(),O("button",{key:o.id,class:Re(["zone-tab",{active:((n=f.value)==null?void 0:n.id)===o.id}]),onClick:i=>vt(o),onContextmenu:i=>Bo(i,o)},[Oe(j(o.name)+" ",1),((a=f.value)==null?void 0:a.id)===o.id?(A(),O("span",ua)):Q("",!0)],42,da)}),128))]),l("div",ha,[l("button",{class:"zone-add-btn",onClick:e[1]||(e[1]=o=>R.value=!0)}," + 구역 추가 "),l("div",fa,[l("button",{class:Re(["mode-btn",{active:k.value==="floor"}]),onClick:e[2]||(e[2]=o=>vo("floor")),title:"평면배치모드 (P)"},e[40]||(e[40]=[Ot('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-dbc5bf2d><rect x="3" y="3" width="18" height="18" rx="2" data-v-dbc5bf2d></rect><rect x="7" y="7" width="4" height="4" data-v-dbc5bf2d></rect><rect x="13" y="7" width="4" height="4" data-v-dbc5bf2d></rect><rect x="7" y="13" width="4" height="4" data-v-dbc5bf2d></rect><rect x="13" y="13" width="4" height="4" data-v-dbc5bf2d></rect></svg><span data-v-dbc5bf2d>평면배치</span>',2)]),2),l("button",{class:Re(["mode-btn",{active:k.value==="front"}]),onClick:e[3]||(e[3]=o=>vo("front")),title:"정면배치모드 (F)"},e[41]||(e[41]=[Ot('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-dbc5bf2d><rect x="3" y="3" width="18" height="18" rx="2" data-v-dbc5bf2d></rect><line x1="3" y1="15" x2="21" y2="15" stroke-dasharray="2 2" data-v-dbc5bf2d></line><rect x="7" y="7" width="4" height="6" data-v-dbc5bf2d></rect><rect x="13" y="7" width="4" height="6" data-v-dbc5bf2d></rect></svg><span data-v-dbc5bf2d>정면배치</span>',2)]),2),l("button",{class:"mode-btn",onClick:Tn,title:"그룹핑 결과 확인"},e[42]||(e[42]=[l("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("circle",{cx:"12",cy:"12",r:"3"}),l("path",{d:"M12 1v6m0 6v6"}),l("path",{d:"m21 12-6-3-6 3-6-3"})],-1),l("span",null,"그룹핑 확인",-1)])),k.value==="floor"||k.value==="front"?(A(),O("div",va,[l("button",{class:"zoom-btn",onClick:nt,title:"모든 락커가 화면에 맞춤 (클릭)"},[e[43]||(e[43]=l("svg",{width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("rect",{x:"3",y:"3",width:"18",height:"18",rx:"2"}),l("path",{d:"M7 7h.01M7 12h.01M7 17h.01M12 7h.01M12 12h.01M12 17h.01M17 7h.01M17 12h.01M17 17h.01"})],-1)),l("span",null,j(Math.round(te.value*100))+"%",1)]),e[44]||(e[44]=l("div",{class:"zoom-hints"},[l("span",{class:"hint"},"Ctrl+스크롤: 줌"),l("span",{class:"hint"},"휠클릭+드래그: 이동")],-1))])):Q("",!0),l("button",{class:"mode-btn debug-btn",onClick:e[4]||(e[4]=o=>Ve.value=!0),title:"락커 데이터 상세 확인"},e[45]||(e[45]=[l("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[l("path",{d:"m9 12 2 2 4-4"}),l("path",{d:"M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"}),l("path",{d:"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"})],-1),l("span",null,"디버그 정보",-1)]))])])]),l("div",ga,[(A(),O("svg",{ref_key:"canvasRef",ref:S,class:"canvas",width:"100%",height:"100%",viewBox:Yn.value,style:ct({cursor:Pn.value,margin:0,padding:0}),preserveAspectRatio:"none",onWheel:he(Jo,["prevent"]),onMousedown:Qo,onMousemove:en,onMouseup:uo,onMouseleave:uo,onClick:nn},[e[47]||(e[47]=Ot('<defs data-v-dbc5bf2d><pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse" data-v-dbc5bf2d><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e5e5e5" stroke-width="0.5" data-v-dbc5bf2d></path></pattern><filter id="buttonShadow" x="-50%" y="-50%" width="200%" height="200%" data-v-dbc5bf2d><feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" data-v-dbc5bf2d></feDropShadow></filter></defs><rect width="100%" height="100%" fill="url(#grid)" class="canvas-background" data-v-dbc5bf2d></rect>',2)),f.value?(A(),O("rect",{key:0,x:"0",y:"0",width:P.value,height:se.value,fill:"none",stroke:"black","stroke-width":"1"},null,8,ma)):Q("",!0),k.value==="front"?(A(),O("g",ya,[l("line",{x1:0,y1:Be,x2:bt,y2:Be,stroke:"#94a3b8","stroke-width":"2","stroke-dasharray":"10,5"}),l("text",{x:ee.value.x+20/te.value,y:Be+20,fill:"#64748b","font-size":12/te.value,"font-weight":"500"}," 바닥선 ",8,wa),l("text",{x:ee.value.x+(Ne-80)/te.value,y:Be+20,fill:"#64748b","font-size":12/te.value,"font-weight":"500","text-anchor":"end"}," 바닥선 ",8,xa)])):Q("",!0),(A(!0),O(be,null,$e(Xo.value,o=>{var n,a;return A(),wt(ps,{key:o.id,locker:o,"is-selected":((n=w.value)==null?void 0:n.id)===o.id,"is-multi-selected":M.value.has(o.id),"should-hide-individual-outline":zo.value.has(o.id)&&!N.value,"is-dragging":N.value&&M.value.has(o.id),"adjacent-sides":Vo(o.id),"view-mode":k.value,"is-transitioning-to-floor":Ht.value,"show-number":!0,"show-rotate-handle":((a=w.value)==null?void 0:a.id)===o.id,"zoom-level":te.value,onClick:(i,d)=>sn(i,d),onContextmenu:he(Ln,["prevent"]),onSelect:e[5]||(e[5]=i=>w.value=b.value.find(d=>d.id===i)),onDragstart:ln,onRotatestart:rn,onRotate:cn,onRotateend:dn},null,8,["locker","is-selected","is-multi-selected","should-hide-individual-outline","is-dragging","adjacent-sides","view-mode","is-transitioning-to-floor","show-rotate-handle","zoom-level","onClick"])}),128)),Ct.value.length>0&&!N.value?(A(),O("g",ba,[(A(!0),O(be,null,$e(Ct.value.filter(o=>o.length>1),(o,n)=>{var a,i,d,r;return A(),O("rect",{key:`group-${n}`,x:(((a=Lt(o))==null?void 0:a.minX)||0)-5,y:(((i=Lt(o))==null?void 0:i.minY)||0)-5,width:(((d=Lt(o))==null?void 0:d.width)||0)+10,height:(((r=Lt(o))==null?void 0:r.height)||0)+10,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"unified-selection-outline","pointer-events":"none"},e[46]||(e[46]=[l("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,La)}),128))])):Q("",!0),w.value&&!N.value&&ae.value?(A(),O("g",Ca,[l("g",{transform:`translate(${io().x}, ${io().y}) rotate(${w.value.rotation||0}, ${w.value.width/2}, ${w.value.height/2})`},null,8,ka)])):Q("",!0),ft.value?(A(),O("g",Ea,[(A(!0),O(be,null,$e(lo.value,o=>(A(),O("line",{key:`h-${o.position}`,x1:0,y1:o.position,x2:P.value,y2:o.position,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,Ma))),128)),(A(!0),O(be,null,$e(ro.value,o=>(A(),O("line",{key:`v-${o.position}`,x1:o.position,y1:0,x2:o.position,y2:se.value,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,$a))),128))])):Q("",!0),Xe.value&&re.value.x!=null&&re.value.y!=null&&de.value.x!=null&&de.value.y!=null&&Math.abs((de.value.x||0)-(re.value.x||0))>5?(A(),O("rect",{key:5,x:Math.min(re.value.x||0,de.value.x||0),y:Math.min(re.value.y||0,de.value.y||0),width:Math.abs((de.value.x||0)-(re.value.x||0)),height:Math.abs((de.value.y||0)-(re.value.y||0)),fill:"rgba(0, 122, 255, 0.1)",stroke:"#007AFF","stroke-width":"1","stroke-dasharray":"5 5","pointer-events":"none",class:"selection-box"},null,8,Ta)):Q("",!0)],44,pa))])])])])),R.value?(A(),wt(Ts,{key:2,onClose:e[6]||(e[6]=o=>R.value=!1),onSave:Rn})):Q("",!0),Y.value?(A(),wt(Ks,{key:3,onClose:e[7]||(e[7]=o=>Y.value=!1),onSave:In})):Q("",!0),Fe.value?(A(),O("div",{key:4,style:ct({position:"fixed",left:De.value.x+"px",top:De.value.y+"px",zIndex:1e3}),class:"context-menu",onClick:e[8]||(e[8]=he(()=>{},["stop"]))},[k.value==="front"?(A(),O(be,{key:0},[l("div",{class:"context-menu-item",onClick:kn},e[48]||(e[48]=[l("i",{class:"fas fa-layer-group"},null,-1),Oe(" 단수 입력 ",-1)])),l("div",{class:"context-menu-item",onClick:$n},e[49]||(e[49]=[l("i",{class:"fas fa-sort-numeric-up"},null,-1),Oe(" 번호 부여 ",-1)])),l("div",{class:"context-menu-item",onClick:An},e[50]||(e[50]=[l("i",{class:"fas fa-eraser"},null,-1),Oe(" 번호 삭제 ",-1)]))],64)):Q("",!0),l("div",{class:"context-menu-item",onClick:Cn},e[51]||(e[51]=[l("i",{class:"fas fa-trash"},null,-1),Oe(" 락커 삭제 ",-1)]))],4)):Q("",!0),Se.value?(A(),O("div",{key:5,class:"modal-overlay",onClick:tn},[l("div",{class:"modal-content",onClick:e[11]||(e[11]=he(()=>{},["stop"]))},[e[53]||(e[53]=l("h3",null,"단수 입력",-1)),l("div",Da,[e[52]||(e[52]=l("label",null,"단수:",-1)),fe(l("input",{"onUpdate:modelValue":e[9]||(e[9]=o=>me.value=o),type:"number",min:"1",max:"9",placeholder:"1-9 사이 입력",class:"form-control",onInput:Mn},null,544),[[Ue,me.value,void 0,{number:!0}]])]),l("div",Sa,[l("button",{class:"btn btn-secondary",onClick:e[10]||(e[10]=o=>Se.value=!1)},"취소"),l("button",{class:"btn btn-primary",onClick:En},"확인")])])])):Q("",!0),we.value?(A(),O("div",{key:6,class:"modal-overlay",onClick:on},[l("div",{class:"modal-content number-assign-modal",onClick:e[21]||(e[21]=he(()=>{},["stop"]))},[e[66]||(e[66]=l("h3",null,"번호 부여",-1)),l("div",Aa,[e[57]||(e[57]=l("div",{style:{display:"flex","justify-content":"space-between","margin-bottom":"10px"}},[l("label",null,"시작번호:"),l("label",{style:{"margin-right":"100px"}},"번호생성옵션:")],-1)),l("div",_a,[fe(l("input",{"onUpdate:modelValue":e[12]||(e[12]=o=>L.value=o),type:"number",min:1,placeholder:"시작 번호",class:"form-control number-input",style:{width:"120px"}},null,512),[[Ue,L.value,void 0,{number:!0}]]),l("div",Oa,[l("label",Na,[fe(l("input",{type:"radio","onUpdate:modelValue":e[13]||(e[13]=o=>V.value=o),value:"all"},null,512),[[xt,V.value]]),e[54]||(e[54]=l("span",null,"전체",-1))]),l("label",Ra,[fe(l("input",{type:"radio","onUpdate:modelValue":e[14]||(e[14]=o=>V.value=o),value:"odd"},null,512),[[xt,V.value]]),e[55]||(e[55]=l("span",null,"홀수",-1))]),l("label",Ia,[fe(l("input",{type:"radio","onUpdate:modelValue":e[15]||(e[15]=o=>V.value=o),value:"even"},null,512),[[xt,V.value]]),e[56]||(e[56]=l("span",null,"짝수",-1))])])])]),l("div",Fa,[e[60]||(e[60]=l("div",{class:"form-labels-row"},[l("label",{class:"section-label"},"생성방향:")],-1)),l("div",Pa,[l("div",Ya,[l("label",Va,[fe(l("input",{type:"radio","onUpdate:modelValue":e[16]||(e[16]=o=>H.value=o),value:"horizontal"},null,512),[[xt,H.value]]),e[58]||(e[58]=l("span",null,"가로",-1))]),l("label",Ka,[fe(l("input",{type:"radio","onUpdate:modelValue":e[17]||(e[17]=o=>H.value=o),value:"vertical"},null,512),[[xt,H.value]]),e[59]||(e[59]=l("span",null,"세로",-1))])])])]),l("div",Xa,[e[63]||(e[63]=l("label",{class:"section-label"},"추가옵션:",-1)),l("div",za,[e[61]||(e[61]=l("span",{style:{"margin-right":"8px"}},"역방향",-1)),fe(l("input",{type:"checkbox","onUpdate:modelValue":e[18]||(e[18]=o=>ne.value=o),style:{"margin-right":"30px"}},null,512),[[Mo,ne.value]]),e[62]||(e[62]=l("span",{style:{"margin-right":"8px"}},"아래에서부터",-1)),fe(l("input",{type:"checkbox","onUpdate:modelValue":e[19]||(e[19]=o=>Z.value=o)},null,512),[[Mo,Z.value]])])]),p.value?(A(),O("div",Ba,[l("div",Ha,[e[64]||(e[64]=l("div",{class:"loading-spinner"},null,-1)),l("span",Ua,j(z.value),1)])])):Q("",!0),l("div",ja,[l("button",{class:"btn btn-secondary",onClick:e[20]||(e[20]=o=>we.value=!1),disabled:p.value}," 취소 ",8,Ga),l("button",{class:"btn btn-primary",onClick:Sn,disabled:p.value},[p.value?(A(),O("span",Za,e[65]||(e[65]=[l("i",{class:"fas fa-spinner fa-spin"},null,-1),Oe(" 처리중... ",-1)]))):(A(),O("span",qa,"번호 부여"))],8,Wa)])])])):Q("",!0),ye.value?(A(),O("div",{key:7,class:"modal-overlay",onClick:e[24]||(e[24]=o=>ye.value=!1)},[l("div",{class:"modal-content grouping-popup",onClick:e[23]||(e[23]=he(()=>{},["stop"]))},[e[67]||(e[67]=l("h3",null,"대그룹 분석 결과",-1)),l("div",Ja,[l("pre",null,j(Ge.value),1)]),l("div",Qa,[l("button",{class:"btn btn-primary",onClick:e[22]||(e[22]=o=>ye.value=!1)},"확인")])])])):Q("",!0),Ve.value?(A(),O("div",{key:8,class:"modal-overlay",onClick:e[28]||(e[28]=o=>Ve.value=!1)},[l("div",{class:"modal-content debug-popup",onClick:e[27]||(e[27]=he(()=>{},["stop"]))},[e[74]||(e[74]=l("h3",null,"🔍 락커 데이터 디버깅 정보",-1)),l("div",ei,[e[72]||(e[72]=l("h4",null,"📊 전체 통계",-1)),l("div",ti,[l("div",oi,[e[68]||(e[68]=l("span",{class:"label"},"Store 전체:",-1)),l("span",ni,j(eo(u).lockers.length)+"개",1)]),l("div",si,[e[69]||(e[69]=l("span",{class:"label"},"현재 구역:",-1)),l("span",ai,j(b.value.length)+"개",1)]),l("div",ii,[e[70]||(e[70]=l("span",{class:"label"},"뷰모드:",-1)),l("span",li,j(k.value),1)]),l("div",ri,[e[71]||(e[71]=l("span",{class:"label"},"선택 구역:",-1)),l("span",ci,j(((s=f.value)==null?void 0:s.name)||"None"),1)])])]),l("div",di,[l("h4",null,"🏢 Store 전체 락커 ("+j(eo(u).lockers.length)+"개)",1),l("div",ui,[(A(!0),O(be,null,$e(eo(u).lockers,o=>(A(),O("div",{key:o.id,class:Re(["locker-item",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[l("div",hi,[l("span",fi,j(o.number),1),l("span",vi,j(o.parentLockrCd?"자식":"부모"),1)]),l("div",gi,[l("span",null,"ID: "+j(o.id),1),l("span",null,"Zone: "+j(o.zoneId),1),l("span",null,"Parent: "+j(o.parentLockrCd||"None"),1),l("span",null,"Height: "+j(o.actualHeight||o.height)+"px",1)])],2))),128))])]),l("div",pi,[l("h4",null,"👁️ 현재 표시 락커 ("+j(b.value.length)+"개)",1),l("div",mi,[(A(!0),O(be,null,$e(b.value,o=>(A(),O("div",{key:o.id,class:Re(["locker-item current",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[l("div",yi,[l("span",wi,j(o.number),1),l("span",xi,j(o.parentLockrCd?"자식":"부모"),1),e[73]||(e[73]=l("span",{class:"render-status"},"표시중",-1))]),l("div",bi,[l("span",null,"위치: ("+j(o.x)+", "+j(o.y)+")",1),l("span",null,"크기: "+j(o.width)+"x"+j(o.height),1),l("span",null,"실제높이: "+j(o.actualHeight)+"px",1),l("span",null,"회전: "+j(o.rotation)+"°",1)])],2))),128))])]),l("div",Li,[l("button",{class:"btn btn-secondary",onClick:e[25]||(e[25]=o=>Ae())},"🔄 새로고침"),l("button",{class:"btn btn-primary",onClick:e[26]||(e[26]=o=>Ve.value=!1)},"닫기")])])])):Q("",!0),(A(),wt($o,{to:"body"},[Pe.value?(A(),O("div",{key:0,class:"zone-context-menu",style:ct({position:"fixed",left:We.value.x+"px",top:We.value.y+"px",zIndex:9999}),onClick:e[31]||(e[31]=he(()=>{},["stop"]))},[l("div",{class:"zone-context-menu-item",onClick:e[29]||(e[29]=o=>t.editZone(Ze.value))},e[75]||(e[75]=[l("span",{class:"zone-context-menu-icon"},"✏️",-1),Oe(" 구역 수정 ",-1)])),l("div",{class:"zone-context-menu-item",onClick:e[30]||(e[30]=o=>Ho(Ze.value))},e[76]||(e[76]=[l("span",{class:"zone-context-menu-icon"},"🗑️",-1),Oe(" 구역 삭제 ",-1)]))],4)):Q("",!0)])),(A(),wt($o,{to:"body"},[Ye.value?(A(),O("div",{key:0,class:"context-menu",style:ct({position:"fixed",left:De.value.x+"px",top:De.value.y+"px",zIndex:9999}),onClick:e[33]||(e[33]=he(()=>{},["stop"]))},[l("div",{class:"context-menu-item",onClick:e[32]||(e[32]=o=>co(et.value))},e[77]||(e[77]=[l("span",{class:"context-menu-icon"},"🗑️",-1),Oe(" 타입 삭제 ",-1)]))],4)):Q("",!0)]))])}}}),$i=Rt(Ci,[["__scopeId","data-v-dbc5bf2d"]]);export{$i as default};
