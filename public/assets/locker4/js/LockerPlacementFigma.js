import{d as Xn,r as m,c as ie,w as gt,o as Pn,n as le,a as Fn,b as T,e as M,f as We,g as V,h as u,F as re,i as ue,j as se,k as Re,t as N,l as he,m as Ft,p as pt,q as fe,v as Co,s as Mo,u as Ze,x as Eo,y as Kt,T as ko,_ as Kn}from"./index.js";import{u as Hn,L as zn,Z as Bn,a as jn,i as Gn,g as Un}from"./LockerRegistrationModal.js";const Wn={class:"locker-placement"},Zn={key:0,class:"loading-overlay"},qn={key:1,class:"main-content"},Jn={class:"container"},Qn={class:"locker-sidebar"},es={key:0,class:"loading-state"},ts={key:1,class:"empty-state"},os={key:2,class:"locker-types"},ns=["onClick","onDblclick","onContextmenu"],ss={class:"type-visual"},as=["width","height","viewBox"],is=["width","height","fill"],ls=["y1","x2","y2","stroke"],rs={class:"type-info"},cs={class:"type-name"},ds={class:"type-size"},us=["onClick"],hs={key:3,class:"deleted-types-section"},fs=["onClick"],vs={class:"canvas-area"},gs={class:"zone-tabs"},ps={class:"zone-tab-group"},ms=["onClick","onContextmenu"],ys={key:0,class:"tab-indicator"},xs={class:"zone-controls"},ws={class:"mode-toggle-inline"},Ls={key:0,class:"zoom-controls"},bs={class:"canvas-wrapper"},Cs=["viewBox"],Ms=["width","height"],Es={key:1},ks=["x","y","font-size"],Ts=["x","y","font-size"],As={key:2,class:"unified-outlines"},Ds=["x","y","width","height"],$s={key:3},Ns=["transform"],_s={key:4,class:"alignment-guides"},Ss=["y1","x2","y2"],Rs=["x1","x2","y2"],Os=["x","y","width","height"],Ys={key:5,class:"modal-overlay"},Is={class:"form-group"},Vs={class:"modal-buttons"},Xs={key:6,class:"modal-overlay"},Ps={class:"form-group"},Fs={style:{display:"flex","justify-content":"space-between","align-items":"flex-start"}},Ks={class:"radio-group-horizontal",style:{flex:"1","margin-left":"20px"}},Hs={class:"radio-label"},zs={class:"radio-label"},Bs={class:"radio-label"},js={class:"form-section"},Gs={class:"form-options-row"},Us={class:"radio-group-horizontal"},Ws={class:"radio-label"},Zs={class:"radio-label"},qs={class:"form-section"},Js={style:{"margin-top":"10px"}},Qs={style:{"margin-bottom":"8px"}},ea={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},ta={style:{"font-size":"12px",color:"#666"}},oa={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},na={style:{"font-size":"12px",color:"#666"}},sa={key:0,class:"progress-section"},aa={class:"progress-indicator"},ia={class:"progress-text"},la={class:"modal-buttons"},ra=["disabled"],ca=["disabled"],da={key:0},ua={key:1},ha={class:"grouping-results"},fa={class:"modal-buttons"},va={class:"debug-section"},ga={class:"debug-stats"},pa={class:"stat-item"},ma={class:"value"},ya={class:"stat-item"},xa={class:"value"},wa={class:"stat-item"},La={class:"value"},ba={class:"stat-item"},Ca={class:"value"},Ma={class:"debug-section"},Ea={class:"locker-list"},ka={class:"locker-header"},Ta={class:"locker-name"},Aa={class:"locker-type"},Da={class:"locker-details"},$a={class:"debug-section"},Na={class:"locker-list"},_a={class:"locker-header"},Sa={class:"locker-name"},Ra={class:"locker-type"},Oa={class:"locker-details"},Ya={class:"modal-buttons"},To=1,Ao=1,Le=1250,qe=3100,mt=1435,ce=1350,ve=670,Do=5,$o=55,Ia=Xn({__name:"LockerPlacementFigma",setup(Va){const A=Hn(),O=m(null),Oe=m(null),L=m(null),No=m(!1),yt=m(null),Ye=m(!1),Ie=m(!1),P=m(!1),Je=m({x:0,y:0}),b=m("floor"),W=m(!0),xt=m(!1),Ht=m([]),_o=m({isSelecting:!1,startX:0,startY:0,endX:0,endY:0}),Ve=m(!1),wt=m(""),Lt=m(!1),Xe=m({x:0,y:0}),Qe=m(!1),bt=m({x:0,y:0}),Ct=m(null),et=m(!1),So=m({x:0,y:0}),zt=m(null),tt=m(!1),ge=m(1),Bt=m(null),jt=m(null),ot=m(!1),nt=m(!1),st=m(1),J=m("all"),ke=m("horizontal"),Te=m(!1),Ae=m(!1),be=m(!1),pe=m(""),me=()=>b.value==="floor"?To:Ao,Q=m(qe),ee=m(mt),Gt=m(1550),Ut=m(700),F=m(1),Wt=Math.max(ce/qe,ve/mt),Zt=Math.min(qe/ce,mt/ve),U=m({x:0,y:0}),Pe=m(!1),at=m({x:0,y:0}),it=()=>{if(xe.value||Fe.value)return;const t=document.querySelector(".canvas-wrapper");if(t){const e=t.getBoundingClientRect(),s=e.width,o=e.height;Gt.value=Math.max(s,ce),Ut.value=Math.max(o,ve)}},Ro=(t,e)=>{const s=me();return{x:t*s,y:e*s}},Oo=(t,e)=>{const s=me();return{width:t*s,height:e*s}},Ce=ie(()=>A.zones),ye=m([]);m(!1);const xe=m(!0),Fe=m(!0),qt=m(!1),Mt=m(null);m(null);const G=(()=>{if(Gn()){const t=Un();return t?`${t.baseUrl}/api`:"/api"}return"http://localhost:3333/api"})(),Et=async()=>{try{const t=await fetch(`${G}/zones`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.zones){const s=e.zones.map(o=>({id:o.LOCKR_KND_CD,name:o.LOCKR_KND_NM,x:o.X,y:o.Y,width:o.WIDTH,height:o.HEIGHT,color:o.COLOR,floor:o.FLOOR,...o}));A.zones=s}else console.warn("[API] No zones data in response:",e),A.zones=[]}catch(t){console.error("[API] Failed to load zones:",t.message),A.zones=[]}},de=async()=>{try{const e=b.value==="floor"?`${G}/lockrs?parentOnly=true`:`${G}/lockrs`,s=await fetch(e);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const o=await s.json();if(o.lockers&&o.lockers.forEach(n=>{const i=n.PARENT_LOCKR_CD===null?"PARENT":`CHILD of ${n.PARENT_LOCKR_CD}`}),o.success&&o.lockers){const n=o.lockers.map(a=>{const i=ye.value.find(v=>v.id===a.LOCKR_TYPE_CD),c=(i==null?void 0:i.width)||40,l=(i==null?void 0:i.height)||60,d=(i==null?void 0:i.depth)||40,r=a.PARENT_LOCKR_CD?`locker-${a.PARENT_LOCKR_CD}`:null;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X!==null&&a.X!==void 0?a.X:void 0,y:a.Y!==null&&a.Y!==void 0?a.Y:void 0,width:c,height:d,depth:d,actualHeight:l,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockerId:r,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});A.lockers=n,A.lockers.forEach(a=>{const c=!a.parentLockrCd?"PARENT":`CHILD of ${a.parentLockrCd}`}),n.forEach(a=>{a.number==="L3"||a.number==="L4"||a.number==="L1"||a.number==="L2"||a.number})}else if(o.lockers){const n=o.lockers.map(a=>{const i=ye.value.find(l=>l.id===a.LOCKR_TYPE_CD),c=(i==null?void 0:i.height)||60;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X||0,y:a.Y||0,width:(i==null?void 0:i.width)||40,height:(i==null?void 0:i.depth)||40,depth:(i==null?void 0:i.depth)||40,actualHeight:c,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});A.lockers=n}else console.warn("[API] No lockers data in response:",o),A.lockers=[]}catch(t){console.error("[API] Failed to load lockers:",t.message),A.lockers=[]}},Jt=async()=>{try{xe.value=!0;const t=await fetch(`${G}/types`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.success){const s=(e.types||[]).map(o=>({id:o.LOCKR_TYPE_CD,name:o.LOCKR_TYPE_NM,width:o.WIDTH,height:o.HEIGHT,depth:o.DEPTH,color:o.COLOR||"#3b82f6",type:o.LOCKR_TYPE_CD}));ye.value=s}}catch(t){console.error("Failed to load locker types:",t),ye.value=[]}finally{xe.value=!1,qt.value=!0}},Yo=async t=>{try{const e=await fetch(`${G}/zones`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save zone");const s=await e.json();if(s.success)return await Et(),s}catch(e){throw console.error("[API] Zone save failed:",e),Mt.value="Failed to save zone",e}},kt=async t=>{try{const e=await fetch(`${G}/lockrs`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save locker");const s=await e.json();if(s.success)return await de(),s}catch(e){throw console.error("[API] Locker save failed:",e),Mt.value="Failed to save locker",e}},Qt=async(t,e)=>{try{const s=await fetch(`${G}/lockrs/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!s.ok){const n=await s.text();throw new Error(`Failed to update locker placement: ${s.status} - ${n}`)}const o=await s.json();if(o.success)return o}catch(s){throw console.error("[API] Locker placement update failed:",s),Mt.value="Failed to update locker placement",s}},Io=async t=>{try{const e=await fetch(`${G}/lockrs/batch-numbers`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({updates:t})});if(!e.ok){const o=await e.text();throw new Error(`Failed to batch update locker numbers: ${e.status} - ${o}`)}const s=await e.json();if(s.success)return s;throw new Error(`Batch update failed: ${s.message||"Unknown error"}`)}catch(e){throw console.error("[API] Batch locker number update failed:",e),e}},Vo=async t=>{try{const e=t.map(s=>{var i;const o=g.value.find(c=>c.id===s.id),n=Math.round(s.x*100)/100,a=Math.round(s.y*100)/100;if(o&&o.lockrCd)return Qt(o.lockrCd,{X:n,Y:a});if(o){const c={LOCKR_KND:(i=O.value)==null?void 0:i.id,LOCKR_TYPE_CD:o.type||"1",X:n,Y:a,LOCKR_LABEL:o.number,ROTATION:o.rotation||0,LOCKR_STAT:"00"};return kt(c).then(l=>(l&&l.lockrCd&&(o.lockrCd=l.lockrCd),l))}});await Promise.all(e)}catch(e){console.error("[API] Failed to save some locker positions:",e)}},Ke=m([]),lt=t=>{if(t.length<=1)return null;const e=2,s=t.map(c=>{const l=b.value==="front"?c.actualHeight||c.height||60:c.depth||c.height||40,d=b.value==="front"&&c.frontViewX!==void 0?c.frontViewX:c.x,r=b.value==="front"&&c.frontViewY!==void 0?c.frontViewY:c.y;return{left:d,right:d+c.width*e,top:r,bottom:r+l*e,locker:c}}),o=Math.min(...s.map(c=>c.left)),n=Math.max(...s.map(c=>c.right)),a=Math.min(...s.map(c=>c.top)),i=Math.max(...s.map(c=>c.bottom));return{minX:o,maxX:n,minY:a,maxY:i,width:n-o,height:i-a}},Xo=(t,e,s=5)=>{const n=b.value==="front"?t.actualHeight||t.height||60:t.depth||t.height||40,a=b.value==="front"?e.actualHeight||e.height||60:e.depth||e.height||40,i=D=>b.value==="front"?{x:D.frontViewX!==void 0?D.frontViewX:D.x,y:D.frontViewY!==void 0?D.frontViewY:D.y}:{x:D.x,y:D.y},c=i(t),l=i(e),d={left:c.x,right:c.x+t.width*2,top:c.y,bottom:c.y+n*2},r={left:l.x,right:l.x+e.width*2,top:l.y,bottom:l.y+a*2},f=s,v=Math.min(Math.abs(d.right-r.left),Math.abs(r.right-d.left)),h=Math.min(Math.abs(d.bottom-r.top),Math.abs(r.bottom-d.top))<=f,w=d.left<r.right&&r.left<d.right,$=v<=f,p=d.top<r.bottom&&r.top<d.bottom;return h&&w||$&&p},Po=t=>{const e=[],s=new Set,o=(n,a)=>{s.has(n.id)||(s.add(n.id),a.push(n),t.forEach(i=>{!s.has(i.id)&&Xo(n,i)&&o(i,a)}))};return t.forEach(n=>{if(!s.has(n.id)){const a=[];o(n,a),e.push(a)}}),e},Fo=t=>{if(!x.value.has(t))return[];const e=g.value.find(d=>d.id===t);if(!e)return[];const s=[],o=10,n=ae(e),a=(e.rotation||0)%360,i={0:{top:"top",right:"right",bottom:"bottom",left:"left"},90:{top:"left",right:"top",bottom:"right",left:"bottom"},180:{top:"bottom",right:"left",bottom:"top",left:"right"},270:{top:"right",right:"bottom",bottom:"left",left:"top"}},c=Math.round(a/90)*90%360,l=i[c]||i[0];return eo.value.forEach(d=>{if(d.id===t)return;const r=ae(d);P.value&&console.log(`[Adjacent Check] ${t} vs ${d.id}:`,{locker:{id:t,rotation:a,bounds:n},other:{id:d.id,rotation:d.rotation,bounds:r},mapping:l}),Math.abs(n.y-(r.y+r.height))<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&(s.push(l.top),P.value&&console.log("  -> TOP adjacent (physical top touches other's bottom)")),Math.abs(n.y+n.height-r.y)<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&s.push(l.bottom),Math.abs(n.x-(r.x+r.width))<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.left),Math.abs(n.x+n.width-r.x)<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.right)}),[...new Set(s)]},Tt=ie(()=>ye.value.filter(t=>!Ke.value.includes(t.id))),g=ie(()=>{if(!O.value)return[];let t=A.lockers.filter(e=>e.zoneId===O.value.id);return b.value==="floor"&&(t=t.filter(e=>!e.parentLockrCd)),t.forEach(e=>{!e.parentLockrCd||`${e.parentLockrCd}`}),t}),Ko=ie(()=>g.value.map((e,s)=>{let o,n,a;const i=e.actualHeight||e.height||60;if(b.value==="floor"){const l=Ro(e.x,e.y);o=l.x,n=l.y,a=Oo(e.width,e.height||e.depth||40).height}else{const l=me();if(e.frontViewX!==void 0&&e.frontViewX!==null&&e.frontViewY!==void 0&&e.frontViewY!==null)o=e.frontViewX*l,n=e.frontViewY*l,a=i*l;else if(e.x!==void 0&&e.x!==null&&e.y!==void 0&&e.y!==null){const d=400+s*80,r=200;o=d,n=r,a=i*l}else o=100+s*100,n=100,a=i*l}const c=e.width*me();return{...e,displayX:o,displayY:n,displayWidth:c,displayHeight:a,actualHeight:e.actualHeight||i||60,logicalX:e.x,logicalY:e.y,logicalWidth:e.width,logicalHeight:e.height||e.depth||40}})),Ho=ie(()=>{const t=Ko.value.map(e=>{if(b.value==="front"){const s=e.actualHeight||e.height||60,o=e.displayX/me(),n=e.displayY/me(),a=e.frontViewRotation!==void 0?e.frontViewRotation:0;return e.x===o&&e.y===n&&e.height===s&&e.rotation===a?e:{...e,x:o,y:n,height:s,actualHeight:s,rotation:a}}return e});if(b.value==="front")return t;if(L.value){const e=t.findIndex(s=>s.id===L.value.id);if(e>-1){const[s]=t.splice(e,1);t.push(s)}}return t}),eo=ie(()=>g.value.filter(t=>x.value.has(t.id))),rt=ie(()=>Po(eo.value)),zo=ie(()=>{const t=new Set;return rt.value.forEach(e=>{e.length>1&&e.forEach(s=>t.add(s.id))}),t});m(!1),m([]);const to=()=>{if(!L.value)return{x:0,y:0};const t=g.value.find(e=>e.id===L.value.id);return t?b.value==="front"?{x:t.frontViewX!==void 0?t.frontViewX:t.x,y:t.frontViewY!==void 0?t.frontViewY:t.y}:{x:t.x,y:t.y}:{x:L.value.x,y:L.value.y}},te=t=>{if(!t)return{width:0,height:0};const e=2;return b.value==="floor"?{width:(t.width||40)*e,height:(t.depth||t.height||40)*e}:{width:(t.width||40)*e,height:(t.actualHeight||t.height||60)*e}},He=m(!1),ct=m(!1),Me=m([]),x=m(new Set),At=m(null),we=m(!1),X=m({x:0,y:0}),H=m({x:0,y:0}),oe=m([]),Dt=m(!1),dt=m(!1);m([]);const ze=m(!1),oo=m([]),no=m([]),Be=async t=>{O.value=t,L.value=null,b.value==="front"&&(console.log("[Zone Change] Loading lockers for zone in front view mode..."),await de(),le(()=>{g.value.some(s=>s.frontViewX==null||s.frontViewY==null)?(console.log("[Zone Change] Found lockers without front view coordinates, recalculating..."),_e()):console.log("[Zone Change] All lockers have front view coordinates")})),setTimeout(()=>{De()},100)},Bo=(t,e)=>{t.preventDefault(),t.stopPropagation(),Ct.value=e,bt.value={x:t.clientX,y:t.clientY},Qe.value=!0;const s=()=>{Qe.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},jo=async t=>{var e;try{const s=g.value.filter(c=>c.LOCKR_KND===t.id||c.zoneId===t.id||c.LOCKR_KND===t.LOCKR_KND_CD);if(s.length>0){alert(`구역 삭제 불가

이 구역에 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`구역 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=t.LOCKR_KND_CD||t.id,n=`${G}/zones/${o}`,a=await fetch(n,{method:"DELETE"});if(!a.ok){const c=await a.json();throw new Error(c.message||"Failed to delete zone")}(await a.json()).success&&(await Et(),((e=O.value)==null?void 0:e.id)===t.id&&(Ce.value.length>0?Be(Ce.value[0]):O.value=null),alert("구역이 성공적으로 삭제되었습니다."))}catch(s){console.error("[API] Zone deletion failed:",s),alert(`구역 삭제 중 오류가 발생했습니다:
${s.message}`)}finally{Qe.value=!1}},Go=(t,e)=>{t.preventDefault(),zt.value=e,So.value={x:t.clientX,y:t.clientY},et.value=!0;const s=()=>{et.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},so=async t=>{var e;try{const s=g.value.filter(a=>a.LOCKR_TYPE_CD===t.id||a.type===t.id);if(s.length>0){alert(`타입 삭제 불가

이 타입으로 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`락커 타입 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=await fetch(`${G}/types/${t.id}`,{method:"DELETE"});if(!o.ok){const a=await o.json();throw new Error(a.message||"Failed to delete locker type")}(await o.json()).success&&(await Jt(),((e=Oe.value)==null?void 0:e.id)===t.id&&(Oe.value=null),et.value=!1)}catch(s){console.error("Failed to delete locker type:",s),alert("락커 타입 삭제에 실패했습니다.")}},Uo=t=>{Oe.value=t},Wo=(t,e,s,o)=>{let n=t,a=e;n=Math.round(n/20)*20,a=Math.round(a/20)*20;let i=0;const c=50;for(;i<c;){if(!Ot(n,a,s,o,null,0,!1))return{x:n,y:a};n+=20,n>Q.value-s-100&&(n=t,a+=20,a>ee.value-o-100&&(a=100,t+=20,n=t)),i++}return console.warn("[Direct Add] Could not find collision-free position, using default"),{x:t,y:e}},Zo=async t=>{if(b.value!=="floor"){alert("평면배치모드에서만 락커를 추가할 수 있습니다.");return}if(!O.value){alert("구역을 선택해주세요.");return}Oe.value=t;const e=100,s=Math.round(ee.value/3),o=Wo(e,s,t.width,t.depth||t.width),n=wo(o.x,o.y,t.width,t.depth||t.width),a={id:`locker-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,name:t.name,x:n.x,y:n.y,width:t.width,height:t.depth||t.width,depth:t.depth||t.width,actualHeight:t.height,color:t.color,rotation:0,type:t.name,status:"available",number:Rt(),zoneId:O.value.id};let i=null;try{const l={LOCKR_KND:O.value.id,LOCKR_TYPE_CD:t.id||t.type,X:a.x,Y:a.y,LOCKR_LABEL:a.number,ROTATION:a.rotation||0,LOCKR_STAT:"00"},d=await kt(l);d&&d.lockrCd&&(await de(),De(),i=g.value.find(r=>r.x===a.x&&r.y===a.y&&r.number===a.number))}catch(l){console.error("[Database] Failed to save locker:",l),i=A.addLocker(a)}i&&(L.value=i,x.value.clear(),x.value.add(i.id),W.value=!0),Rn();const c=window.event;if(c&&c.currentTarget){const l=c.currentTarget;l.classList.add("pulse-animation"),setTimeout(()=>l.classList.remove("pulse-animation"),300)}},qo=t=>{const e=Ke.value.indexOf(t);e>-1&&Ke.value.splice(e,1)},Jo=t=>{const e=ye.value.find(s=>s.type===t);return e?e.name:t},je=t=>{const e=yt.value;if(!e)return{x:0,y:0};const s=e.createSVGPoint();s.x=t.clientX,s.y=t.clientY;const o=s.matrixTransform(e.getScreenCTM().inverse());return me(),{x:Math.round(o.x*100)/100,y:Math.round(o.y*100)/100}},Qo=t=>{if(b.value!=="floor"&&b.value!=="front"||!t.ctrlKey)return;t.preventDefault();const s=t.currentTarget.getBoundingClientRect(),o=(t.clientX-s.left)/s.width,n=(t.clientY-s.top)/s.height,a=ce/F.value,i=ve/F.value,c=U.value.x+o*a,l=U.value.y+n*i,d=t.deltaY>0?.9:1.1,r=Math.min(Math.max(F.value*d,Wt),Zt);if(r!==F.value){const f=ce/r,v=ve/r,y={x:c-o*f,y:l-n*v};U.value=$t(y,r),F.value=r}},$t=(t,e)=>{const s=ce/e,o=ve/e,n=0,a=0,i=Math.max(0,qe-s),c=Math.max(0,mt-o);return{x:Math.max(n,Math.min(i,t.x)),y:Math.max(a,Math.min(c,t.y))}},De=()=>{if(console.log("[AutoFit] Starting autoFitLockers...",{lockersCount:g.value.length,viewMode:b.value}),g.value.length===0){console.log("[AutoFit] No lockers found, using default zoom"),F.value=1,U.value={x:0,y:0};return}let t=1/0,e=1/0,s=-1/0,o=-1/0;const n=2;if(g.value.forEach(h=>{if(h.parentLockerId)return;let w,$,p,k;if(b.value==="floor")w=h.x,$=h.y,p=h.x+(h.width||40)*n,k=h.y+(h.depth||h.height||40)*n;else if(b.value==="front")w=h.frontViewX!==void 0?h.frontViewX:h.x,$=h.frontViewY!==void 0?h.frontViewY:h.y,p=w+(h.width||40)*n,k=$+(h.actualHeight||h.height||60)*n;else return;t=Math.min(t,w),e=Math.min(e,$),s=Math.max(s,p),o=Math.max(o,k)}),t===1/0||e===1/0){F.value=1,U.value={x:0,y:0};return}const a=s-t,i=o-e,c=.3,l=a*(1+c),d=i*(1+c),r=ce/l,f=ve/d;let v=Math.min(r,f);v=v*.729,v=Math.max(Wt,Math.min(v,Zt));let y;if(b.value==="front"){const h=ve/v,w=ce/v;y={x:(t+s)/2-w/2,y:o-h}}else{const h=(t+s)/2,w=(e+o)/2,$=ce/(2*v),p=ve/(2*v);y={x:h-$,y:w-p}}F.value=v,U.value=$t(y,v),console.log("[AutoFit]",b.value,"mode - Zoom:",v,"Pan:",U.value,"Bounds:",{minX:t,minY:e,maxX:s,maxY:o})},en=t=>{if((b.value==="floor"||b.value==="front")&&t.button===1){t.preventDefault(),Pe.value=!0,at.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y,n=t.target;!(n.closest("[data-locker-id]")||n.tagName==="rect"&&!n.classList.contains("canvas-background")||n.tagName==="text"||n.tagName==="g"&&n.querySelector("text"))&&(n.tagName==="svg"||n.classList.contains("canvas-background")||n.getAttribute("fill")==="url(#grid)"||n.classList.contains("selection-box"))&&!P.value&&(we.value=!0,X.value={x:s,y:o},H.value={x:s,y:o},x.value.clear(),L.value=null,t.preventDefault(),t.stopPropagation())},tn=t=>{if((b.value==="floor"||b.value==="front")&&Pe.value){const n=(t.clientX-at.value.x)/F.value,a=(t.clientY-at.value.y)/F.value,i={x:U.value.x-n,y:U.value.y-a};U.value=$t(i,F.value),at.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y;we.value?(H.value={x:s,y:o},Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Do&&io()):P.value&&dn(t)},ao=t=>{if((b.value==="floor"||b.value==="front")&&Pe.value){Pe.value=!1;return}if(!(He.value||ct.value)){if(we.value){const e=je(t),s=e.x,o=e.y;Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Do?(io(),Dt.value=!0,x.value.size>0&&(W.value=!0),setTimeout(()=>{Dt.value=!1},100)):He.value||(x.value.clear(),L.value=null),we.value=!1,X.value={x:0,y:0},H.value={x:0,y:0}}P.value&&un()}},io=()=>{if(!X.value||!H.value||X.value.x==null||X.value.y==null||H.value.x==null||H.value.y==null){console.warn("[Rectangle Select] Invalid coordinates, skipping selection update");return}const t=Math.min(X.value.x,H.value.x),e=Math.max(X.value.x,H.value.x),s=Math.min(X.value.y,H.value.y),o=Math.max(X.value.y,H.value.y);if(x.value.clear(),g.value.forEach(n=>{let a,i,c,l;if(b.value==="front"){const r=n.frontViewX!==void 0?n.frontViewX:n.x,f=n.frontViewY!==void 0?n.frontViewY:n.y,v=te(n);a=r,i=r+v.width,c=f,l=f+v.height}else{const r=te(n);a=n.x,i=n.x+r.width,c=n.y,l=n.y+r.height}!(i<t||a>e||l<s||c>o)&&x.value.add(n.id)}),x.value.size>0){const n=Array.from(x.value)[0];L.value=g.value.find(a=>a.id===n),W.value=!0}else L.value=null},on=t=>{if(Dt.value||dt.value||ct.value)return;const e=t.target,s=e.tagName==="svg"||e.classList.contains("canvas-background")||e.tagName==="rect"&&e.getAttribute("fill")==="url(#grid)"||e.classList.contains("canvas");if(s&&!t.ctrlKey&&!t.shiftKey&&!t.metaKey){L.value=null,x.value.clear(),A.selectLocker(null),W.value=!1;return}if(s&&(t.shiftKey||t.ctrlKey)){const o=yt.value.getBoundingClientRect();_o.value={isSelecting:!0,startX:t.clientX-o.left,startY:t.clientY-o.top,endX:t.clientX-o.left,endY:t.clientY-o.top},console.log("[Selection] Drag selection started");return}},nn=(t,e)=>{var s;if(console.log("[Selection] Attempting to select in mode:",b.value,"Locker:",t.id),dt.value){console.log("[Select] Ignored - drag just finished");return}if(we.value){console.log("[Select] Ignored - drag selection in progress");return}if(!P.value){if(e&&(e.ctrlKey||e.metaKey)){if(x.value.has(t.id)){if(x.value.delete(t.id),((s=L.value)==null?void 0:s.id)===t.id){const o=Array.from(x.value);L.value=o.length>0?g.value.find(n=>n.id===o[0]):null}}else x.value.add(t.id),L.value=t;W.value=!0,console.log(`[Selection] Toggle select ${t.id}, total: ${x.value.size}`)}else e&&e.shiftKey&&At.value?(sn(At.value,t),W.value=!0):(x.value.clear(),x.value.add(t.id),L.value=t,console.log("[Selection UI] Rotation applied:",{lockerRotation:t.rotation||0,buttonPositions:{left:{x:t.width/2-15,y:-30},right:{x:t.width/2+15,y:-30},delete:{x:t.width+15,y:-15}},rotationCenter:{x:t.width/2,y:t.height/2}}));At.value=t,A.selectLocker(t.id),W.value=!0,console.log("[Select] Selection updated - Count:",x.value.size,"IDs:",Array.from(x.value),"ShowUI:",W.value)}},sn=(t,e)=>{const s=g.value.findIndex(i=>i.id===t.id),o=g.value.findIndex(i=>i.id===e.id);if(s===-1||o===-1)return;const n=Math.min(s,o),a=Math.max(s,o);x.value.clear();for(let i=n;i<=a;i++)x.value.add(g.value[i].id);L.value=e,console.log(`[Selection] Range select from ${t.id} to ${e.id}, total: ${x.value.size}`)},an=(t,e)=>{if(b.value==="front")return;if(!t||we.value){console.log("[Drag] Ignored - drag selection in progress");return}P.value=!0,W.value=!1;const s=e.ctrlKey||e.metaKey;console.log("[Multi-Select] Copying with drag:",s),console.log("[Drag] Started - hiding selection UI");let o=t;if(s){const l=new Map;if(Array.from(x.value).forEach(d=>{const r=g.value.find(f=>f.id===d);if(r){const f={...r,id:`locker-${Date.now()}-${Math.random()}`,number:"",x:r.x+20,y:r.y+20},v=A.addLocker(f);A.updateLocker(v.id,{lockrNo:Rt()}),l.set(r.id,v.id)}}),l.size>0){if(l.has(t.id)){const d=l.get(t.id);o=g.value.find(r=>r.id===d)}x.value.clear(),l.forEach(d=>{x.value.add(d)}),L.value=o,console.log("[Multi-Select] Created copies:",l.size,"New leader:",o.id)}}!s&&!x.value.has(t.id)&&(x.value.clear(),x.value.add(t.id),L.value=t),P.value=!0;const n=je(e);oe.value=Array.from(x.value).map(l=>{const d=g.value.find($=>$.id===l),r=Math.round(d.x*100)/100,f=Math.round(d.y*100)/100,v=Math.round(o.x*100)/100,y=Math.round(o.y*100)/100,h=r-v,w=f-y;return{id:d.id,initialX:r,initialY:f,relativeX:h,relativeY:w,isLeader:d.id===o.id}});const a=Math.round(o.x*100)/100,i=Math.round(o.y*100)/100;Je.value={x:n.x-a,y:n.y-i};const c=x.value.size;c>1?console.log("[Group Drag] Started with",c,"lockers, leader:",o.id):console.log("[Drag] Start dragging locker:",t.id),e.preventDefault()},$e=m(null),ln=(t,e)=>{if(t){if(x.value.has(t.id)||(L.value=t,x.value.add(t.id)),He.value=!0,x.value.size>1){const s=Array.from(x.value),o=g.value.filter(l=>s.includes(l.id)),n={minX:Math.min(...o.map(l=>l.x)),maxX:Math.max(...o.map(l=>l.x+l.width)),minY:Math.min(...o.map(l=>l.y)),maxY:Math.max(...o.map(l=>l.y+(l.height||l.depth||40)))},a=(n.minX+n.maxX)/2,i=(n.minY+n.maxY)/2,c=new Map;o.forEach(l=>{const d=te(l),r=l.x+d.width/2,f=l.y+d.height/2;c.set(l.id,{relativeX:r-a,relativeY:f-i,width:d.width,height:d.height,initialRotation:l.rotation||0})}),$e.value={centerX:a,centerY:i,lockerStates:c,leaderId:t.id}}else $e.value=null;P.value=!1}},rn=(t,e)=>{if(x.value.size>1&&$e.value){const s=$e.value,o=g.value.find(r=>r.id===t);if(!o||!s)return;o._lastRotation===void 0&&(o._lastRotation=o.rotation||0,console.log("=== ROTATION INIT ==="),console.log("  Initial rotation set to:",o._lastRotation));let n=e-o._lastRotation;for(console.log("=== ROTATION DEBUG ==="),console.log("  newRotation:",e),console.log("  lastRotation:",o._lastRotation),console.log("  raw delta:",n);n>180;)n-=360,console.log("  → Adjusted delta (>180):",n);for(;n<-180;)n+=360,console.log("  → Adjusted delta (<-180):",n);const a=o._rotationDirection||0,i=Math.sign(n);a!==0&&i!==0&&a!==i&&console.log("  Direction change detected! prev:",a,"current:",i),o._rotationDirection=i,o._lastRotation=e,console.log("  Final delta:",n);const c=s.centerX,l=s.centerY;Array.from(x.value).forEach(r=>{const f=g.value.find(D=>D.id===r);if(!f)return;const v=s.lockerStates.get(r);if(!v)return;const y=e-(s.lockerStates.get(s.leaderId).initialRotation||0),h=y*Math.PI/180,w=Math.cos(h),$=Math.sin(h),p=v.relativeX*w-v.relativeY*$+c,k=v.relativeX*$+v.relativeY*w+l;f.x=p-v.width/2,f.y=k-v.height/2,f.id===s.leaderId?(f.rotation=e,console.log(`[ROTATION DIRECTION] Leader locker ${f.id} rotation: ${f.rotation}`)):(f.rotation=v.initialRotation+y,console.log(`[ROTATION DIRECTION] Follower locker ${f.id} rotation: ${f.rotation}`)),lo(f.id,f.rotation)})}else{const s=g.value.find(o=>o.id===t);s&&(s.rotation=e,console.log(`[ROTATION DIRECTION] Single locker ${s.id} rotation: ${s.rotation}`),lo(t,s.rotation))}},cn=t=>{if(x.value.size>1)Array.from(x.value).forEach(n=>{const a=g.value.find(i=>i.id===n);if(a){const i=Math.round(a.rotation/45)*45;a.rotation=i,console.log(`[ROTATION END] Snapped locker ${n} from ${a.rotation} to ${i}`)}});else{const o=g.value.find(n=>n.id===t);if(o){const n=o.rotation,a=Math.round(n/45)*45;o.rotation=a,console.log(`[ROTATION END] Snapped locker ${t} from ${n} to ${a}`)}}ct.value=!0,He.value=!1,setTimeout(()=>{ct.value=!1},200);const s=g.value.find(o=>o.id===t);if(s&&(delete s._lastRotation,delete s._lastRawRotation,delete s._rotationDirection),$e.value&&($e.value=null),x.value.size>1){const o=Array.from(x.value);g.value.filter(a=>o.includes(a.id)).forEach(a=>{Nt(a.id,a.rotation)})}else{const o=g.value.find(n=>n.id===t);o&&Nt(t,o.rotation)}},lo=(()=>{let t=null;return(e,s)=>{clearTimeout(t),t=setTimeout(()=>{Nt(e,s)},200)}})(),Nt=async(t,e)=>{try{if(A.getLockerById(t)){let o=e%360;o>180?o-=360:o<-180&&(o+=360);const n=He.value;await A.updateLocker(t,{rotation:o},n)}}catch(s){console.error("[Rotation] Failed to save rotation:",s)}},dn=t=>{if(!P.value||oe.value.length===0)return;const e=je(t),s=oe.value.find(C=>C.isLeader);if(!s)return;const o=g.value.find(C=>C.id===s.id);if(!o)return;const n=e.x-Je.value.x,a=e.y-Je.value.y,i=te(o),c=ht(n),l=ht(a),d=wo(c,l,i.width,i.height,s.id,o.rotation||0),r=d.x!==c||d.y!==l;r&&console.log("[SNAP DEBUG] Position was snapped from",{x:c,y:l},"to",d);const f=d.x-s.initialX,v=d.y-s.initialY,y=[];let h=!1,w=1/0,$=1/0,p=-1/0,k=-1/0;oe.value.forEach(C=>{const E=g.value.find(S=>S.id===C.id);if(E){const S=te(E);let I,R;C.isLeader?(I=d.x,R=d.y):(I=d.x+C.relativeX,R=d.y+C.relativeY),w=Math.min(w,I),$=Math.min($,R),p=Math.max(p,I+S.width),k=Math.max(k,R+S.height)}});let D=0,Y=0;w<0?D=-w:p>Q.value&&(D=Q.value-p),$<0?Y=-$:k>ee.value&&(Y=ee.value-k);const _=d.x+D,Z=d.y+Y;if(oe.value.forEach(C=>{const E=g.value.find(S=>S.id===C.id);if(E){const S=te(E);let I,R;C.isLeader?(I=_,R=Z):(I=_+C.relativeX,R=Z+C.relativeY),Ot(I,R,S.width,S.height,E.id,E.rotation||0,r)&&(h=!0),y.push({id:E.id,x:I,y:R,dims:S})}}),!h)y.forEach(C=>{var I;const E=Math.round(C.x*100)/100,S=Math.round(C.y*100)/100;A.updateLocker(C.id,{x:E,y:S},!0),((I=L.value)==null?void 0:I.id)===C.id&&(L.value={...L.value,x:E,y:S})}),console.log("[Group Drag] Moving",x.value.size,"lockers. Leader:",s.id,"Delta:",{x:f.toFixed(1),y:v.toFixed(1)});else if(r&&h){console.log("[SNAP WARNING] Collision detected at snapped position, checking overlap amount...");let C=0;oe.value.forEach(E=>{const S=g.value.find(I=>I.id===E.id);if(S){const I=te(S);let R,z;E.isLeader?(R=d.x,z=d.y):(R=d.x+E.relativeX,z=d.y+E.relativeY);const B=ae({x:R,y:z,width:I.width,height:I.height,rotation:S.rotation||0});g.value.forEach(j=>{if(j.id!==S.id&&!x.value.has(j.id)){const K=ae(j),ne=Math.min(B.x+B.width,K.x+K.width)-Math.max(B.x,K.x),q=Math.min(B.y+B.height,K.y+K.height)-Math.max(B.y,K.y);ne>0&&q>0&&(C=Math.max(C,Math.min(ne,q)),console.log("[SNAP OVERLAP] With",j.id,"- X:",ne.toFixed(1),"Y:",q.toFixed(1)))}})}}),C<1?(console.log("[SNAP] Accepting snapped position with micro-overlap:",C.toFixed(2),"px"),y.forEach(E=>{var S;A.updateLocker(E.id,{x:E.x,y:E.y},!0),((S=L.value)==null?void 0:S.id)===E.id&&(L.value={...L.value,x:E.x,y:E.y})})):console.warn("[SNAP] Rejecting snapped position due to significant overlap:",C.toFixed(1),"px")}else{console.log("[COLLISION ADJUSTMENT DEBUG] Collision detected (non-snapped), finding valid position:",{snappedLeader:d,proposedPositions:y.length,hasCollision:h,wasSnapped:r});let C=d.x,E=d.y,S=!1;const I=[{dx:-20,dy:0},{dx:20,dy:0},{dx:0,dy:-20},{dx:0,dy:20},{dx:-20,dy:-20},{dx:20,dy:-20},{dx:-20,dy:20},{dx:20,dy:20}];for(const R of I){const z=d.x+R.dx,B=d.y+R.dy;let j=!1;if(oe.value.forEach(K=>{const ne=g.value.find(q=>q.id===K.id);if(ne&&!j){const q=te(ne);let Ee,Ue;K.isLeader?(Ee=z,Ue=B):(Ee=z+K.relativeX,Ue=B+K.relativeY);const In=Q.value-q.width,Vn=ee.value-q.height;Ee=Math.max(0,Math.min(Ee,In)),Ue=Math.max(0,Math.min(Ue,Vn)),Ot(Ee,Ue,q.width,q.height,ne.id,ne.rotation||0,!1)&&(j=!0)}}),!j){C=z,E=B,S=!0;break}}S?(oe.value.forEach(R=>{var B;const z=g.value.find(j=>j.id===R.id);if(z){let j,K;R.isLeader?(j=C,K=E):(j=C+R.relativeX,K=E+R.relativeY);const ne=te(z),q=Q.value-ne.width,Ee=ee.value-ne.height;j=Math.max(0,Math.min(j,q)),K=Math.max(0,Math.min(K,Ee)),A.updateLocker(z.id,{x:j,y:K},!0),((B=L.value)==null?void 0:B.id)===z.id&&(L.value={...L.value,x:j,y:K})}}),console.log("[COLLISION] Adjusted to valid position:",`(${C}, ${E})`)):console.warn("[COLLISION] No collision-free adjustment found, keeping original positions")}},un=()=>{if(P.value){if(dt.value=!0,console.log("[Drag] Setting lockerDragJustFinished flag to true"),setTimeout(()=>{dt.value=!1,console.log("[Drag] Cleared lockerDragJustFinished flag")},150),oe.value.length>0){const t=oe.value.map(e=>{const s=g.value.find(o=>o.id===e.id);return{id:e.id,x:(s==null?void 0:s.x)||e.x,y:(s==null?void 0:s.y)||e.y}});Vo(t)}P.value=!1,W.value=!0,Je.value={x:0,y:0},oe.value=[],ze.value=!1,oo.value=[],no.value=[],console.log("[Drag] End dragging - Current selection count:",x.value.size)}},hn=()=>{const t=[],e=new Set,s=g.value.filter(o=>!o.parentLockerId);for(let o=0;o<s.length;o++){const n=s[o],a=n.rotation||0;let i=null;if(a===0||a===360?i={minX:n.x,maxX:n.x+n.width,minY:n.y+(n.depth||n.height),maxY:n.y+(n.depth||n.height)+50}:a===90?i={minX:n.x+n.width,maxX:n.x+n.width+50,minY:n.y,maxY:n.y+(n.depth||n.height)}:a===180?i={minX:n.x,maxX:n.x+n.width,minY:n.y-50,maxY:n.y}:a===270&&(i={minX:n.x-50,maxX:n.x,minY:n.y,maxY:n.y+(n.depth||n.height)}),i)for(let c=0;c<s.length;c++){if(o===c)continue;const l=s[c];if(n.zoneId!==l.zoneId)continue;const d=l.depth||l.height,r=!(l.x+l.width<=i.minX||l.x>=i.maxX),f=!(l.y+d<=i.minY||l.y>=i.maxY);r&&f&&(e.add(n.id),e.add(l.id),t.push(`락커 ${n.number}의 문 앞이 락커 ${l.number}에 의해 막혀있습니다.`))}}t.length>0?console.log("[Door Blockage Check]:",{blocked:!0,errors:t,problematicLockers:Array.from(e)}):console.log("[Door Blockage Check]: All locker doors are accessible"),t.length>0&&(t.length=0,t.push("세로배치 모드 불가: 락커의 문 앞이 다른 락커에 의해 막혀있습니다."));for(let o=0;o<g.value.length;o++){const n=g.value[o];for(let a=o+1;a<g.value.length;a++){const i=g.value[a],c=Math.abs(n.x+n.width-i.x)<5||Math.abs(i.x+i.width-n.x)<5,l=Math.abs(n.y+(n.depth||n.height)-i.y)<5||Math.abs(i.y+(i.depth||i.height)-n.y)<5;if(c||l){if(c){const d=n.rotation%180===0,r=i.rotation%180===180;(n.x<i.x&&d&&r||i.x<n.x&&r&&d)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}if(l){const d=n.rotation%180===90,r=n.rotation%180===270,f=i.rotation%180===90,v=i.rotation%180===270;(n.y<i.y&&d&&v||i.y<n.y&&f&&r)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}}}}return console.log("[Placement Validation]:",{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}),{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}},fn=t=>{g.value.forEach(e=>{e.hasError=!1}),t.forEach(e=>{const s=g.value.find(o=>o.id===e);s&&(s.hasError=!0)})},_t=m(!1),ro=t=>{console.log("[setViewMode] Switching to:",t),t==="floor"&&b.value==="front"&&(_t.value=!0,setTimeout(()=>{_t.value=!1},400)),b.value=t,t==="front"&&setTimeout(()=>{De()},50),t==="floor"&&setTimeout(()=>{De()},50),co(),console.log("[ViewMode] Switching to:",t,{previousScale:t==="floor"?Ao:To,newScale:me(),viewMode:b.value}),le(()=>{it()})},co=()=>{if(b.value==="front"){const e=hn();if(e.isValid)console.log("[Validation PASSED] Front view validation successful");else{console.error("[Validation FAILED] Cannot switch to front view:",e.errors),console.error("[Validation FAILED] Problematic lockers:",e.problematicLockers),alert(`세로모드 진입 불가: 락커 배치가 규칙에 맞지 않습니다.
문제: `+e.errors.join(`
`)),fn(e.problematicLockers),b.value="floor";return}g.value.forEach(s=>s.hasError=!1)}console.log("[View Mode] Configuration:",{mode:b.value,floorY:Le,dimensions:b.value==="floor"?"width×depth":"width×height",interactions:b.value==="floor"?"enabled":"disabled"}),No.value=b.value==="front",b.value==="front"?(L.value=null,x.value.clear(),P.value=!1,W.value=!1):(W.value=!0,console.log("[Floor View] Interactions enabled, full editing mode"));const t=b.value==="floor"?"flat":"vertical";A.setPlacementMode(t)},uo=()=>{const t=g.value;if(t.length===0)return;const e={minX:Math.min(...t.map(r=>r.x)),maxX:Math.max(...t.map(r=>r.x+r.width)),minY:Math.min(...t.map(r=>r.y)),maxY:Math.max(...t.map(r=>r.y+(r.depth||r.height)))},s=[],o=[],n=[],a=[],i=[];t.forEach(r=>{const f=Math.abs(r.y-e.minY)<30,v=Math.abs(r.y+(r.depth||r.height)-e.maxY)<30,y=Math.abs(r.x-e.minX)<30,h=Math.abs(r.x+r.width-e.maxX)<30;f&&!y&&!h?s.push(r):v&&!y&&!h?n.push(r):h&&!f&&!v?o.push(r):y&&!f&&!v?a.push(r):f&&h||v&&h?o.push(r):f&&y?s.push(r):v&&y?n.push(r):i.push(r)}),s.sort((r,f)=>r.x-f.x),o.sort((r,f)=>r.y-f.y),n.sort((r,f)=>f.x-r.x),a.sort((r,f)=>f.y-r.y);let c=[];s.length>0&&o.length>0&&n.length>0?(console.log("[U-Shape] Detected ㄷ pattern"),c=[...s,...o,...n],console.log("[U-Shape] Walking order:",{top:s.map(r=>`L${r.number}`).join("→"),right:o.map(r=>`L${r.number}`).join("→"),bottom:n.map(r=>`L${r.number}`).join("→"),total:c.map(r=>`L${r.number}`).join("→")})):a.length>0&&o.length>0?(console.log("[Back-to-Back] Detected two columns"),a.sort((r,f)=>r.y-f.y),o.sort((r,f)=>f.y-r.y),c=[...a,...o]):(console.log("[Simple Row] Single line of lockers"),c=[...t].sort((r,f)=>r.x-f.x)),a.length>0&&c.indexOf(a[0])===-1&&(console.log("[Left Column] Adding left side lockers"),c.push(...a)),i.length>0&&(console.log("[Middle] Adding uncategorized lockers:",i.length),c.push(...i));const l=t.length,d=c.length;if(l!==d){console.error("[Transform] Locker count mismatch!",{original:l,unfolded:d});const r=new Set(c.map(v=>v.id)),f=t.filter(v=>!r.has(v.id));console.log("[Missing] Lockers not included:",f.map(v=>`L${v.number}`)),c.push(...f)}Ht.value=c,console.log("[Front View] Transformation complete:",{totalLockers:c.length,sequence:c.map(r=>r.number||r.id).join(" -> ")})},Ge=t=>{let e=t%360;return e<0&&(e+=360),e},ho=t=>bo(t),ut=t=>t.reduce((e,s)=>s.y<e.y||s.y===e.y&&s.x<e.x?s:e,t[0]),fo=t=>t.sort((e,s)=>{const o=ut(e),n=ut(s);return Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x}),St=t=>{const e=[],s=new Set;return t.forEach(o=>{if(s.has(o.id))return;const n=[],a=[o];for(;a.length>0;){const i=a.shift();s.has(i.id)||(s.add(i.id),n.push(i),t.forEach(c=>{s.has(c.id)||It(i,c)&&a.push(c)}))}n.length>0&&e.push(n)}),e.forEach((o,n)=>{console.log(`  Minor group ${n+1}: ${o.map(a=>a.number||a.id).join(", ")}`)}),e},vn=t=>{if(t.length<=1)return t[0]?t[0][0]:null;const e=new Map;for(const o of t){let n=0;for(const a of t){if(o===a)continue;let i=!1;for(const c of o){for(const l of a)if(Vt(c,l)){i=!0;break}if(i)break}i&&n++}e.set(o,n)}const s=t.filter(o=>e.get(o)===1);if(s.length===0){console.log("[Clockwise Start] Complete loop detected, finding leftmost group");let o=t[0];for(const n of t){const a=Ne(n),i=Ne(o);a.x<i.x&&(o=n)}return console.log("[Clockwise Start] Selected leftmost group:",o.map(n=>n.number||n.id).join(",")),o[0]}if(s.length>=2){console.log("[Clockwise Start] Broken chain detected with",s.length,"endpoints");let o=s[0];for(const n of s){const a=Ne(n),i=Ne(o);(a.y<i.y||Math.abs(a.y-i.y)<10&&a.x<i.x)&&(o=n)}return console.log("[Clockwise Start] Selected endpoint:",o.map(n=>n.number||n.id).join(",")),o[0]}return console.log("[Clockwise Start] Fallback to first group"),t[0][0]},gn=(t,e)=>{for(const s of e)if(s.some(o=>o.id===t.id))return s;return null},Ne=t=>{const e=t.reduce((o,n)=>o+n.x,0),s=t.reduce((o,n)=>o+n.y,0);return{x:e/t.length,y:s/t.length}},pn=(t,e,s)=>{const o=[],n=Ne(t);for(const a of s){if(e.has(a))continue;let i=!1;for(const c of t){for(const l of a)if(Vt(c,l)){i=!0;break}if(i)break}if(i){const c=Ne(a),l=c.x-n.x,d=c.y-n.y;let r=Math.atan2(d,l)*180/Math.PI;r<0&&(r+=360),o.push({group:a,angle:r})}}return o.length===0?null:(o.sort((a,i)=>a.angle-i.angle),o[0].group)},vo=t=>{if(t.length<=1)return t;const e=[],s=new Set,o=vn(t),n=gn(o,t);if(!n)return t.sort((i,c)=>{const l=ut(i),d=ut(c);return Math.abs(l.y-d.y)>1?l.y-d.y:l.x-d.x});let a=n;for(;a&&!s.has(a);)e.push(a),s.add(a),a=pn(a,s,t);for(const i of t)s.has(i)||e.push(i);return e},go=t=>{if(t.length===0)return[];const e=Ge(t[0].rotation||0);let s=[...t];switch(console.log(`[Rotation] Processing minor group with rotation ${e}°:`,t.map(o=>`${o.number||o.id}`)),e){case 0:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 90:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 180:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:n.x-o.x);break;case 270:s.sort((o,n)=>Math.abs(o.x-n.x)>1?o.x-n.x:n.y-o.y);break}return console.log("[Rotation] After rotation, order:",s.map(o=>o.number||o.id)),s},mn=(t,e,s,o)=>{let n=null,a=null;s.forEach((v,y)=>{v.some(h=>h.id===t.id)&&(n=y),v.some(h=>h.id===e.id)&&(a=y)});const i=n!==null&&a!==null&&n===a;let c=!1;if(o){const v=o.get(t.id),y=o.get(e.id);c=v!==void 0&&y!==void 0&&v===y}const l=v=>{if(v.typeId==="custom-1755675491548")return"normal";if(v.typeId==="custom-1755675506519")return"tall";if(v.color==="#4A90E2")return"blue";if(v.color==="#BD10E0")return"purple";if(!v.typeId&&v.actualHeight){if(v.actualHeight===30)return"normal";if(v.actualHeight===90)return"tall"}return v.typeId||"default"},d=l(t),r=l(e),f=d===r;return i?{same:!0,sameType:f,sameMinorGroup:!0,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:a,prevType:d,currentType:r}:{same:!1,sameType:f,sameMinorGroup:!1,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:a,prevType:d,currentType:r}},yn=(t,e,s,o)=>{const n=mn(t,e,s,o);return console.log(`  Group spacing between ${t.number} and ${e.number}:`,n),n.sameMinorGroup?(console.log("  → Same minor group: 0px gap"),0):n.sameMajorGroup?(console.log("  → Same major group, different minor group: 10px gap"),10):(console.log("  → Different major group: 20px gap"),20)},_e=()=>{console.trace("Called from:");const t=g.value.filter(p=>!p.parentLockrCd&&(!p.tierLevel||p.tierLevel===0));if(console.log(`[Transform] Processing ${t.length} parent lockers (${g.value.length-t.length} child lockers excluded from grouping)`),t.length===0)return;const e=ho(t),s=fo(e),o=[],n=2;let a=0;const i=[],c=[],l=[],d=new Map;s.forEach((p,k)=>{console.log(`[Front View] Processing major group ${k+1}:`,p.map(_=>`${_.number||_.id}(rot:${_.rotation||0})`)),p.forEach(_=>{d.set(_.id,k)});const D=St(p),Y=vo(D);l.push(...Y),console.log(`  Found ${Y.length} minor groups:`),Y.forEach((_,Z)=>{console.log(`    Minor Group ${Z+1}:`,_.map(C=>`${C.number}(rot:${C.rotation||0})`))}),Y.forEach((_,Z)=>{console.log(`  Processing minor group ${Z+1}:`,_.map(E=>`${E.number||E.id}(rot:${E.rotation||0})`)),go(_).forEach(E=>{c.push(E)})})});let r=null;c.forEach((p,k)=>{if(o.push(p),r&&k>0){let _=0;!r.parentLockrCd&&!p.parentLockrCd&&(_=yn(r,p,l,d)),a+=_}const D=(p.width||40)*n,Y=(p.actualHeight||p.height||60)*n;if(i.push({...p,frontViewX:a,frontViewY:Le-Y,frontViewRotation:0}),p.parentLockrCd){const _=i.find(Z=>Z.lockrCd===p.parentLockrCd);if(_){let Z=30;if(_.lockrTypeCd||_.typeId||_.type){const R=_.lockrTypeCd||_.typeId||_.type,z=ye.value.find(B=>B.id===R||B.type===R||B.LOCKR_TYPE_CD===R);z&&z.height&&(Z=z.height,console.log(`[TIER HEIGHT] Using type height: ${Z} for parent type: ${R}`))}const C=Z*n,E=p.tierLevel||1,S=_.frontViewX,I=_.frontViewY-C*E;i[i.length-1].frontViewX=S,i[i.length-1].frontViewY=I,i[i.length-1].frontViewRotation=0}else console.error(`[CHILD POSITION] Parent not found for ${p.number}, parentLockrCd: ${p.parentLockrCd}`),i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=Le-Y,i[i.length-1].frontViewRotation=0,a+=D}else i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=Le-Y,i[i.length-1].frontViewRotation=0,a+=D;r=p});const f=a,v=(Q.value-f)/2;i.forEach(p=>{p.frontViewX+=v});const y=[],h=0;if(i.forEach(p=>{const k=(p.actualHeight||p.height||0)*2,D=p.frontViewY;if(D<h){console.warn(`[Boundary Check] 락커 ${p.number}이(가) 화면 위쪽 경계를 넘어갑니다:`,{lockerId:p.id,number:p.number,topEdge:D,height:k,canvasTop:h,isOverflowing:D<h});const Y=g.value.find(_=>_.id===p.id);Y&&y.push(Y)}}),y.length>0){console.log(`[Boundary Check] 화면을 넘어가는 ${y.length}개의 락커를 삭제합니다:`,y.map(k=>`${k.number}(${k.id})`)),y.forEach(k=>{const D=g.value.findIndex(Y=>Y.id===k.id);D!==-1&&g.value.splice(D,1)});const p=y.map(async k=>{try{const D=await fetch(`${G}/lockrs/${k.lockrCd}`,{method:"DELETE"});D.ok?console.log(`[Boundary Check] 백엔드에서 락커 ${k.number}(${k.lockrCd}) 삭제 완료`):console.error(`[Boundary Check] 백엔드에서 락커 ${k.number} 삭제 실패:`,await D.text())}catch(D){console.error(`[Boundary Check] 백엔드에서 락커 ${k.number} 삭제 중 오류:`,D)}});Promise.all(p).then(()=>{console.log("[Boundary Check] 모든 경계 초과 락커 삭제 완료, 락커 목록 다시 로드 및 위치 재계산"),de().then(()=>{le(()=>{_e()})})})}console.log("[Batch Update] Starting batch update for all lockers...");const w=[];i.forEach(p=>{w.push({id:p.id,updates:{frontViewX:p.frontViewX,frontViewY:p.frontViewY,frontViewRotation:p.frontViewRotation||0}})}),console.log("[Transform] Child lockers excluded - preserving their existing FRONT_VIEW coordinates from DB"),A.batchUpdateLockers(w),console.log(`[Batch Update] Updated ${w.length} lockers simultaneously`),console.log("[DB Save] Saving front view coordinates to database...");const $=w.map(async p=>{try{const k=g.value.find(D=>D.id===p.id);if(k&&k.lockrCd){const D={};p.updates.frontViewX!==void 0&&(D.FRONT_VIEW_X=p.updates.frontViewX),p.updates.frontViewY!==void 0&&(D.FRONT_VIEW_Y=p.updates.frontViewY);const Y=await fetch(`${G}/lockrs/${k.lockrCd}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(D)});Y.ok?console.log(`[DB Save] Saved locker ${k.number} with FRONT_VIEW_X=${D.FRONT_VIEW_X}, FRONT_VIEW_Y=${D.FRONT_VIEW_Y}`):console.error(`[DB Save] Failed to save locker ${k.number}:`,await Y.text())}}catch(k){console.error(`[DB Save] Failed to save locker ${p.id}:`,k)}});Promise.all($).then(()=>{console.log("[DB Save] All front view coordinates saved to database")}).catch(p=>{console.error("[DB Save] Error saving some lockers:",p)}),Ht.value=o,console.log("[Front View] NEW Transformation complete:",{totalLockers:o.length,majorGroups:s.length,sequence:o.map(p=>p.number||p.id).join(" → "),deletedLockers:y.length})},po=()=>{if(b.value!=="front"){mo();return}const t=x.value.size>0?Array.from(x.value):L.value?[L.value.id]:[];if(t.length===0)return;const e=t.map(a=>g.value.find(i=>i.id===a)).filter(Boolean);if(e.some(a=>!a.parentLockrCd||a.tierLevel===0)){alert("부모 락커는 삭제할 수 없습니다. 자식 락커(상단 락커)만 삭제 가능합니다.");return}const o=new Map;e.forEach(a=>{const i=a.parentLockrCd||"no-parent";o.has(i)||o.set(i,[]),o.get(i).push(a)}),console.log("[DELETE] Lockers grouped by parent:",Array.from(o.entries()).map(([a,i])=>({parent:a,lockers:i.map(c=>({id:c.id,number:c.number,tierLevel:c.tierLevel}))})));for(const[a,i]of o.entries()){const c=i.map(r=>r.tierLevel||0).filter((r,f,v)=>v.indexOf(r)===f).sort((r,f)=>f-r);console.log(`[DELETE] Parent ${a} tier levels:`,c);const l=Math.max(...c);if(!c.every((r,f)=>{const v=l-f,y=r===v;return console.log(`[DELETE] Parent ${a} tier validation:`,{tier:r,index:f,expected:v,isValid:y}),y})){alert(`삭제는 각 부모 그룹별로 가장 높은 tier부터 순서대로만 가능합니다. (부모: ${a})`);return}}const n=[];for(const[a,i]of o.entries()){const c=Math.max(...i.map(d=>d.tierLevel||0));console.log(`[DELETE] Parent ${a} selected max tier:`,c);const l=g.value.some(d=>d.parentLockrCd===a&&!i.find(r=>r.id===d.id)&&(d.tierLevel||0)>c);console.log(`[DELETE] Parent ${a} has upper tiers:`,l),l&&n.push({parentKey:a,selectedMaxTier:c,reason:"선택된 최상단 락커 위에 더 높은 tier 존재"})}if(n.length>0){console.log("[DELETE] Blocked groups:",n),alert("선택된 락커들 중 일부 그룹에서 최상단 락커 위에 더 높은 tier가 있습니다. 가장 높은 tier부터 삭제해주세요.");return}mo(),L.value=null,console.log("[Delete] Deleted lockers:",t)},xn=t=>{const e=t.match(/locker-(\d+)/);return e?parseInt(e[1]):null},mo=async()=>{const t=x.value.size>0?Array.from(x.value):L.value?[L.value.id]:[];if(t.length===0)return;const e=[];for(const s of t){const o=g.value.find(n=>n.id===s);if(o&&(o.tierLevel===0||!o.parentLockerId)){const n=xn(s);if(n)try{const a=await fetch(`${G}/lockrs/${n}/children`);if(a.ok){const i=await a.json(),c=i.children||i;c&&c.length>0&&e.push(o)}}catch(a){console.error("[DEBUG] Error checking children:",a)}}}if(e.length>0){alert("상단 락커가 존재합니다. 정면 배치모드에서 상단 락커를 먼저 삭제해주세요.");return}else{const s=t.length;if(!confirm(`삭제하시겠습니까? (${s}개 락커)`))return}t.forEach(s=>{A.deleteLocker(s)}),x.value.clear(),L.value=null,console.log("[Delete] Deleted lockers:",t)},wn=()=>{const e=(O.value?A.lockers.filter(o=>o.zoneId===O.value.id):g.value).map(o=>parseInt(String(o.lockrNo||0))).filter(o=>o>0).sort((o,n)=>o-n);if(e.length===0)return[];const s=[];for(let o=1;o<e[e.length-1];o++)e.includes(o)||s.push(`L${o}`);return s},Ln=t=>{x.value.size===0&&!L.value||(t.preventDefault(),Lt.value=!0,Xe.value={x:t.clientX,y:t.clientY})},Se=()=>{Lt.value=!1},bn=()=>{po(),Se()},Cn=()=>{Se(),tt.value=!0,ge.value=1,le(()=>{const t=Bt.value;t&&(t.focus(),t.select())})},yo=async()=>{const t=Number(ge.value);if(isNaN(t)||t<1||t>9){alert("단수는 1부터 9까지 숫자만 입력 가능합니다.");return}if(b.value!=="front"){alert("단수 추가는 정면배치모드(Front View)에서만 가능합니다.");return}console.log("[AddFloors] Loading latest locker data from database..."),await de(),console.log("[AddFloors] Latest data loaded, processing tier addition...");const e=Array.from(x.value).map(o=>g.value.find(n=>n.id===o)).filter(Boolean),s=e.map(async o=>{let n=o,a=null;if(o.parentLockerId||o.parentLockrCd){if(a=g.value.find(d=>d.id===o.parentLockerId||d.lockrCd===o.parentLockrCd),!a){console.error(`[AddFloors] Parent not found for child locker ${o.number}`);return}n=a,console.log(`[AddFloors] Selected locker is CHILD (${o.number}), using parent (${n.number})`)}else console.log(`[AddFloors] Selected locker is PARENT (${n.number})`);console.log("[AddFloors] Finding existing children for parent:",{parentId:n.id,parentLockrCd:n.lockrCd,parentNumber:n.number});const i=g.value.filter(d=>{const r=d.parentLockrCd&&d.parentLockrCd===n.lockrCd||d.parentLockerId&&d.parentLockerId===n.id;return r&&console.log("[AddFloors] Found existing child:",{childId:d.id,childNumber:d.number,parentLockrCd:d.parentLockrCd,parentLockerId:d.parentLockerId,tierLevel:d.tierLevel||0}),r}),c=i.reduce((d,r)=>Math.max(d,r.tierLevel||0),0),l=c>0?c+1:1;console.log("[AddFloors] Tier level calculation:",{existingChildrenCount:i.length,maxExistingTier:c,startTierLevel:l,algorithm:c>0?`Children exist -> Start from tier ${l}`:"No children -> Start from tier 1"}),console.log(`[AddFloors] Adding ${t} tiers to parent locker:`,{number:n.number,parentLockrCd:n.lockrCd,existingChildren:i.length,existingChildrenDetails:i.map(d=>({number:d.number,tierLevel:d.tierLevel})),maxExistingTier:c,startTierLevel:l,frontViewX:n.frontViewX,frontViewY:n.frontViewY});try{const d={tierCount:t,startTierLevel:l,parentFrontViewX:n.frontViewX,parentFrontViewY:n.frontViewY};console.log("[AddFloors] Sending to backend:",d);const f=await(await fetch(`${G}/lockrs/${n.lockrCd}/tiers`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d)})).json();if(f.success)console.log(`[AddFloors] Successfully added ${f.count} tiers starting from level ${l}`);else throw console.error("[AddFloors] Failed to add tiers:",f.error),new Error(f.error)}catch(d){throw console.error("[AddFloors] Error adding tiers:",d),d}});try{await Promise.all(s),console.log("[AddFloors] All tiers added successfully")}catch(o){console.error("[AddFloors] Some tiers failed to add:",o),alert("티어 추가 중 오류가 발생했습니다: "+o.message);return}tt.value=!1,console.log(`[Context Menu] Added ${t} tiers to ${e.length} lockers`),de().then(()=>{le(()=>{console.log("[AddFloors] Applying front view transformation for new tiers...");try{_e(),console.log("[AddFloors] Front view transformation completed for new tiers")}catch(o){console.error("[AddFloors] Front view transformation failed:",o),uo()}})}),co()},Mn=t=>{const e=t.target,o=e.value.replace(/[^0-9]/g,"");if(o!==""){const n=parseInt(o);n>9?(e.value="9",ge.value=9):n<1?(e.value="1",ge.value=1):(e.value=o,ge.value=n)}else e.value="",ge.value=1},En=()=>{Se();const t=O.value?A.lockers.filter(o=>o.zoneId===O.value.id):g.value,e=new Set(t.map(o=>o.lockrNo).filter(o=>o&&o>0));let s=1;for(;e.has(s);)s++;console.log("[Number Dialog] 기존 번호:",Array.from(e).sort((o,n)=>o-n)),console.log(`[Number Dialog] 첫 번째 빈 번호: ${s}`),nt.value=!0,st.value=s,ke.value="horizontal",Te.value=!1,Ae.value=!1,le(()=>{const o=jt.value;o&&(o.focus(),o.select())})},kn=()=>{console.log("[Grouping Analysis] Starting analysis..."),console.log("[TEST] Running test with known data first..."),Nn();const t=g.value.filter(s=>!s.parentLockrCd);if(t.length===0){wt.value="분석할 락커가 없습니다.",Ve.value=!0;return}console.log("[REAL DATA] Now analyzing actual lockers...");let e=`세로배치 순서별 그룹 분석
`;e+=`━━━━━━━━━━━━━━━━━━━━━
`;try{const s=ho(t),o=fo(s);if(o.forEach((n,a)=>{e+=`대그룹 ${a+1} (${n.length}개 락커):
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;const i=St(n),c=vo(i);if(c.forEach((l,d)=>{const f=go(l).map(y=>{const h=t.find(w=>w.id===y.id);return`${(h==null?void 0:h.number)||y.id}(${(h==null?void 0:h.rotation)||0}°)`}).join(", ");let v="";if(l.length===1?v="단독":v="인접 (같은방향)",e+=`  소그룹 ${a+1}-${d+1}: ${f} - ${v}
`,l.length>1){e+=`    소그룹 내 거리:
`;for(let y=0;y<l.length-1;y++)for(let h=y+1;h<l.length;h++)if(It(l[y],l[h])){const w=Yt(l[y],l[h]),$=l[y].number||l[y].id,p=l[h].number||l[h].id;e+=`      ${$} ↔ ${p}: ${w.toFixed(2)}px
`}}}),c.length>1){e+=`  소그룹 간 거리:
`;for(let l=0;l<c.length-1;l++)for(let d=l+1;d<c.length;d++){let r=1/0,f={l1:"",l2:""};for(const v of c[l])for(const y of c[d]){const h=Yt(v,y);h<r&&(r=h,f.l1=v.number||v.id,f.l2=y.number||y.id)}e+=`    소그룹 ${a+1}-${l+1} ↔ 소그룹 ${a+1}-${d+1}: ${r.toFixed(2)}px (${f.l1} - ${f.l2})
`}}e+=`
`}),o.length>1){e+=`대그룹 간 거리:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;for(let n=0;n<o.length-1;n++)for(let a=n+1;a<o.length;a++){let i=1/0,c={l1:"",l2:""};for(const l of o[n])for(const d of o[a]){const r=Yt(l,d);r<i&&(i=r,c.l1=l.number||l.id,c.l2=d.number||d.id)}e+=`  대그룹 ${n+1} ↔ 대그룹 ${a+1}: ${i.toFixed(2)}px (${c.l1} - ${c.l2})
`}e+=`
`}e+=`요약:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`,e+=`총 대그룹: ${s.length}개
`,e+=`총 소그룹: ${o.reduce((n,a)=>n+St(a).length,0)}개
`,e+=`
💡 이 순서는 세로배치 시 실제 표시 순서와 동일합니다.`}catch(s){console.error("[Grouping Analysis] Error:",s),e+=`분석 중 오류가 발생했습니다.
`,e+=s.message}wt.value=e,Ve.value=!0},Rt=()=>{const t=O.value?A.lockers.filter(o=>o.zoneId===O.value.id):g.value;console.log("[findNextAvailableLabel] Total lockers in zone:",t.length);const e=t.map(o=>{const n=o.number||o.lockrLabel||"",a=n.toString().match(/^L(\d+)$/),i=a?parseInt(a[1]):0;return i>0&&console.log(`[findNextAvailableLabel] Found label ${n} -> number ${i}`),i}).filter(o=>o>0).sort((o,n)=>o-n);if(console.log("[findNextAvailableLabel] Assigned numbers:",e),e.length===0)return console.log("[findNextAvailableLabel] No existing labels, returning L1"),"L1";for(let o=1;o<e[e.length-1];o++)if(!e.includes(o))return console.log(`[findNextAvailableLabel] Found gap at ${o}, returning L${o}`),`L${o}`;const s=e[e.length-1]+1;return console.log(`[findNextAvailableLabel] No gaps found, returning L${s}`),`L${s}`},Tn=(t,e)=>{if(t.length===0)return[];const s=20;if(e){const o=new Map;return t.forEach(n=>{const a=n.frontViewY||n.y;let i=null;for(let[c]of o)if(Math.abs(a-c)<=s){i=c;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewX||a.x)-(i.frontViewX||i.x)))}else{const o=new Map;return t.forEach(n=>{const a=n.frontViewX||n.x;let i=null;for(let[c]of o)if(Math.abs(a-c)<=s){i=c;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewY||a.y)-(i.frontViewY||i.y)))}},xo=async()=>{be.value=!0,pe.value="번호 할당을 준비중입니다...";try{const t=O.value?A.lockers.filter(h=>h.zoneId===O.value.id):g.value,e=new Set(t.map(h=>h.lockrNo).filter(h=>h&&h>0));console.log("[Number Assignment] Step 1 - 기존 번호들:",Array.from(e).sort((h,w)=>h-w));const s=Array.from(x.value).map(h=>g.value.find(w=>w.id===h)).filter(Boolean);s.length>0&&(console.log("[Number Assignment] 샘플 락커 전체 데이터:",s[0]),console.log("[Number Assignment] 샘플 락커 주요 필드:",{id:s[0].id,lockrNo:s[0].lockrNo,lockrNoType:typeof s[0].lockrNo,number:s[0].number,numberType:typeof s[0].number,lockrCd:s[0].lockrCd,LOCKR_NO:s[0].LOCKR_NO,LOCKR_NO_Type:typeof s[0].LOCKR_NO}));const o=[],n=[];if(s.forEach((h,w)=>{const $=h.lockrNo||h.LOCKR_NO||h.number,p=Number($),k=!isNaN(p)&&p>0;w<3&&console.log(`[Number Assignment] 락커 ${w+1} 상세:`,{id:h.id.slice(-4),lockrNo:h.lockrNo,LOCKR_NO:h.LOCKR_NO,number:h.number,converted:p,hasNumber:k}),k?(h.lockrNo=p,o.push(h)):n.push(h)}),console.log(`[Number Assignment] Step 2 - 선택된 락커: 총 ${s.length}개`),console.log(`  - 번호 있음: ${o.length}개`,o.map(h=>`L${h.lockrNo}`)),console.log(`  - 번호 없음: ${n.length}개`),n.length===0){alert("선택한 모든 락커에 이미 번호가 부여되어 있습니다."),be.value=!1;return}const a=ke.value==="horizontal";let i=Tn(n,a);Ae.value&&i.reverse(),Te.value&&i.forEach(h=>h.reverse());const c=i.flat();console.log("[Number Assignment] Step 2 - 정렬 완료:",c.map((h,w)=>`${w+1}번째: ${h.id.slice(-4)}`));const l=st.value||1;let d=l;const r=[],f=[];J.value==="odd"&&d%2===0?(d++,console.log(`[Number Assignment] 홀수 모드: 시작번호를 ${l}에서 ${d}로 조정`)):J.value==="even"&&d%2===1&&(d++,console.log(`[Number Assignment] 짝수 모드: 시작번호를 ${l}에서 ${d}로 조정`)),console.log(`[Number Assignment] Step 3 - 시작번호: ${d}, 할당할 락커 수: ${c.length}, 모드: ${J.value}`),pe.value=`락커 번호를 할당중입니다... (0/${c.length})`;let v=0;for(const h of c){for(;e.has(d);)console.log(`  - ${d}번은 이미 사용중, 다음 번호 확인`),J.value==="all"?d++:d+=2;console.log(`  - ${h.id.slice(-4)} 락커에 ${d}번 할당`),A.updateLocker(h.id,{lockrNo:d}),h.lockrCd&&r.push({lockrCd:h.lockrCd,LOCKR_NO:d}),f.push(`${v+1}. ${h.id.slice(-4)} → L${d}`),e.add(d),J.value==="all"?d++:d+=2,v++,pe.value=`락커 번호를 할당중입니다... (${v}/${c.length})`}if(console.log("[Number Assignment] Step 3 완료 - 할당 내역:",f),r.length>0)try{pe.value=`데이터베이스에 ${r.length}개 락커 번호를 저장중입니다...`,console.log(`[Number Assignment] Step 4 - DB 배치 업데이트 시작: ${r.length}개`),await Io(r),console.log("[Number Assignment] Step 4 완료 - DB 업데이트 성공"),pe.value="번호 할당이 완료되었습니다!"}catch(h){console.error("[Number Assignment] DB 업데이트 실패:",h),pe.value="데이터베이스 저장에 실패했습니다.",alert("데이터베이스 저장 중 오류가 발생했습니다. 다시 시도해주세요.");return}console.log("[Number Assignment] 전체 프로세스 완료"),console.log(`  - 총 ${n.length}개 락커에 번호 할당 완료`),console.log(`  - ${o.length}개 락커는 기존 번호 유지`);const y=wn();y.length>0&&console.log("[Number Assignment] 번호 갭 발견:",y),setTimeout(()=>{nt.value=!1},500)}catch(t){console.error("[Number Assignment] Assignment failed:",t),pe.value="번호 할당 중 오류가 발생했습니다.",alert("번호 할당 중 오류가 발생했습니다. 다시 시도해주세요.")}finally{be.value=!1}},An=async()=>{if(Se(),confirm("선택된 락커의 번호를 삭제하시겠습니까?")){const t=Array.from(x.value).map(async e=>{try{A.updateLocker(e,{lockrNo:void 0});const s=g.value.find(o=>o.id===e);s&&s.lockrCd&&await Qt(s.lockrCd,{LOCKR_NO:0})}catch(s){console.error(`[Number Deletion] Failed to delete number for locker ${e}:`,s)}});await Promise.all(t)}},Dn=()=>{console.log("[Overlap Fix] Starting overlap detection and fix...");let t=0;for(let e=0;e<g.value.length;e++){const s=g.value[e],o=ae(s);for(let n=e+1;n<g.value.length;n++){const a=g.value[n],i=ae(a),c=Math.min(o.x+o.width,i.x+i.width)-Math.max(o.x,i.x),l=Math.min(o.y+o.height,i.y+i.height)-Math.max(o.y,i.y),d=.5;if(c>d&&l>d){let r=a.x,f=a.y;if(Math.abs(c)<Math.abs(l))if(i.x<o.x+o.width/2){const w=Math.max(Math.abs(c)+4,4);r=a.x-w}else{const w=Math.max(Math.abs(c)+4,4);r=a.x+w}else if(i.y<o.y+o.height/2){const w=Math.max(Math.abs(l)+4,4);f=a.y-w}else{const w=Math.max(Math.abs(l)+4,4);f=a.y+w}r=ht(r),f=ht(f);const v=te(a);r=Math.max(0,Math.min(r,Q.value-v.width)),f=Math.max(0,Math.min(f,ee.value-v.height));const y=a.x,h=a.y;A.updateLocker(a.id,{x:r,y:f}),t++,console.log(`[Overlap Fix] Moved ${a.id} from (${y}, ${h}) to (${r}, ${f})`)}}}return t>0?console.log(`[Overlap Fix] Fixed ${t} overlapping lockers`):console.log("[Overlap Fix] No overlaps detected"),t},ae=t=>{let e,s;if(t.type||t.id){const h=te(t);e=h.width,s=h.height}else e=t.width,s=t.height;const o=(t.rotation||0)*Math.PI/180;if(o===0)return{x:t.x,y:t.y,width:e,height:s,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s};const n=e/2,a=s/2,i=Math.cos(o),c=Math.sin(o),d=[{x:0,y:0},{x:e,y:0},{x:e,y:s},{x:0,y:s}].map(h=>{const w=h.x-n,$=h.y-a,p=w*i-$*c,k=w*c+$*i;return{x:t.x+n+p,y:t.y+a+k}}),r=Math.min(...d.map(h=>h.x)),f=Math.max(...d.map(h=>h.x)),v=Math.min(...d.map(h=>h.y)),y=Math.max(...d.map(h=>h.y));return{x:r,y:v,width:f-r,height:y-v,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s}},ht=(t,e=20)=>Math.round(t/e)*e,wo=(t,e,s,o,n,a=0)=>{const l=ae({x:t,y:e,width:s,height:o,rotation:a});let d=t,r=e,f=!1;console.log("=== SNAP PRIORITY DEBUG ==="),console.log("Checking corner snap first (priority 1)");for(const v of g.value){if(v.id===n)continue;const y=ae(v),h=y.x,w=y.y,$=y.width,p=y.height,k=[{existingX:h+$,existingY:w+p,dragX:l.x,dragY:l.y,type:"corner-bottom-right-to-top-left"},{existingX:h,existingY:w+p,dragX:l.x+l.width,dragY:l.y,type:"corner-bottom-left-to-top-right"},{existingX:h+$,existingY:w,dragX:l.x,dragY:l.y+l.height,type:"corner-top-right-to-bottom-left"},{existingX:h,existingY:w,dragX:l.x+l.width,dragY:l.y+l.height,type:"corner-top-left-to-bottom-right"}];for(const C of k){const E=Math.sqrt(Math.pow(C.existingX-C.dragX,2)+Math.pow(C.existingY-C.dragY,2));if(E<20){console.log(`[CORNER SNAP] ${C.type}, distance: ${E.toFixed(1)}`),d=t+(C.existingX-C.dragX),r=e+(C.existingY-C.dragY),f=!0;break}}if(f){console.log("Corner snap succeeded - skipping face-to-face snap");break}if(console.log("No corner snap - checking face-to-face snap (priority 2)"),Math.abs(h+$-l.x)<20&&!f){d=t+(h+$-l.x);const C=Math.abs(l.y-w),E=Math.abs(l.y+l.height-(w+p));C<20?r=e+(w-l.y):E<20&&(r=e+(w+p-(l.y+l.height))),f=!0,console.log("[FACE SNAP] Right snap applied");continue}if(Math.abs(h-(l.x+l.width))<20&&!f){d=t+(h-(l.x+l.width));const C=Math.abs(l.y-w),E=Math.abs(l.y+l.height-(w+p));C<20?r=e+(w-l.y):E<20&&(r=e+(w+p-(l.y+l.height))),f=!0,console.log("[FACE SNAP] Left snap applied");continue}if(Math.abs(w+p-l.y)<20&&!f){r=e+(w+p-l.y);const C=Math.abs(l.x-h),E=Math.abs(l.x+l.width-(h+$));C<20?d=t+(h-l.x):E<20&&(d=t+(h+$-(l.x+l.width))),f=!0,console.log("[FACE SNAP] Bottom snap applied");continue}if(Math.abs(w-(l.y+l.height))<20&&!f){r=e+(w-(l.y+l.height));const C=Math.abs(l.x-h),E=Math.abs(l.x+l.width-(h+$));C<20?d=t+(h-l.x):E<20&&(d=t+(h+$-(l.x+l.width))),f=!0,console.log("[FACE SNAP] Top snap applied");continue}}return console.log("Final result: snapped =",f),{x:d,y:r}},Ot=(t,e,s,o,n=null,a=0,i=!1)=>{const c=ae({x:t,y:e,width:s,height:o,rotation:a});return g.value.some(l=>{if(l.id===n||P.value&&x.value.has(l.id))return!1;const d=ae(l),r=Math.min(c.x+c.width,d.x+d.width)-Math.max(c.x,d.x),f=Math.min(c.y+c.height,d.y+d.height)-Math.max(c.y,d.y),v=.5,y=r>v&&f>v;return y&&console.log("[COLLISION] Detected with",l.id,"- overlap:",`(${r.toFixed(1)}, ${f.toFixed(1)})`,"tolerance:",v),y})},$n=()=>{console.log("[TEST] Creating test locker data with Adjacent/Connected thresholds..."),console.log("[TEST] ADJACENT: ≤30px + same direction, CONNECTED: 40-43px (any direction)");const t=[{id:"test-L1",number:"L1",x:100,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L2",number:"L2",x:165,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L3",number:"L3",x:230,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L4",number:"L4",x:312,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L5",number:"L5",x:377,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L6",number:"L6",x:442,y:100,width:40,height:60,rotation:90,color:"#BD10E0"}];return console.log("[TEST] Expected result: ALL in 1 major group (connected through L3↔L4)"),console.log("[TEST] Expected minor groups: [L1,L2,L3] (adjacent, 0°), [L4,L5,L6] (adjacent, 90°)"),console.log("[TEST] Key distances:"),console.log("[TEST]   L1↔L2: 25px (adjacent, same dir)"),console.log("[TEST]   L2↔L3: 25px (adjacent, same dir)"),console.log("[TEST]   L3↔L4: 42px (connected, diff dir)"),console.log("[TEST]   L4↔L5: 25px (adjacent, same dir)"),console.log("[TEST]   L5↔L6: 25px (adjacent, same dir)"),t},Nn=()=>{console.log("=== TESTING WITH KNOWN DATA ===");const t=[...g.value];g.value=$n();const e=bo();return g.value=t,console.log("=== TEST COMPLETE ==="),e},ft=t=>{const e=t.x||t.left||0,s=t.y||t.top||0,o=t.width||60,n=t.height||t.depth||40,a=(t.rotation||0)*Math.PI/180,i=e+o/2,c=s+n/2;return[{x:-o/2,y:-n/2},{x:o/2,y:-n/2},{x:o/2,y:n/2},{x:-o/2,y:n/2}].map(d=>({x:i+d.x*Math.cos(a)-d.y*Math.sin(a),y:c+d.x*Math.sin(a)+d.y*Math.cos(a)}))},Yt=(t,e)=>{const s=ft(t),o=ft(e);let n=1/0;for(const a of s)for(const i of o){const c=Math.sqrt(Math.pow(a.x-i.x,2)+Math.pow(a.y-i.y,2));n=Math.min(n,c)}return n},Lo=(t,e,s)=>{const o=ft(t),n=ft(e);let a=0;for(const i of o)for(const c of n)Math.sqrt(Math.pow(i.x-c.x,2)+Math.pow(i.y-c.y,2))<s&&a++;return a},It=(t,e)=>{const s=Lo(t,e,$o),o=Ge(t.rotation||0),n=Ge(e.rotation||0),a=o===n;return s>=2&&a},Vt=(t,e)=>{const s=Lo(t,e,$o);if(s>=1)return!0;if(s>=2){const o=Ge(t.rotation||0),n=Ge(e.rotation||0);return o!==n}return!1},bo=t=>{const e=[],s=new Set,o=t||g.value;return o.forEach(n=>{if(s.has(n.id))return;const a=[n];s.add(n.id);const i=[n];for(;i.length>0;){const c=i.shift();o.forEach(l=>{if(s.has(l.id))return;const d=It(c,l),r=Vt(c,l);(d||r)&&(a.push(l),s.add(l.id),i.push(l))})}e.push(a)}),e.forEach((n,a)=>{console.log(`  Group ${a+1}: ${n.map(i=>i.number||i.id).join(", ")}`)}),e},_n=async t=>{try{const s={LOCKR_KND_CD:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,LOCKR_KND_NM:t.name,X:0,Y:0,WIDTH:Q.value,HEIGHT:ee.value,COLOR:t.color||"#f0f9ff"};await Yo(s);const o=Ce.value.find(n=>n.LOCKR_KND_NM===t.name);o&&Be(o),Ye.value=!1}catch(e){console.error("Failed to save zone:",e),alert("Failed to save zone. Please try again.")}},Sn=async t=>{var e;try{const s={id:`locker-${Date.now()}`,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:`custom-${Date.now()}`,zoneId:((e=O.value)==null?void 0:e.id)||null,x:0,y:0,rotation:0};await kt(s);try{const n=await fetch(`${G}/types`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LOCKR_TYPE_CD:`custom-${Date.now()}`,LOCKR_TYPE_NM:t.name,WIDTH:t.width,HEIGHT:t.height,DEPTH:t.depth,COLOR:t.color||"#3b82f6"})});n.ok?console.log("[Locker Registration] Type saved to backend successfully"):console.error("Failed to save locker type to backend:",await n.text())}catch(n){console.error("Error saving locker type to backend:",n)}const o={id:s.id,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:s.type};ye.value.push(o),Ie.value=!1,console.log("[Locker Registration] New locker saved:",{id:s.id,name:s.name,dimensions:{width:s.width,depth:s.depth,height:s.height},type:s.type})}catch(s){console.error("Failed to save locker:",s),alert("Failed to save locker. Please try again.")}},Rn=()=>{console.log("[Debug] All locker dimensions:"),g.value.forEach(t=>{console.log(`${t.type||t.name}:`,{id:t.id,width:t.width,height:t.height,depth:t.depth,actualHeight:t.actualHeight,position:{x:t.x,y:t.y}})}),console.log("[Snap System] Configuration:",{threshold:20,lockerCount:g.value.length,viewMode:b.value})},vt=(t,e)=>{if(!L.value)return;const s=Math.max(0,Math.min(L.value.x+t,Q.value-L.value.width)),o=Math.max(0,Math.min(L.value.y+e,ee.value-L.value.height));A.updateLocker(L.value.id,{x:s,y:o})},Xt=t=>{(t.ctrlKey||t.metaKey)&&(xt.value=!0);const e=t.target;if(e.tagName==="INPUT"||e.tagName==="TEXTAREA"){console.log("[Keyboard] Ignored - typing in input field");return}if(Ie.value||Ye.value){console.log("[Keyboard] Ignored - modal is open");return}if((t.ctrlKey||t.metaKey)&&t.shiftKey&&t.key==="F"){t.preventDefault();const s=Dn();s>0?(console.log(`[Keyboard] Fixed ${s} overlapping lockers`),alert(`Fixed ${s} overlapping lockers`)):(console.log("[Keyboard] No overlaps detected"),alert("No overlapping lockers found"));return}if((t.ctrlKey||t.metaKey)&&t.key==="a"){t.preventDefault(),g.value.forEach(s=>{x.value.add(s.id)}),g.value.length>0&&(L.value=g.value[0]),console.log("[Multi-Select] Selected all lockers");return}if(t.key==="r"||t.key==="R"){t.preventDefault(),L.value;return}if((t.ctrlKey||t.metaKey)&&t.key==="c"){if(b.value==="front"){console.log("[Copy] Disabled in front view mode");return}t.preventDefault(),x.value.size>0?(Me.value=Array.from(x.value).map(s=>{const o=g.value.find(n=>n.id===s);return o?{...o}:null}).filter(Boolean),console.log("[Multi-Select] Copied",Me.value.length,"lockers")):L.value&&(Me.value=[{...L.value}],console.log("[Copy] Locker copied:",L.value.id));return}if((t.ctrlKey||t.metaKey)&&t.key==="v"&&Me.value&&Me.value.length>0&&O.value){if(b.value==="front"){console.log("[Paste] Disabled in front view mode");return}t.preventDefault(),x.value.clear(),Me.value.forEach((s,o)=>{const n={...s,id:`locker-${Date.now()}-${Math.random()}`,number:Rt(),x:s.x+20,y:s.y+20,zoneId:O.value.id},a=A.addLocker(n);x.value.add(a.id),o===0&&(L.value=a)}),console.log("[Multi-Select] Pasted",Me.value.length,"lockers");return}if((t.key==="Delete"||t.key==="Backspace")&&(L.value||x.value.size>0)&&(t.preventDefault(),po()),(t.key==="g"||t.key==="G")&&(t.preventDefault(),ze.value=!ze.value,console.log(`[Alignment] Guides ${ze.value?"ON":"OFF"}`)),t.ctrlKey&&t.key==="z"&&(t.preventDefault(),A.undo()),t.ctrlKey&&t.key==="y"&&(t.preventDefault(),A.redo()),t.key==="Escape"&&(x.value.clear(),L.value=null,A.selectLocker(null)),L.value){const s=t.shiftKey?20:1;t.key==="ArrowLeft"?(t.preventDefault(),vt(-s,0)):t.key==="ArrowRight"?(t.preventDefault(),vt(s,0)):t.key==="ArrowUp"?(t.preventDefault(),vt(0,-s)):t.key==="ArrowDown"&&(t.preventDefault(),vt(0,s))}};gt(()=>g.value,t=>{if(L.value){const e=t.find(s=>s.id===L.value.id);e&&(L.value=e)}},{deep:!0}),gt(()=>b.value,async(t,e)=>{if(e&&t!==e){if(console.log(`[ViewMode Change] ${e} → ${t}, reloading lockers...`),await de(),t==="front"&&e==="floor")console.log("[ViewMode Change] Transitioning from floor to front - recalculating positions..."),le(()=>{try{_e(),console.log("[ViewMode Change] Front view transformation completed")}catch(s){console.error("[ViewMode Change] Front view transformation failed:",s),uo()}});else if(t==="front"&&e==="front"){console.log("[ViewMode Change] Zone change in front view - checking for missing coordinates...");const s=g.value.filter(o=>o.frontViewX===null||o.frontViewX===void 0||o.frontViewY===null||o.frontViewY===void 0);s.length>0?(console.log(`[ViewMode Change] Found ${s.length} lockers with missing front view coordinates`),console.log("[ViewMode Change] Missing coordinates for lockers:",s.map(o=>o.number).join(", ")),console.log("[ViewMode Change] Recalculating positions for ALL lockers in zone using grouping logic"),le(()=>{try{_e(),console.log("[ViewMode Change] Zone-wide recalculation completed")}catch(o){console.error("[ViewMode Change] Zone-wide recalculation failed:",o)}})):console.log("[ViewMode Change] All lockers have saved positions - using DB coordinates")}}else e||console.log("[ViewMode Watcher] Initial mount - skipping reload (onMounted will handle it)")});const On=ie(()=>Pe.value||P.value?"grabbing":we.value?"crosshair":xt.value&&x.value.size>0?"copy":x.value.size>0?"move":"default"),Yn=ie(()=>{const t=Gt.value/F.value,e=Ut.value/F.value,s=U.value.x,o=U.value.y;return`${s} ${o} ${t} ${e}`});gt(x,t=>{},{immediate:!0,deep:!0}),gt(rt,t=>{},{deep:!0}),Pn(async()=>{console.log("Component mounted, loading data..."),b.value="floor",console.log("[onMounted] Initial view mode set to:",b.value),xe.value=!0,Fe.value=!0;try{if(await Promise.all([Et(),Jt()]),console.log("[onMounted] About to load lockers with view mode:",b.value),await de(),await le(),xe.value=!1,Fe.value=!1,console.log("All data loading completed"),b.value==="floor"&&g.value.length>0&&setTimeout(()=>{De()},100),b.value==="front"){const t=g.value.filter(e=>e.frontViewX===null||e.frontViewX===void 0||e.frontViewY===null||e.frontViewY===void 0);t.length>0&&(console.log(`[onMounted] Found ${t.length} lockers with missing front view coordinates`),console.log("[onMounted] Auto-calculating positions for lockers:",t.map(e=>e.number).join(", ")),le(()=>{try{_e(),console.log("[onMounted] Auto-calculation completed")}catch(e){console.error("[onMounted] Auto-calculation failed:",e)}}))}Ce.value.length>0&&!O.value&&(Be(Ce.value[0]),console.log("[Data Loading] Auto-selected first zone:",Ce.value[0].name))}catch(t){console.error("Error loading data:",t),xe.value=!1,Fe.value=!1}setTimeout(()=>{it()},100),window.addEventListener("resize",it),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt),document.addEventListener("click",Se),A.zones.length>0&&Be(A.zones[0]),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt)});const Pt=t=>{!t.ctrlKey&&!t.metaKey&&(xt.value=!1)};return Fn(()=>{document.removeEventListener("keydown",Xt),document.removeEventListener("keyup",Pt),document.removeEventListener("click",Se),window.removeEventListener("resize",it)}),(t,e)=>{var s;return M(),T("div",Wn,[xe.value||Fe.value?(M(),T("div",Zn,e[36]||(e[36]=[u("div",{class:"loading-spinner"},[u("div",{class:"spinner"}),u("p",null,"Loading locker data...")],-1)]))):(M(),T("div",qn,[u("div",Jn,[u("aside",Qn,[e[41]||(e[41]=u("h2",{class:"locker-sidebar-title"},"락커 선택창",-1)),xe.value?(M(),T("div",es,e[37]||(e[37]=[u("p",null,"🔄 락커 타입을 불러오는 중...",-1)]))):qt.value&&Tt.value.length===0?(M(),T("div",ts,e[38]||(e[38]=[u("p",null,"📦 등록된 락커가 없습니다",-1),u("p",{class:"empty-hint"},"락커를 등록해주세요",-1)]))):Tt.value.length>0?(M(),T("div",os,[(M(!0),T(re,null,ue(Tt.value,o=>{var n;return M(),T("div",{key:o.id,class:"locker-type-item-wrapper"},[u("div",{class:Re(["locker-type-item",{active:((n=Oe.value)==null?void 0:n.id)===o.id}]),onClick:a=>Uo(o),onDblclick:a=>Zo(o),onContextmenu:se(a=>Go(a,o),["prevent"]),style:{cursor:"pointer"}},[u("div",ss,[(M(),T("svg",{width:(o.width||40)*2,height:(o.depth||o.width||40)*2,viewBox:`0 0 ${(o.width||40)*2} ${(o.depth||o.width||40)*2}`,class:"type-preview"},[u("rect",{x:"2",y:"2",width:Math.max((o.width||40)*2-4,1),height:Math.max((o.depth||o.width||40)*2-4,1),fill:o.color?`${o.color}20`:"#FFFFFF",stroke:"#9ca3af","stroke-width":.5*2,rx:2*2,ry:2*2,"shape-rendering":"crispEdges"},null,8,is),u("line",{x1:10,y1:(o.depth||o.width||40)*2-5,x2:(o.width||40)*2-10,y2:(o.depth||o.width||40)*2-5,stroke:o.color||"#1e40af","stroke-width":"4",opacity:"0.9","stroke-linecap":"square",class:"front-indicator"},null,8,ls)],8,as))]),u("div",rs,[u("span",cs,N(o.name||"Unknown"),1),u("span",ds,N(o.width)+"x"+N(o.depth||o.width)+"x"+N(o.height)+"cm ",1)])],42,ns),u("button",{class:"delete-type-button",onClick:se(a=>so(o),["stop"]),title:"이 락커 타입 삭제"},e[39]||(e[39]=[u("svg",{width:"16",height:"16",viewBox:"0 0 16 16"},[u("path",{d:"M4 4 L12 12 M12 4 L4 12",stroke:"#ef4444","stroke-width":"2","stroke-linecap":"round"})],-1)]),8,us)])}),128))])):V("",!0),Ke.value.length>0?(M(),T("div",hs,[e[40]||(e[40]=u("div",{class:"section-title"},"삭제된 타입",-1)),(M(!0),T(re,null,ue(Ke.value,o=>(M(),T("div",{key:o,class:"deleted-type-item"},[u("span",null,N(Jo(o)),1),u("button",{onClick:n=>qo(o),class:"restore-btn"},"복원",8,fs)]))),128))])):V("",!0),u("button",{class:"register-locker-btn",onClick:e[0]||(e[0]=o=>Ie.value=!0)}," 락커 등록 ")]),u("main",vs,[u("div",gs,[u("div",ps,[(M(!0),T(re,null,ue(Ce.value,o=>{var n,a;return M(),T("button",{key:o.id,class:Re(["zone-tab",{active:((n=O.value)==null?void 0:n.id)===o.id}]),onClick:i=>Be(o),onContextmenu:i=>Bo(i,o)},[he(N(o.name)+" ",1),((a=O.value)==null?void 0:a.id)===o.id?(M(),T("span",ys)):V("",!0)],42,ms)}),128))]),u("div",xs,[u("button",{class:"zone-add-btn",onClick:e[1]||(e[1]=o=>Ye.value=!0)}," + 구역 추가 "),u("div",ws,[u("button",{class:Re(["mode-btn",{active:b.value==="floor"}]),onClick:e[2]||(e[2]=o=>ro("floor")),title:"평면배치모드 (P)"},e[42]||(e[42]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-a343cdd7><rect x="3" y="3" width="18" height="18" rx="2" data-v-a343cdd7></rect><rect x="7" y="7" width="4" height="4" data-v-a343cdd7></rect><rect x="13" y="7" width="4" height="4" data-v-a343cdd7></rect><rect x="7" y="13" width="4" height="4" data-v-a343cdd7></rect><rect x="13" y="13" width="4" height="4" data-v-a343cdd7></rect></svg><span data-v-a343cdd7>평면배치</span>',2)]),2),u("button",{class:Re(["mode-btn",{active:b.value==="front"}]),onClick:e[3]||(e[3]=o=>ro("front")),title:"정면배치모드 (F)"},e[43]||(e[43]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-a343cdd7><rect x="3" y="3" width="18" height="18" rx="2" data-v-a343cdd7></rect><line x1="3" y1="15" x2="21" y2="15" stroke-dasharray="2 2" data-v-a343cdd7></line><rect x="7" y="7" width="4" height="6" data-v-a343cdd7></rect><rect x="13" y="7" width="4" height="6" data-v-a343cdd7></rect></svg><span data-v-a343cdd7>정면배치</span>',2)]),2),u("button",{class:"mode-btn",onClick:kn,title:"그룹핑 결과 확인"},e[44]||(e[44]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("circle",{cx:"12",cy:"12",r:"3"}),u("path",{d:"M12 1v6m0 6v6"}),u("path",{d:"m21 12-6-3-6 3-6-3"})],-1),u("span",null,"그룹핑 확인",-1)])),b.value==="floor"||b.value==="front"?(M(),T("div",Ls,[u("button",{class:"zoom-btn",onClick:De,title:"모든 락커가 화면에 맞춤 (클릭)"},[e[45]||(e[45]=u("svg",{width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("rect",{x:"3",y:"3",width:"18",height:"18",rx:"2"}),u("path",{d:"M7 7h.01M7 12h.01M7 17h.01M12 7h.01M12 12h.01M12 17h.01M17 7h.01M17 12h.01M17 17h.01"})],-1)),u("span",null,N(Math.round(F.value*100))+"%",1)]),e[46]||(e[46]=u("div",{class:"zoom-hints",style:{display:"none"}},[u("span",{class:"hint"},"Ctrl+스크롤: 줌"),u("span",{class:"hint"},"휠클릭+드래그: 이동")],-1))])):V("",!0),u("button",{class:"mode-btn debug-btn",onClick:e[4]||(e[4]=o=>ot.value=!0),title:"락커 데이터 상세 확인",style:{display:"none"}},e[47]||(e[47]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("path",{d:"m9 12 2 2 4-4"}),u("path",{d:"M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"}),u("path",{d:"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"})],-1),u("span",null,"디버그 정보",-1)]))])])]),u("div",bs,[(M(),T("svg",{ref_key:"canvasRef",ref:yt,class:"canvas",width:"100%",height:"100%",viewBox:Yn.value,style:pt({cursor:On.value,margin:0,padding:0}),preserveAspectRatio:"xMidYMid meet",onWheel:se(Qo,["prevent"]),onMousedown:en,onMousemove:tn,onMouseup:ao,onMouseleave:ao,onClick:on},[e[49]||(e[49]=Ft('<defs data-v-a343cdd7><pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse" data-v-a343cdd7><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e5e5e5" stroke-width="0.5" data-v-a343cdd7></path></pattern><filter id="buttonShadow" x="-50%" y="-50%" width="200%" height="200%" data-v-a343cdd7><feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" data-v-a343cdd7></feDropShadow></filter></defs><rect width="100%" height="100%" fill="url(#grid)" class="canvas-background" data-v-a343cdd7></rect>',2)),O.value?(M(),T("rect",{key:0,x:"0",y:"0",width:Q.value,height:ee.value,fill:"none",stroke:"black","stroke-width":"1"},null,8,Ms)):V("",!0),b.value==="front"?(M(),T("g",Es,[u("line",{x1:0,y1:Le,x2:qe,y2:Le,stroke:"#94a3b8","stroke-width":"2","stroke-dasharray":"10,5"}),u("text",{x:U.value.x+20/F.value,y:Le+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500"}," 바닥선 ",8,ks),u("text",{x:U.value.x+(ce-80)/F.value,y:Le+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500","text-anchor":"end"}," 바닥선 ",8,Ts)])):V("",!0),(M(!0),T(re,null,ue(Ho.value,o=>{var n,a;return M(),We(zn,{key:o.id,locker:o,"is-selected":((n=L.value)==null?void 0:n.id)===o.id,"is-multi-selected":x.value.has(o.id),"should-hide-individual-outline":zo.value.has(o.id)&&!P.value,"is-dragging":P.value&&x.value.has(o.id),"adjacent-sides":Fo(o.id),"view-mode":b.value,"is-transitioning-to-floor":_t.value,"show-number":!0,"show-rotate-handle":((a=L.value)==null?void 0:a.id)===o.id,"zoom-level":F.value,onClick:(i,c)=>nn(i,c),onContextmenu:se(Ln,["prevent"]),onSelect:e[5]||(e[5]=i=>L.value=g.value.find(c=>c.id===i)),onDragstart:an,onRotatestart:ln,onRotate:rn,onRotateend:cn},null,8,["locker","is-selected","is-multi-selected","should-hide-individual-outline","is-dragging","adjacent-sides","view-mode","is-transitioning-to-floor","show-rotate-handle","zoom-level","onClick"])}),128)),rt.value.length>0&&!P.value?(M(),T("g",As,[(M(!0),T(re,null,ue(rt.value.filter(o=>o.length>1),(o,n)=>{var a,i,c,l;return M(),T("rect",{key:`group-${n}`,x:(((a=lt(o))==null?void 0:a.minX)||0)-5,y:(((i=lt(o))==null?void 0:i.minY)||0)-5,width:(((c=lt(o))==null?void 0:c.width)||0)+10,height:(((l=lt(o))==null?void 0:l.height)||0)+10,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"unified-selection-outline","pointer-events":"none"},e[48]||(e[48]=[u("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,Ds)}),128))])):V("",!0),L.value&&!P.value&&W.value?(M(),T("g",$s,[u("g",{transform:`translate(${to().x}, ${to().y}) rotate(${L.value.rotation||0}, ${L.value.width/2}, ${L.value.height/2})`},null,8,Ns)])):V("",!0),ze.value?(M(),T("g",_s,[(M(!0),T(re,null,ue(oo.value,o=>(M(),T("line",{key:`h-${o.position}`,x1:0,y1:o.position,x2:Q.value,y2:o.position,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,Ss))),128)),(M(!0),T(re,null,ue(no.value,o=>(M(),T("line",{key:`v-${o.position}`,x1:o.position,y1:0,x2:o.position,y2:ee.value,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,Rs))),128))])):V("",!0),we.value&&X.value.x!=null&&X.value.y!=null&&H.value.x!=null&&H.value.y!=null&&Math.abs((H.value.x||0)-(X.value.x||0))>5?(M(),T("rect",{key:5,x:Math.min(X.value.x||0,H.value.x||0),y:Math.min(X.value.y||0,H.value.y||0),width:Math.abs((H.value.x||0)-(X.value.x||0)),height:Math.abs((H.value.y||0)-(X.value.y||0)),fill:"rgba(0, 122, 255, 0.1)",stroke:"#007AFF","stroke-width":"1","stroke-dasharray":"5 5","pointer-events":"none",class:"selection-box"},null,8,Os)):V("",!0)],44,Cs))])])])])),Ye.value?(M(),We(Bn,{key:2,onClose:e[6]||(e[6]=o=>Ye.value=!1),onSave:_n})):V("",!0),Ie.value?(M(),We(jn,{key:3,onClose:e[7]||(e[7]=o=>Ie.value=!1),onSave:Sn})):V("",!0),Lt.value?(M(),T("div",{key:4,style:pt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:1e3}),class:"context-menu",onClick:e[8]||(e[8]=se(()=>{},["stop"]))},[b.value==="front"?(M(),T(re,{key:0},[u("div",{class:"context-menu-item",onClick:Cn},e[50]||(e[50]=[u("i",{class:"fas fa-layer-group"},null,-1),he(" 단수 입력 ",-1)])),u("div",{class:"context-menu-item",onClick:En},e[51]||(e[51]=[u("i",{class:"fas fa-sort-numeric-up"},null,-1),he(" 번호 부여 ",-1)])),u("div",{class:"context-menu-item",onClick:An},e[52]||(e[52]=[u("i",{class:"fas fa-eraser"},null,-1),he(" 번호 삭제 ",-1)]))],64)):V("",!0),u("div",{class:"context-menu-item",onClick:bn},e[53]||(e[53]=[u("i",{class:"fas fa-trash"},null,-1),he(" 락커 삭제 ",-1)]))],4)):V("",!0),tt.value?(M(),T("div",Ys,[u("div",{class:"modal-content",onClick:e[11]||(e[11]=se(()=>{},["stop"]))},[e[55]||(e[55]=u("h3",null,"단수 입력",-1)),u("div",Is,[e[54]||(e[54]=u("label",null,"단수:",-1)),fe(u("input",{ref_key:"floorInputRef",ref:Bt,"onUpdate:modelValue":e[9]||(e[9]=o=>ge.value=o),type:"number",min:"1",max:"9",placeholder:"1-9 사이 입력",class:"form-control",onInput:Mn,onKeyup:Mo(yo,["enter"])},null,544),[[Co,ge.value,void 0,{number:!0}]])]),u("div",Vs,[u("button",{class:"btn btn-secondary",onClick:e[10]||(e[10]=o=>tt.value=!1)},"취소"),u("button",{class:"btn btn-primary",onClick:yo},"확인")])])])):V("",!0),nt.value?(M(),T("div",Xs,[u("div",{class:"modal-content number-assign-modal",onClick:e[23]||(e[23]=se(()=>{},["stop"]))},[e[68]||(e[68]=u("h3",null,"번호 부여",-1)),u("div",Ps,[e[59]||(e[59]=u("div",{style:{display:"flex","justify-content":"space-between","margin-bottom":"10px"}},[u("label",null,"시작번호:"),u("label",{style:{"margin-right":"100px"}},"번호생성옵션:")],-1)),u("div",Fs,[fe(u("input",{ref_key:"startNumberInputRef",ref:jt,"onUpdate:modelValue":e[12]||(e[12]=o=>st.value=o),type:"number",min:1,placeholder:"시작 번호",class:"form-control number-input",style:{width:"120px"},onKeyup:Mo(xo,["enter"])},null,544),[[Co,st.value,void 0,{number:!0}]]),u("div",Ks,[u("label",Hs,[fe(u("input",{type:"radio","onUpdate:modelValue":e[13]||(e[13]=o=>J.value=o),value:"all"},null,512),[[Ze,J.value]]),e[56]||(e[56]=u("span",null,"전체",-1))]),u("label",zs,[fe(u("input",{type:"radio","onUpdate:modelValue":e[14]||(e[14]=o=>J.value=o),value:"odd"},null,512),[[Ze,J.value]]),e[57]||(e[57]=u("span",null,"홀수",-1))]),u("label",Bs,[fe(u("input",{type:"radio","onUpdate:modelValue":e[15]||(e[15]=o=>J.value=o),value:"even"},null,512),[[Ze,J.value]]),e[58]||(e[58]=u("span",null,"짝수",-1))])])])]),u("div",js,[e[62]||(e[62]=u("div",{class:"form-labels-row"},[u("label",{class:"section-label"},"생성방향:")],-1)),u("div",Gs,[u("div",Us,[u("label",Ws,[fe(u("input",{type:"radio","onUpdate:modelValue":e[16]||(e[16]=o=>ke.value=o),value:"horizontal"},null,512),[[Ze,ke.value]]),e[60]||(e[60]=u("span",null,"가로",-1))]),u("label",Zs,[fe(u("input",{type:"radio","onUpdate:modelValue":e[17]||(e[17]=o=>ke.value=o),value:"vertical"},null,512),[[Ze,ke.value]]),e[61]||(e[61]=u("span",null,"세로",-1))])])])]),u("div",qs,[e[65]||(e[65]=u("label",{class:"section-label"},"추가옵션:",-1)),u("div",Js,[u("div",Qs,[u("label",ea,[e[63]||(e[63]=u("span",{style:{"margin-right":"8px"}},"역방향",-1)),fe(u("input",{type:"checkbox","onUpdate:modelValue":e[18]||(e[18]=o=>Te.value=o),onChange:e[19]||(e[19]=o=>console.log("역방향:",Te.value)),style:{"margin-right":"5px"}},null,544),[[Eo,Te.value]]),u("span",ta,"("+N(Te.value?"활성":"비활성")+")",1)])]),u("div",null,[u("label",oa,[e[64]||(e[64]=u("span",{style:{"margin-right":"8px"}},"아래에서부터",-1)),fe(u("input",{type:"checkbox","onUpdate:modelValue":e[20]||(e[20]=o=>Ae.value=o),onChange:e[21]||(e[21]=o=>console.log("아래에서부터:",Ae.value)),style:{"margin-right":"5px"}},null,544),[[Eo,Ae.value]]),u("span",na,"("+N(Ae.value?"활성":"비활성")+")",1)])])])]),be.value?(M(),T("div",sa,[u("div",aa,[e[66]||(e[66]=u("div",{class:"loading-spinner"},null,-1)),u("span",ia,N(pe.value),1)])])):V("",!0),u("div",la,[u("button",{class:"btn btn-secondary",onClick:e[22]||(e[22]=o=>nt.value=!1),disabled:be.value}," 취소 ",8,ra),u("button",{class:"btn btn-primary",onClick:xo,disabled:be.value},[be.value?(M(),T("span",da,e[67]||(e[67]=[u("i",{class:"fas fa-spinner fa-spin"},null,-1),he(" 처리중... ",-1)]))):(M(),T("span",ua,"번호 부여"))],8,ca)])])])):V("",!0),Ve.value?(M(),T("div",{key:7,class:"modal-overlay",onClick:e[26]||(e[26]=o=>Ve.value=!1)},[u("div",{class:"modal-content grouping-popup",onClick:e[25]||(e[25]=se(()=>{},["stop"]))},[e[69]||(e[69]=u("h3",null,"대그룹 분석 결과",-1)),u("div",ha,[u("pre",null,N(wt.value),1)]),u("div",fa,[u("button",{class:"btn btn-primary",onClick:e[24]||(e[24]=o=>Ve.value=!1)},"확인")])])])):V("",!0),ot.value?(M(),T("div",{key:8,class:"modal-overlay",onClick:e[30]||(e[30]=o=>ot.value=!1)},[u("div",{class:"modal-content debug-popup",onClick:e[29]||(e[29]=se(()=>{},["stop"]))},[e[76]||(e[76]=u("h3",null,"🔍 락커 데이터 디버깅 정보",-1)),u("div",va,[e[74]||(e[74]=u("h4",null,"📊 전체 통계",-1)),u("div",ga,[u("div",pa,[e[70]||(e[70]=u("span",{class:"label"},"Store 전체:",-1)),u("span",ma,N(Kt(A).lockers.length)+"개",1)]),u("div",ya,[e[71]||(e[71]=u("span",{class:"label"},"현재 구역:",-1)),u("span",xa,N(g.value.length)+"개",1)]),u("div",wa,[e[72]||(e[72]=u("span",{class:"label"},"뷰모드:",-1)),u("span",La,N(b.value),1)]),u("div",ba,[e[73]||(e[73]=u("span",{class:"label"},"선택 구역:",-1)),u("span",Ca,N(((s=O.value)==null?void 0:s.name)||"None"),1)])])]),u("div",Ma,[u("h4",null,"🏢 Store 전체 락커 ("+N(Kt(A).lockers.length)+"개)",1),u("div",Ea,[(M(!0),T(re,null,ue(Kt(A).lockers,o=>(M(),T("div",{key:o.id,class:Re(["locker-item",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",ka,[u("span",Ta,N(o.number),1),u("span",Aa,N(o.parentLockrCd?"자식":"부모"),1)]),u("div",Da,[u("span",null,"ID: "+N(o.id),1),u("span",null,"Zone: "+N(o.zoneId),1),u("span",null,"Parent: "+N(o.parentLockrCd||"None"),1),u("span",null,"Height: "+N(o.actualHeight||o.height)+"px",1)])],2))),128))])]),u("div",$a,[u("h4",null,"👁️ 현재 표시 락커 ("+N(g.value.length)+"개)",1),u("div",Na,[(M(!0),T(re,null,ue(g.value,o=>(M(),T("div",{key:o.id,class:Re(["locker-item current",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",_a,[u("span",Sa,N(o.number),1),u("span",Ra,N(o.parentLockrCd?"자식":"부모"),1),e[75]||(e[75]=u("span",{class:"render-status"},"표시중",-1))]),u("div",Oa,[u("span",null,"위치: ("+N(o.x)+", "+N(o.y)+")",1),u("span",null,"크기: "+N(o.width)+"x"+N(o.height),1),u("span",null,"실제높이: "+N(o.actualHeight)+"px",1),u("span",null,"회전: "+N(o.rotation)+"°",1)])],2))),128))])]),u("div",Ya,[u("button",{class:"btn btn-secondary",onClick:e[27]||(e[27]=o=>de())},"🔄 새로고침"),u("button",{class:"btn btn-primary",onClick:e[28]||(e[28]=o=>ot.value=!1)},"닫기")])])])):V("",!0),(M(),We(ko,{to:"body"},[Qe.value?(M(),T("div",{key:0,class:"zone-context-menu",style:pt({position:"fixed",left:bt.value.x+"px",top:bt.value.y+"px",zIndex:9999}),onClick:e[33]||(e[33]=se(()=>{},["stop"]))},[u("div",{class:"zone-context-menu-item",onClick:e[31]||(e[31]=o=>t.editZone(Ct.value))},e[77]||(e[77]=[u("span",{class:"zone-context-menu-icon"},"✏️",-1),he(" 구역 수정 ",-1)])),u("div",{class:"zone-context-menu-item",onClick:e[32]||(e[32]=o=>jo(Ct.value))},e[78]||(e[78]=[u("span",{class:"zone-context-menu-icon"},"🗑️",-1),he(" 구역 삭제 ",-1)]))],4)):V("",!0)])),(M(),We(ko,{to:"body"},[et.value?(M(),T("div",{key:0,class:"context-menu",style:pt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:9999}),onClick:e[35]||(e[35]=se(()=>{},["stop"]))},[u("div",{class:"context-menu-item",onClick:e[34]||(e[34]=o=>so(zt.value))},e[79]||(e[79]=[u("span",{class:"context-menu-icon"},"🗑️",-1),he(" 타입 삭제 ",-1)]))],4)):V("",!0)]))])}}}),Ka=Kn(Ia,[["__scopeId","data-v-a343cdd7"]]);export{Ka as default};
