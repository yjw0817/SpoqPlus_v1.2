import{d as In,r as m,c as ie,w as vt,o as Vn,n as le,a as Xn,b as T,e as M,f as We,g as V,h as u,F as re,i as de,j as se,k as Re,t as _,l as ue,m as Ft,p as gt,q as he,v as Lo,s as bo,u as Ze,x as Co,y as Kt,T as Eo,_ as Pn}from"./index.js";import{u as Fn,L as Kn,Z as Hn,a as zn,i as Bn,g as jn}from"./LockerRegistrationModal.js";const Gn={class:"locker-placement"},Un={key:0,class:"loading-overlay"},Wn={key:1,class:"main-content"},Zn={class:"container"},qn={class:"sidebar"},Jn={key:0,class:"loading-state"},Qn={key:1,class:"empty-state"},es={key:2,class:"locker-types"},ts=["onClick","onDblclick","onContextmenu"],os={class:"type-visual"},ns=["width","height","viewBox"],ss=["width","height","fill"],as=["y1","x2","y2","stroke"],is={class:"type-info"},ls={class:"type-name"},rs={class:"type-size"},cs=["onClick"],ds={key:3,class:"deleted-types-section"},us=["onClick"],hs={class:"canvas-area"},fs={class:"zone-tabs"},vs={class:"zone-tab-group"},gs=["onClick","onContextmenu"],ps={key:0,class:"tab-indicator"},ms={class:"zone-controls"},ys={class:"mode-toggle-inline"},xs={key:0,class:"zoom-controls"},ws={class:"canvas-wrapper"},Ls=["viewBox"],bs=["width","height"],Cs={key:1},Es=["x","y","font-size"],Ms=["x","y","font-size"],ks={key:2,class:"unified-outlines"},As=["x","y","width","height"],Ts={key:3},Ds=["transform"],$s={key:4,class:"alignment-guides"},Ns=["y1","x2","y2"],_s=["x1","x2","y2"],Ss=["x","y","width","height"],Rs={key:5,class:"modal-overlay"},Os={class:"form-group"},Ys={class:"modal-buttons"},Is={key:6,class:"modal-overlay"},Vs={class:"form-group"},Xs={style:{display:"flex","justify-content":"space-between","align-items":"flex-start"}},Ps={class:"radio-group-horizontal",style:{flex:"1","margin-left":"20px"}},Fs={class:"radio-label"},Ks={class:"radio-label"},Hs={class:"radio-label"},zs={class:"form-section"},Bs={class:"form-options-row"},js={class:"radio-group-horizontal"},Gs={class:"radio-label"},Us={class:"radio-label"},Ws={class:"form-section"},Zs={style:{"margin-top":"10px"}},qs={style:{"margin-bottom":"8px"}},Js={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},Qs={style:{"font-size":"12px",color:"#666"}},ea={style:{display:"inline-flex","align-items":"center",cursor:"pointer"}},ta={style:{"font-size":"12px",color:"#666"}},oa={key:0,class:"progress-section"},na={class:"progress-indicator"},sa={class:"progress-text"},aa={class:"modal-buttons"},ia=["disabled"],la=["disabled"],ra={key:0},ca={key:1},da={class:"grouping-results"},ua={class:"modal-buttons"},ha={class:"debug-section"},fa={class:"debug-stats"},va={class:"stat-item"},ga={class:"value"},pa={class:"stat-item"},ma={class:"value"},ya={class:"stat-item"},xa={class:"value"},wa={class:"stat-item"},La={class:"value"},ba={class:"debug-section"},Ca={class:"locker-list"},Ea={class:"locker-header"},Ma={class:"locker-name"},ka={class:"locker-type"},Aa={class:"locker-details"},Ta={class:"debug-section"},Da={class:"locker-list"},$a={class:"locker-header"},Na={class:"locker-name"},_a={class:"locker-type"},Sa={class:"locker-details"},Ra={class:"modal-buttons"},Mo=1,ko=1,we=1250,qe=3100,pt=1440,fe=1350,Le=670,Ao=5,To=55,Oa=In({__name:"LockerPlacementFigma",setup(Ya){const D=Fn(),Y=m(null),Oe=m(null),w=m(null),Do=m(!1),mt=m(null),Ye=m(!1),Ie=m(!1),P=m(!1),Je=m({x:0,y:0}),L=m("floor"),Z=m(!0),yt=m(!1),Ht=m([]),$o=m({isSelecting:!1,startX:0,startY:0,endX:0,endY:0}),Ve=m(!1),xt=m(""),wt=m(!1),Xe=m({x:0,y:0}),Qe=m(!1),Lt=m({x:0,y:0}),bt=m(null),et=m(!1),No=m({x:0,y:0}),zt=m(null),tt=m(!1),ve=m(1),Bt=m(null),jt=m(null),ot=m(!1),nt=m(!1),st=m(1),J=m("all"),ke=m("horizontal"),Ae=m(!1),Te=m(!1),be=m(!1),ge=m(""),pe=()=>L.value==="floor"?Mo:ko,Q=m(qe),ee=m(pt);m(1550),m(700);const F=m(1),Gt=Math.max(fe/qe,Le/pt),Ut=Math.min(qe/fe,pt/Le),W=m({x:0,y:0}),Pe=m(!1),at=m({x:0,y:0}),Ct=()=>{if(ye.value||Fe.value)return;const t=document.querySelector(".canvas-wrapper");if(t){const e=t.getBoundingClientRect();e.width,e.height}},_o=(t,e)=>{const s=pe();return{x:t*s,y:e*s}},So=(t,e)=>{const s=pe();return{width:t*s,height:e*s}},Ce=ie(()=>D.zones),me=m([]);m(!1);const ye=m(!0),Fe=m(!0),Wt=m(!1),Et=m(null);m(null);const U=(()=>{if(Bn()){const t=jn();return t?`${t.baseUrl}/api`:"/api"}return"http://localhost:3333/api"})(),Mt=async()=>{try{const t=await fetch(`${U}/zones`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.zones){const s=e.zones.map(o=>({id:o.LOCKR_KND_CD,name:o.LOCKR_KND_NM,x:o.X,y:o.Y,width:o.WIDTH,height:o.HEIGHT,color:o.COLOR,floor:o.FLOOR,...o}));D.zones=s}else console.warn("[API] No zones data in response:",e),D.zones=[]}catch(t){console.error("[API] Failed to load zones:",t.message),D.zones=[]}},ce=async()=>{try{const e=L.value==="floor"?`${U}/lockrs?parentOnly=true`:`${U}/lockrs`,s=await fetch(e);if(!s.ok)throw new Error(`HTTP ${s.status}: ${s.statusText}`);const o=await s.json();if(o.lockers&&o.lockers.forEach(n=>{const i=n.PARENT_LOCKR_CD===null?"PARENT":`CHILD of ${n.PARENT_LOCKR_CD}`}),o.success&&o.lockers){const n=o.lockers.map(a=>{const i=me.value.find(v=>v.id===a.LOCKR_TYPE_CD),c=(i==null?void 0:i.width)||40,l=(i==null?void 0:i.height)||60,d=(i==null?void 0:i.depth)||40,r=a.PARENT_LOCKR_CD?`locker-${a.PARENT_LOCKR_CD}`:null;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X!==null&&a.X!==void 0?a.X:void 0,y:a.Y!==null&&a.Y!==void 0?a.Y:void 0,width:c,height:d,depth:d,actualHeight:l,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockerId:r,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});D.lockers=n,D.lockers.forEach(a=>{const c=!a.parentLockrCd?"PARENT":`CHILD of ${a.parentLockrCd}`}),n.forEach(a=>{a.number==="L3"||a.number==="L4"||a.number==="L1"||a.number==="L2"||a.number})}else if(o.lockers){const n=o.lockers.map(a=>{const i=me.value.find(l=>l.id===a.LOCKR_TYPE_CD),c=(i==null?void 0:i.height)||60;return{id:`locker-${a.LOCKR_CD}`,lockrCd:a.LOCKR_CD,number:a.LOCKR_LABEL||`L${a.LOCKR_CD}`,x:a.X||0,y:a.Y||0,width:(i==null?void 0:i.width)||40,height:(i==null?void 0:i.depth)||40,depth:(i==null?void 0:i.depth)||40,actualHeight:c,status:"available",rotation:a.ROTATION||0,zoneId:a.LOCKR_KND,typeId:a.LOCKR_TYPE_CD,type:a.LOCKR_TYPE_CD,color:i==null?void 0:i.color,compCd:a.COMP_CD,bcoffCd:a.BCOFF_CD,lockrLabel:a.LOCKR_LABEL,lockrNo:a.LOCKR_NO,lockrKnd:a.LOCKR_KND,lockrTypeCd:a.LOCKR_TYPE_CD,frontViewX:a.FRONT_VIEW_X,frontViewY:a.FRONT_VIEW_Y,frontViewNumber:a.FRONT_VIEW_NUMBER,parentLockrCd:a.PARENT_LOCKR_CD,tierLevel:a.TIER_LEVEL,lockrStat:a.LOCKR_STAT}});D.lockers=n}else console.warn("[API] No lockers data in response:",o),D.lockers=[]}catch(t){console.error("[API] Failed to load lockers:",t.message),D.lockers=[]}},Zt=async()=>{try{ye.value=!0;const t=await fetch(`${U}/types`);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const e=await t.json();if(e.success){const s=(e.types||[]).map(o=>({id:o.LOCKR_TYPE_CD,name:o.LOCKR_TYPE_NM,width:o.WIDTH,height:o.HEIGHT,depth:o.DEPTH,color:o.COLOR||"#3b82f6",type:o.LOCKR_TYPE_CD}));me.value=s}}catch(t){console.error("Failed to load locker types:",t),me.value=[]}finally{ye.value=!1,Wt.value=!0}},Ro=async t=>{try{const e=await fetch(`${U}/zones`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save zone");const s=await e.json();if(s.success)return await Mt(),s}catch(e){throw console.error("[API] Zone save failed:",e),Et.value="Failed to save zone",e}},kt=async t=>{try{const e=await fetch(`${U}/lockrs`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!e.ok)throw new Error("Failed to save locker");const s=await e.json();if(s.success)return await ce(),s}catch(e){throw console.error("[API] Locker save failed:",e),Et.value="Failed to save locker",e}},qt=async(t,e)=>{try{const s=await fetch(`${U}/lockrs/${t}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(!s.ok){const n=await s.text();throw new Error(`Failed to update locker placement: ${s.status} - ${n}`)}const o=await s.json();if(o.success)return o}catch(s){throw console.error("[API] Locker placement update failed:",s),Et.value="Failed to update locker placement",s}},Oo=async t=>{try{const e=await fetch(`${U}/lockrs/batch-numbers`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({updates:t})});if(!e.ok){const o=await e.text();throw new Error(`Failed to batch update locker numbers: ${e.status} - ${o}`)}const s=await e.json();if(s.success)return s;throw new Error(`Batch update failed: ${s.message||"Unknown error"}`)}catch(e){throw console.error("[API] Batch locker number update failed:",e),e}},Yo=async t=>{try{const e=t.map(s=>{var i;const o=g.value.find(c=>c.id===s.id),n=Math.round(s.x*100)/100,a=Math.round(s.y*100)/100;if(o&&o.lockrCd)return qt(o.lockrCd,{X:n,Y:a});if(o){const c={LOCKR_KND:(i=Y.value)==null?void 0:i.id,LOCKR_TYPE_CD:o.type||"1",X:n,Y:a,LOCKR_LABEL:o.number,ROTATION:o.rotation||0,LOCKR_STAT:"00"};return kt(c).then(l=>(l&&l.lockrCd&&(o.lockrCd=l.lockrCd),l))}});await Promise.all(e)}catch(e){console.error("[API] Failed to save some locker positions:",e)}},Ke=m([]),it=t=>{if(t.length<=1)return null;const e=2,s=t.map(c=>{const l=L.value==="front"?c.actualHeight||c.height||60:c.depth||c.height||40,d=L.value==="front"&&c.frontViewX!==void 0?c.frontViewX:c.x,r=L.value==="front"&&c.frontViewY!==void 0?c.frontViewY:c.y;return{left:d,right:d+c.width*e,top:r,bottom:r+l*e,locker:c}}),o=Math.min(...s.map(c=>c.left)),n=Math.max(...s.map(c=>c.right)),a=Math.min(...s.map(c=>c.top)),i=Math.max(...s.map(c=>c.bottom));return{minX:o,maxX:n,minY:a,maxY:i,width:n-o,height:i-a}},Io=(t,e,s=5)=>{const n=L.value==="front"?t.actualHeight||t.height||60:t.depth||t.height||40,a=L.value==="front"?e.actualHeight||e.height||60:e.depth||e.height||40,i=A=>L.value==="front"?{x:A.frontViewX!==void 0?A.frontViewX:A.x,y:A.frontViewY!==void 0?A.frontViewY:A.y}:{x:A.x,y:A.y},c=i(t),l=i(e),d={left:c.x,right:c.x+t.width*2,top:c.y,bottom:c.y+n*2},r={left:l.x,right:l.x+e.width*2,top:l.y,bottom:l.y+a*2},h=s,v=Math.min(Math.abs(d.right-r.left),Math.abs(r.right-d.left)),f=Math.min(Math.abs(d.bottom-r.top),Math.abs(r.bottom-d.top))<=h,b=d.left<r.right&&r.left<d.right,N=v<=h,p=d.top<r.bottom&&r.top<d.bottom;return f&&b||N&&p},Vo=t=>{const e=[],s=new Set,o=(n,a)=>{s.has(n.id)||(s.add(n.id),a.push(n),t.forEach(i=>{!s.has(i.id)&&Io(n,i)&&o(i,a)}))};return t.forEach(n=>{if(!s.has(n.id)){const a=[];o(n,a),e.push(a)}}),e},Xo=t=>{if(!y.value.has(t))return[];const e=g.value.find(d=>d.id===t);if(!e)return[];const s=[],o=10,n=ae(e),a=(e.rotation||0)%360,i={0:{top:"top",right:"right",bottom:"bottom",left:"left"},90:{top:"left",right:"top",bottom:"right",left:"bottom"},180:{top:"bottom",right:"left",bottom:"top",left:"right"},270:{top:"right",right:"bottom",bottom:"left",left:"top"}},c=Math.round(a/90)*90%360,l=i[c]||i[0];return Jt.value.forEach(d=>{if(d.id===t)return;const r=ae(d);P.value&&console.log(`[Adjacent Check] ${t} vs ${d.id}:`,{locker:{id:t,rotation:a,bounds:n},other:{id:d.id,rotation:d.rotation,bounds:r},mapping:l}),Math.abs(n.y-(r.y+r.height))<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&(s.push(l.top),P.value&&console.log("  -> TOP adjacent (physical top touches other's bottom)")),Math.abs(n.y+n.height-r.y)<o&&n.x<r.x+r.width&&n.x+n.width>r.x&&s.push(l.bottom),Math.abs(n.x-(r.x+r.width))<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.left),Math.abs(n.x+n.width-r.x)<o&&n.y<r.y+r.height&&n.y+n.height>r.y&&s.push(l.right)}),[...new Set(s)]},At=ie(()=>me.value.filter(t=>!Ke.value.includes(t.id))),g=ie(()=>{if(!Y.value)return[];let t=D.lockers.filter(e=>e.zoneId===Y.value.id);return L.value==="floor"&&(t=t.filter(e=>!e.parentLockrCd)),t.forEach(e=>{!e.parentLockrCd||`${e.parentLockrCd}`}),t}),Po=ie(()=>g.value.map((e,s)=>{let o,n,a;const i=e.actualHeight||e.height||60;if(L.value==="floor"){const l=_o(e.x,e.y);o=l.x,n=l.y,a=So(e.width,e.height||e.depth||40).height}else{const l=pe();if(e.frontViewX!==void 0&&e.frontViewX!==null&&e.frontViewY!==void 0&&e.frontViewY!==null)o=e.frontViewX*l,n=e.frontViewY*l,a=i*l;else if(e.x!==void 0&&e.x!==null&&e.y!==void 0&&e.y!==null){const d=400+s*80,r=200;o=d,n=r,a=i*l}else o=100+s*100,n=100,a=i*l}const c=e.width*pe();return{...e,displayX:o,displayY:n,displayWidth:c,displayHeight:a,actualHeight:e.actualHeight||i||60,logicalX:e.x,logicalY:e.y,logicalWidth:e.width,logicalHeight:e.height||e.depth||40}})),Fo=ie(()=>{const t=Po.value.map(e=>{if(L.value==="front"){const s=e.actualHeight||e.height||60,o=e.displayX/pe(),n=e.displayY/pe(),a=e.frontViewRotation!==void 0?e.frontViewRotation:0;return e.x===o&&e.y===n&&e.height===s&&e.rotation===a?e:{...e,x:o,y:n,height:s,actualHeight:s,rotation:a}}return e});if(L.value==="front")return t;if(w.value){const e=t.findIndex(s=>s.id===w.value.id);if(e>-1){const[s]=t.splice(e,1);t.push(s)}}return t}),Jt=ie(()=>g.value.filter(t=>y.value.has(t.id))),lt=ie(()=>Vo(Jt.value)),Ko=ie(()=>{const t=new Set;return lt.value.forEach(e=>{e.length>1&&e.forEach(s=>t.add(s.id))}),t});m(!1),m([]);const Qt=()=>{if(!w.value)return{x:0,y:0};const t=g.value.find(e=>e.id===w.value.id);return t?L.value==="front"?{x:t.frontViewX!==void 0?t.frontViewX:t.x,y:t.frontViewY!==void 0?t.frontViewY:t.y}:{x:t.x,y:t.y}:{x:w.value.x,y:w.value.y}},te=t=>{if(!t)return{width:0,height:0};const e=2;return L.value==="floor"?{width:(t.width||40)*e,height:(t.depth||t.height||40)*e}:{width:(t.width||40)*e,height:(t.actualHeight||t.height||60)*e}},He=m(!1),rt=m(!1),Ee=m([]),y=m(new Set),Tt=m(null),xe=m(!1),X=m({x:0,y:0}),H=m({x:0,y:0}),oe=m([]),Dt=m(!1),ct=m(!1);m([]);const ze=m(!1),eo=m([]),to=m([]),Be=async t=>{Y.value=t,w.value=null,L.value==="front"&&(console.log("[Zone Change] Loading lockers for zone in front view mode..."),await ce(),le(()=>{g.value.some(s=>s.frontViewX==null||s.frontViewY==null)?(console.log("[Zone Change] Found lockers without front view coordinates, recalculating..."),_e()):console.log("[Zone Change] All lockers have front view coordinates")})),setTimeout(()=>{De()},100)},Ho=(t,e)=>{t.preventDefault(),t.stopPropagation(),bt.value=e,Lt.value={x:t.clientX,y:t.clientY},Qe.value=!0;const s=()=>{Qe.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},zo=async t=>{var e;try{const s=g.value.filter(c=>c.LOCKR_KND===t.id||c.zoneId===t.id||c.LOCKR_KND===t.LOCKR_KND_CD);if(s.length>0){alert(`구역 삭제 불가

이 구역에 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`구역 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=t.LOCKR_KND_CD||t.id,n=`${U}/zones/${o}`,a=await fetch(n,{method:"DELETE"});if(!a.ok){const c=await a.json();throw new Error(c.message||"Failed to delete zone")}(await a.json()).success&&(await Mt(),((e=Y.value)==null?void 0:e.id)===t.id&&(Ce.value.length>0?Be(Ce.value[0]):Y.value=null),alert("구역이 성공적으로 삭제되었습니다."))}catch(s){console.error("[API] Zone deletion failed:",s),alert(`구역 삭제 중 오류가 발생했습니다:
${s.message}`)}finally{Qe.value=!1}},Bo=(t,e)=>{t.preventDefault(),zt.value=e,No.value={x:t.clientX,y:t.clientY},et.value=!0;const s=()=>{et.value=!1,document.removeEventListener("click",s)};document.addEventListener("click",s)},oo=async t=>{var e;try{const s=g.value.filter(a=>a.LOCKR_TYPE_CD===t.id||a.type===t.id);if(s.length>0){alert(`타입 삭제 불가

이 타입으로 ${s.length}개의 락커가 배치되어 있습니다.
먼저 모든 락커를 제거해주세요.`);return}if(!confirm(`락커 타입 "${t.name}"을(를) 삭제하시겠습니까?

이 작업은 되돌릴 수 없습니다.`))return;const o=await fetch(`${U}/types/${t.id}`,{method:"DELETE"});if(!o.ok){const a=await o.json();throw new Error(a.message||"Failed to delete locker type")}(await o.json()).success&&(await Zt(),((e=Oe.value)==null?void 0:e.id)===t.id&&(Oe.value=null),et.value=!1)}catch(s){console.error("Failed to delete locker type:",s),alert("락커 타입 삭제에 실패했습니다.")}},jo=t=>{Oe.value=t},Go=(t,e,s,o)=>{let n=t,a=e;n=Math.round(n/20)*20,a=Math.round(a/20)*20;let i=0;const c=50;for(;i<c;){if(!Ot(n,a,s,o,null,0,!1))return{x:n,y:a};n+=20,n>Q.value-s-100&&(n=t,a+=20,a>ee.value-o-100&&(a=100,t+=20,n=t)),i++}return console.warn("[Direct Add] Could not find collision-free position, using default"),{x:t,y:e}},Uo=async t=>{if(L.value!=="floor"){alert("평면배치모드에서만 락커를 추가할 수 있습니다.");return}if(!Y.value){alert("구역을 선택해주세요.");return}Oe.value=t;const e=100,s=Math.round(ee.value/3),o=Go(e,s,t.width,t.depth||t.width),n=yo(o.x,o.y,t.width,t.depth||t.width),a={id:`locker-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,name:t.name,x:n.x,y:n.y,width:t.width,height:t.depth||t.width,depth:t.depth||t.width,actualHeight:t.height,color:t.color,rotation:0,type:t.name,status:"available",number:Rt(),zoneId:Y.value.id};let i=null;try{const l={LOCKR_KND:Y.value.id,LOCKR_TYPE_CD:t.id||t.type,X:a.x,Y:a.y,LOCKR_LABEL:a.number,ROTATION:a.rotation||0,LOCKR_STAT:"00"},d=await kt(l);d&&d.lockrCd&&(await ce(),De(),i=g.value.find(r=>r.x===a.x&&r.y===a.y&&r.number===a.number))}catch(l){console.error("[Database] Failed to save locker:",l),i=D.addLocker(a)}i&&(w.value=i,y.value.clear(),y.value.add(i.id),Z.value=!0),_n();const c=window.event;if(c&&c.currentTarget){const l=c.currentTarget;l.classList.add("pulse-animation"),setTimeout(()=>l.classList.remove("pulse-animation"),300)}},Wo=t=>{const e=Ke.value.indexOf(t);e>-1&&Ke.value.splice(e,1)},Zo=t=>{const e=me.value.find(s=>s.type===t);return e?e.name:t},je=t=>{const e=mt.value;if(!e)return{x:0,y:0};const s=e.createSVGPoint();s.x=t.clientX,s.y=t.clientY;const o=s.matrixTransform(e.getScreenCTM().inverse());return pe(),{x:Math.round(o.x*100)/100,y:Math.round(o.y*100)/100}},qo=t=>{if(L.value!=="floor"&&L.value!=="front"||!t.ctrlKey)return;t.preventDefault();const s=t.currentTarget.getBoundingClientRect(),o=(t.clientX-s.left)/s.width,n=(t.clientY-s.top)/s.height,a=fe/F.value,i=Le/F.value,c=W.value.x+o*a,l=W.value.y+n*i,d=t.deltaY>0?.9:1.1,r=Math.min(Math.max(F.value*d,Gt),Ut);if(r!==F.value){const h=fe/r,v=Le/r,x={x:c-o*h,y:l-n*v};W.value=$t(x,r),F.value=r}},$t=(t,e)=>{const s=fe/e,o=Le/e,n=0,a=0,i=Math.max(0,qe-s),c=Math.max(0,pt-o);return{x:Math.max(n,Math.min(i,t.x)),y:Math.max(a,Math.min(c,t.y))}},De=()=>{if(console.log("[AutoFit] Starting autoFitLockers...",{lockersCount:g.value.length,viewMode:L.value}),g.value.length===0){console.log("[AutoFit] No lockers found, using default zoom"),F.value=1,W.value={x:0,y:0};return}let t=1/0,e=1/0,s=-1/0,o=-1/0;const n=2;if(g.value.forEach(C=>{if(C.parentLockerId)return;let A,S,$,z;if(L.value==="floor")A=C.x,S=C.y,$=C.x+(C.width||40)*n,z=C.y+(C.depth||C.height||40)*n;else if(L.value==="front")A=C.frontViewX!==void 0?C.frontViewX:C.x,S=C.frontViewY!==void 0?C.frontViewY:C.y,$=A+(C.width||40)*n,z=S+(C.actualHeight||C.height||60)*n;else return;t=Math.min(t,A),e=Math.min(e,S),s=Math.max(s,$),o=Math.max(o,z)}),t===1/0||e===1/0){F.value=1,W.value={x:0,y:0};return}const a=s-t,i=o-e,c=.3,l=a*(1+c),d=i*(1+c),r=fe/l,h=Le/d;let v=Math.min(r,h);v=v*.729,v=Math.max(Gt,Math.min(v,Ut));const x=(t+s)/2,f=(e+o)/2,b=fe/(2*v),N=Le/(2*v);F.value=v;const p={x:x-b,y:f-N};W.value=$t(p,v),console.log("[AutoFit]",L.value,"mode - Zoom:",v,"Pan:",W.value,"Bounds:",{minX:t,minY:e,maxX:s,maxY:o})},Jo=t=>{if((L.value==="floor"||L.value==="front")&&t.button===1){t.preventDefault(),Pe.value=!0,at.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y,n=t.target;!(n.closest("[data-locker-id]")||n.tagName==="rect"&&!n.classList.contains("canvas-background")||n.tagName==="text"||n.tagName==="g"&&n.querySelector("text"))&&(n.tagName==="svg"||n.classList.contains("canvas-background")||n.getAttribute("fill")==="url(#grid)"||n.classList.contains("selection-box"))&&!P.value&&(xe.value=!0,X.value={x:s,y:o},H.value={x:s,y:o},y.value.clear(),w.value=null,t.preventDefault(),t.stopPropagation())},Qo=t=>{if((L.value==="floor"||L.value==="front")&&Pe.value){const n=(t.clientX-at.value.x)/F.value,a=(t.clientY-at.value.y)/F.value,i={x:W.value.x-n,y:W.value.y-a};W.value=$t(i,F.value),at.value={x:t.clientX,y:t.clientY};return}const e=je(t),s=e.x,o=e.y;xe.value?(H.value={x:s,y:o},Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Ao&&so()):P.value&&rn(t)},no=t=>{if((L.value==="floor"||L.value==="front")&&Pe.value){Pe.value=!1;return}if(!(He.value||rt.value)){if(xe.value){const e=je(t),s=e.x,o=e.y;Math.sqrt(Math.pow(s-X.value.x,2)+Math.pow(o-X.value.y,2))>Ao?(so(),Dt.value=!0,y.value.size>0&&(Z.value=!0),setTimeout(()=>{Dt.value=!1},100)):He.value||(y.value.clear(),w.value=null),xe.value=!1,X.value={x:0,y:0},H.value={x:0,y:0}}P.value&&cn()}},so=()=>{if(!X.value||!H.value||X.value.x==null||X.value.y==null||H.value.x==null||H.value.y==null){console.warn("[Rectangle Select] Invalid coordinates, skipping selection update");return}const t=Math.min(X.value.x,H.value.x),e=Math.max(X.value.x,H.value.x),s=Math.min(X.value.y,H.value.y),o=Math.max(X.value.y,H.value.y);if(y.value.clear(),g.value.forEach(n=>{let a,i,c,l;if(L.value==="front"){const r=n.frontViewX!==void 0?n.frontViewX:n.x,h=n.frontViewY!==void 0?n.frontViewY:n.y,v=te(n);a=r,i=r+v.width,c=h,l=h+v.height}else{const r=te(n);a=n.x,i=n.x+r.width,c=n.y,l=n.y+r.height}!(i<t||a>e||l<s||c>o)&&y.value.add(n.id)}),y.value.size>0){const n=Array.from(y.value)[0];w.value=g.value.find(a=>a.id===n),Z.value=!0}else w.value=null},en=t=>{if(Dt.value||ct.value||rt.value)return;const e=t.target,s=e.tagName==="svg"||e.classList.contains("canvas-background")||e.tagName==="rect"&&e.getAttribute("fill")==="url(#grid)"||e.classList.contains("canvas");if(s&&!t.ctrlKey&&!t.shiftKey&&!t.metaKey){w.value=null,y.value.clear(),D.selectLocker(null),Z.value=!1;return}if(s&&(t.shiftKey||t.ctrlKey)){const o=mt.value.getBoundingClientRect();$o.value={isSelecting:!0,startX:t.clientX-o.left,startY:t.clientY-o.top,endX:t.clientX-o.left,endY:t.clientY-o.top},console.log("[Selection] Drag selection started");return}},tn=(t,e)=>{var s;if(console.log("[Selection] Attempting to select in mode:",L.value,"Locker:",t.id),ct.value){console.log("[Select] Ignored - drag just finished");return}if(xe.value){console.log("[Select] Ignored - drag selection in progress");return}if(!P.value){if(e&&(e.ctrlKey||e.metaKey)){if(y.value.has(t.id)){if(y.value.delete(t.id),((s=w.value)==null?void 0:s.id)===t.id){const o=Array.from(y.value);w.value=o.length>0?g.value.find(n=>n.id===o[0]):null}}else y.value.add(t.id),w.value=t;Z.value=!0,console.log(`[Selection] Toggle select ${t.id}, total: ${y.value.size}`)}else e&&e.shiftKey&&Tt.value?(on(Tt.value,t),Z.value=!0):(y.value.clear(),y.value.add(t.id),w.value=t,console.log("[Selection UI] Rotation applied:",{lockerRotation:t.rotation||0,buttonPositions:{left:{x:t.width/2-15,y:-30},right:{x:t.width/2+15,y:-30},delete:{x:t.width+15,y:-15}},rotationCenter:{x:t.width/2,y:t.height/2}}));Tt.value=t,D.selectLocker(t.id),Z.value=!0,console.log("[Select] Selection updated - Count:",y.value.size,"IDs:",Array.from(y.value),"ShowUI:",Z.value)}},on=(t,e)=>{const s=g.value.findIndex(i=>i.id===t.id),o=g.value.findIndex(i=>i.id===e.id);if(s===-1||o===-1)return;const n=Math.min(s,o),a=Math.max(s,o);y.value.clear();for(let i=n;i<=a;i++)y.value.add(g.value[i].id);w.value=e,console.log(`[Selection] Range select from ${t.id} to ${e.id}, total: ${y.value.size}`)},nn=(t,e)=>{if(L.value==="front")return;if(!t||xe.value){console.log("[Drag] Ignored - drag selection in progress");return}P.value=!0,Z.value=!1;const s=e.ctrlKey||e.metaKey;console.log("[Multi-Select] Copying with drag:",s),console.log("[Drag] Started - hiding selection UI");let o=t;if(s){const l=new Map;if(Array.from(y.value).forEach(d=>{const r=g.value.find(h=>h.id===d);if(r){const h={...r,id:`locker-${Date.now()}-${Math.random()}`,number:"",x:r.x+20,y:r.y+20},v=D.addLocker(h);D.updateLocker(v.id,{lockrNo:Rt()}),l.set(r.id,v.id)}}),l.size>0){if(l.has(t.id)){const d=l.get(t.id);o=g.value.find(r=>r.id===d)}y.value.clear(),l.forEach(d=>{y.value.add(d)}),w.value=o,console.log("[Multi-Select] Created copies:",l.size,"New leader:",o.id)}}!s&&!y.value.has(t.id)&&(y.value.clear(),y.value.add(t.id),w.value=t),P.value=!0;const n=je(e);oe.value=Array.from(y.value).map(l=>{const d=g.value.find(N=>N.id===l),r=Math.round(d.x*100)/100,h=Math.round(d.y*100)/100,v=Math.round(o.x*100)/100,x=Math.round(o.y*100)/100,f=r-v,b=h-x;return{id:d.id,initialX:r,initialY:h,relativeX:f,relativeY:b,isLeader:d.id===o.id}});const a=Math.round(o.x*100)/100,i=Math.round(o.y*100)/100;Je.value={x:n.x-a,y:n.y-i};const c=y.value.size;c>1?console.log("[Group Drag] Started with",c,"lockers, leader:",o.id):console.log("[Drag] Start dragging locker:",t.id),e.preventDefault()},$e=m(null),sn=(t,e)=>{if(t){if(y.value.has(t.id)||(w.value=t,y.value.add(t.id)),He.value=!0,y.value.size>1){const s=Array.from(y.value),o=g.value.filter(l=>s.includes(l.id)),n={minX:Math.min(...o.map(l=>l.x)),maxX:Math.max(...o.map(l=>l.x+l.width)),minY:Math.min(...o.map(l=>l.y)),maxY:Math.max(...o.map(l=>l.y+(l.height||l.depth||40)))},a=(n.minX+n.maxX)/2,i=(n.minY+n.maxY)/2,c=new Map;o.forEach(l=>{const d=te(l),r=l.x+d.width/2,h=l.y+d.height/2;c.set(l.id,{relativeX:r-a,relativeY:h-i,width:d.width,height:d.height,initialRotation:l.rotation||0})}),$e.value={centerX:a,centerY:i,lockerStates:c,leaderId:t.id}}else $e.value=null;P.value=!1}},an=(t,e)=>{if(y.value.size>1&&$e.value){const s=$e.value,o=g.value.find(r=>r.id===t);if(!o||!s)return;o._lastRotation===void 0&&(o._lastRotation=o.rotation||0,console.log("=== ROTATION INIT ==="),console.log("  Initial rotation set to:",o._lastRotation));let n=e-o._lastRotation;for(console.log("=== ROTATION DEBUG ==="),console.log("  newRotation:",e),console.log("  lastRotation:",o._lastRotation),console.log("  raw delta:",n);n>180;)n-=360,console.log("  → Adjusted delta (>180):",n);for(;n<-180;)n+=360,console.log("  → Adjusted delta (<-180):",n);const a=o._rotationDirection||0,i=Math.sign(n);a!==0&&i!==0&&a!==i&&console.log("  Direction change detected! prev:",a,"current:",i),o._rotationDirection=i,o._lastRotation=e,console.log("  Final delta:",n);const c=s.centerX,l=s.centerY;Array.from(y.value).forEach(r=>{const h=g.value.find(A=>A.id===r);if(!h)return;const v=s.lockerStates.get(r);if(!v)return;const x=e-(s.lockerStates.get(s.leaderId).initialRotation||0),f=x*Math.PI/180,b=Math.cos(f),N=Math.sin(f),p=v.relativeX*b-v.relativeY*N+c,C=v.relativeX*N+v.relativeY*b+l;h.x=p-v.width/2,h.y=C-v.height/2,h.id===s.leaderId?(h.rotation=e,console.log(`[ROTATION DIRECTION] Leader locker ${h.id} rotation: ${h.rotation}`)):(h.rotation=v.initialRotation+x,console.log(`[ROTATION DIRECTION] Follower locker ${h.id} rotation: ${h.rotation}`)),ao(h.id,h.rotation)})}else{const s=g.value.find(o=>o.id===t);s&&(s.rotation=e,console.log(`[ROTATION DIRECTION] Single locker ${s.id} rotation: ${s.rotation}`),ao(t,s.rotation))}},ln=t=>{if(y.value.size>1)Array.from(y.value).forEach(n=>{const a=g.value.find(i=>i.id===n);if(a){const i=Math.round(a.rotation/45)*45;a.rotation=i,console.log(`[ROTATION END] Snapped locker ${n} from ${a.rotation} to ${i}`)}});else{const o=g.value.find(n=>n.id===t);if(o){const n=o.rotation,a=Math.round(n/45)*45;o.rotation=a,console.log(`[ROTATION END] Snapped locker ${t} from ${n} to ${a}`)}}rt.value=!0,He.value=!1,setTimeout(()=>{rt.value=!1},200);const s=g.value.find(o=>o.id===t);if(s&&(delete s._lastRotation,delete s._lastRawRotation,delete s._rotationDirection),$e.value&&($e.value=null),y.value.size>1){const o=Array.from(y.value);g.value.filter(a=>o.includes(a.id)).forEach(a=>{Nt(a.id,a.rotation)})}else{const o=g.value.find(n=>n.id===t);o&&Nt(t,o.rotation)}},ao=(()=>{let t=null;return(e,s)=>{clearTimeout(t),t=setTimeout(()=>{Nt(e,s)},200)}})(),Nt=async(t,e)=>{try{if(D.getLockerById(t)){let o=e%360;o>180?o-=360:o<-180&&(o+=360);const n=He.value;await D.updateLocker(t,{rotation:o},n)}}catch(s){console.error("[Rotation] Failed to save rotation:",s)}},rn=t=>{if(!P.value||oe.value.length===0)return;const e=je(t),s=oe.value.find(E=>E.isLeader);if(!s)return;const o=g.value.find(E=>E.id===s.id);if(!o)return;const n=e.x-Je.value.x,a=e.y-Je.value.y,i=te(o),c=ut(n),l=ut(a),d=yo(c,l,i.width,i.height,s.id,o.rotation||0),r=d.x!==c||d.y!==l;r&&console.log("[SNAP DEBUG] Position was snapped from",{x:c,y:l},"to",d);const h=d.x-s.initialX,v=d.y-s.initialY,x=[];let f=!1,b=1/0,N=1/0,p=-1/0,C=-1/0;oe.value.forEach(E=>{const k=g.value.find(R=>R.id===E.id);if(k){const R=te(k);let I,O;E.isLeader?(I=d.x,O=d.y):(I=d.x+E.relativeX,O=d.y+E.relativeY),b=Math.min(b,I),N=Math.min(N,O),p=Math.max(p,I+R.width),C=Math.max(C,O+R.height)}});let A=0,S=0;b<0?A=-b:p>Q.value&&(A=Q.value-p),N<0?S=-N:C>ee.value&&(S=ee.value-C);const $=d.x+A,z=d.y+S;if(oe.value.forEach(E=>{const k=g.value.find(R=>R.id===E.id);if(k){const R=te(k);let I,O;E.isLeader?(I=$,O=z):(I=$+E.relativeX,O=z+E.relativeY),Ot(I,O,R.width,R.height,k.id,k.rotation||0,r)&&(f=!0),x.push({id:k.id,x:I,y:O,dims:R})}}),!f)x.forEach(E=>{var I;const k=Math.round(E.x*100)/100,R=Math.round(E.y*100)/100;D.updateLocker(E.id,{x:k,y:R},!0),((I=w.value)==null?void 0:I.id)===E.id&&(w.value={...w.value,x:k,y:R})}),console.log("[Group Drag] Moving",y.value.size,"lockers. Leader:",s.id,"Delta:",{x:h.toFixed(1),y:v.toFixed(1)});else if(r&&f){console.log("[SNAP WARNING] Collision detected at snapped position, checking overlap amount...");let E=0;oe.value.forEach(k=>{const R=g.value.find(I=>I.id===k.id);if(R){const I=te(R);let O,B;k.isLeader?(O=d.x,B=d.y):(O=d.x+k.relativeX,B=d.y+k.relativeY);const j=ae({x:O,y:B,width:I.width,height:I.height,rotation:R.rotation||0});g.value.forEach(G=>{if(G.id!==R.id&&!y.value.has(G.id)){const K=ae(G),ne=Math.min(j.x+j.width,K.x+K.width)-Math.max(j.x,K.x),q=Math.min(j.y+j.height,K.y+K.height)-Math.max(j.y,K.y);ne>0&&q>0&&(E=Math.max(E,Math.min(ne,q)),console.log("[SNAP OVERLAP] With",G.id,"- X:",ne.toFixed(1),"Y:",q.toFixed(1)))}})}}),E<1?(console.log("[SNAP] Accepting snapped position with micro-overlap:",E.toFixed(2),"px"),x.forEach(k=>{var R;D.updateLocker(k.id,{x:k.x,y:k.y},!0),((R=w.value)==null?void 0:R.id)===k.id&&(w.value={...w.value,x:k.x,y:k.y})})):console.warn("[SNAP] Rejecting snapped position due to significant overlap:",E.toFixed(1),"px")}else{console.log("[COLLISION ADJUSTMENT DEBUG] Collision detected (non-snapped), finding valid position:",{snappedLeader:d,proposedPositions:x.length,hasCollision:f,wasSnapped:r});let E=d.x,k=d.y,R=!1;const I=[{dx:-20,dy:0},{dx:20,dy:0},{dx:0,dy:-20},{dx:0,dy:20},{dx:-20,dy:-20},{dx:20,dy:-20},{dx:-20,dy:20},{dx:20,dy:20}];for(const O of I){const B=d.x+O.dx,j=d.y+O.dy;let G=!1;if(oe.value.forEach(K=>{const ne=g.value.find(q=>q.id===K.id);if(ne&&!G){const q=te(ne);let Me,Ue;K.isLeader?(Me=B,Ue=j):(Me=B+K.relativeX,Ue=j+K.relativeY);const On=Q.value-q.width,Yn=ee.value-q.height;Me=Math.max(0,Math.min(Me,On)),Ue=Math.max(0,Math.min(Ue,Yn)),Ot(Me,Ue,q.width,q.height,ne.id,ne.rotation||0,!1)&&(G=!0)}}),!G){E=B,k=j,R=!0;break}}R?(oe.value.forEach(O=>{var j;const B=g.value.find(G=>G.id===O.id);if(B){let G,K;O.isLeader?(G=E,K=k):(G=E+O.relativeX,K=k+O.relativeY);const ne=te(B),q=Q.value-ne.width,Me=ee.value-ne.height;G=Math.max(0,Math.min(G,q)),K=Math.max(0,Math.min(K,Me)),D.updateLocker(B.id,{x:G,y:K},!0),((j=w.value)==null?void 0:j.id)===B.id&&(w.value={...w.value,x:G,y:K})}}),console.log("[COLLISION] Adjusted to valid position:",`(${E}, ${k})`)):console.warn("[COLLISION] No collision-free adjustment found, keeping original positions")}},cn=()=>{if(P.value){if(ct.value=!0,console.log("[Drag] Setting lockerDragJustFinished flag to true"),setTimeout(()=>{ct.value=!1,console.log("[Drag] Cleared lockerDragJustFinished flag")},150),oe.value.length>0){const t=oe.value.map(e=>{const s=g.value.find(o=>o.id===e.id);return{id:e.id,x:(s==null?void 0:s.x)||e.x,y:(s==null?void 0:s.y)||e.y}});Yo(t)}P.value=!1,Z.value=!0,Je.value={x:0,y:0},oe.value=[],ze.value=!1,eo.value=[],to.value=[],console.log("[Drag] End dragging - Current selection count:",y.value.size)}},dn=()=>{const t=[],e=new Set,s=g.value.filter(o=>!o.parentLockerId);for(let o=0;o<s.length;o++){const n=s[o],a=n.rotation||0;let i=null;if(a===0||a===360?i={minX:n.x,maxX:n.x+n.width,minY:n.y+(n.depth||n.height),maxY:n.y+(n.depth||n.height)+50}:a===90?i={minX:n.x+n.width,maxX:n.x+n.width+50,minY:n.y,maxY:n.y+(n.depth||n.height)}:a===180?i={minX:n.x,maxX:n.x+n.width,minY:n.y-50,maxY:n.y}:a===270&&(i={minX:n.x-50,maxX:n.x,minY:n.y,maxY:n.y+(n.depth||n.height)}),i)for(let c=0;c<s.length;c++){if(o===c)continue;const l=s[c];if(n.zoneId!==l.zoneId)continue;const d=l.depth||l.height,r=!(l.x+l.width<=i.minX||l.x>=i.maxX),h=!(l.y+d<=i.minY||l.y>=i.maxY);r&&h&&(e.add(n.id),e.add(l.id),t.push(`락커 ${n.number}의 문 앞이 락커 ${l.number}에 의해 막혀있습니다.`))}}t.length>0?console.log("[Door Blockage Check]:",{blocked:!0,errors:t,problematicLockers:Array.from(e)}):console.log("[Door Blockage Check]: All locker doors are accessible"),t.length>0&&(t.length=0,t.push("세로배치 모드 불가: 락커의 문 앞이 다른 락커에 의해 막혀있습니다."));for(let o=0;o<g.value.length;o++){const n=g.value[o];for(let a=o+1;a<g.value.length;a++){const i=g.value[a],c=Math.abs(n.x+n.width-i.x)<5||Math.abs(i.x+i.width-n.x)<5,l=Math.abs(n.y+(n.depth||n.height)-i.y)<5||Math.abs(i.y+(i.depth||i.height)-n.y)<5;if(c||l){if(c){const d=n.rotation%180===0,r=i.rotation%180===180;(n.x<i.x&&d&&r||i.x<n.x&&r&&d)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}if(l){const d=n.rotation%180===90,r=n.rotation%180===270,h=i.rotation%180===90,v=i.rotation%180===270;(n.y<i.y&&d&&v||i.y<n.y&&h&&r)&&(e.add(n.id),e.add(i.id),t.push(`락커 ${n.number}와 ${i.number}의 입구가 마주보고 있습니다`))}}}}return console.log("[Placement Validation]:",{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}),{isValid:t.length===0,errors:t,problematicLockers:Array.from(e)}},un=t=>{g.value.forEach(e=>{e.hasError=!1}),t.forEach(e=>{const s=g.value.find(o=>o.id===e);s&&(s.hasError=!0)})},_t=m(!1),io=t=>{console.log("[setViewMode] Switching to:",t),t==="floor"&&L.value==="front"&&(_t.value=!0,setTimeout(()=>{_t.value=!1},400)),L.value=t,t==="front"&&setTimeout(()=>{De()},50),t==="floor"&&setTimeout(()=>{De()},50),lo(),console.log("[ViewMode] Switching to:",t,{previousScale:t==="floor"?ko:Mo,newScale:pe(),viewMode:L.value}),le(()=>{Ct()})},lo=()=>{if(L.value==="front"){const e=dn();if(e.isValid)console.log("[Validation PASSED] Front view validation successful");else{console.error("[Validation FAILED] Cannot switch to front view:",e.errors),console.error("[Validation FAILED] Problematic lockers:",e.problematicLockers),alert(`세로모드 진입 불가: 락커 배치가 규칙에 맞지 않습니다.
문제: `+e.errors.join(`
`)),un(e.problematicLockers),L.value="floor";return}g.value.forEach(s=>s.hasError=!1)}console.log("[View Mode] Configuration:",{mode:L.value,floorY:we,dimensions:L.value==="floor"?"width×depth":"width×height",interactions:L.value==="floor"?"enabled":"disabled"}),Do.value=L.value==="front",L.value==="front"?(w.value=null,y.value.clear(),P.value=!1,Z.value=!1):(Z.value=!0,console.log("[Floor View] Interactions enabled, full editing mode"));const t=L.value==="floor"?"flat":"vertical";D.setPlacementMode(t)},ro=()=>{const t=g.value;if(t.length===0)return;const e={minX:Math.min(...t.map(r=>r.x)),maxX:Math.max(...t.map(r=>r.x+r.width)),minY:Math.min(...t.map(r=>r.y)),maxY:Math.max(...t.map(r=>r.y+(r.depth||r.height)))},s=[],o=[],n=[],a=[],i=[];t.forEach(r=>{const h=Math.abs(r.y-e.minY)<30,v=Math.abs(r.y+(r.depth||r.height)-e.maxY)<30,x=Math.abs(r.x-e.minX)<30,f=Math.abs(r.x+r.width-e.maxX)<30;h&&!x&&!f?s.push(r):v&&!x&&!f?n.push(r):f&&!h&&!v?o.push(r):x&&!h&&!v?a.push(r):h&&f||v&&f?o.push(r):h&&x?s.push(r):v&&x?n.push(r):i.push(r)}),s.sort((r,h)=>r.x-h.x),o.sort((r,h)=>r.y-h.y),n.sort((r,h)=>h.x-r.x),a.sort((r,h)=>h.y-r.y);let c=[];s.length>0&&o.length>0&&n.length>0?(console.log("[U-Shape] Detected ㄷ pattern"),c=[...s,...o,...n],console.log("[U-Shape] Walking order:",{top:s.map(r=>`L${r.number}`).join("→"),right:o.map(r=>`L${r.number}`).join("→"),bottom:n.map(r=>`L${r.number}`).join("→"),total:c.map(r=>`L${r.number}`).join("→")})):a.length>0&&o.length>0?(console.log("[Back-to-Back] Detected two columns"),a.sort((r,h)=>r.y-h.y),o.sort((r,h)=>h.y-r.y),c=[...a,...o]):(console.log("[Simple Row] Single line of lockers"),c=[...t].sort((r,h)=>r.x-h.x)),a.length>0&&c.indexOf(a[0])===-1&&(console.log("[Left Column] Adding left side lockers"),c.push(...a)),i.length>0&&(console.log("[Middle] Adding uncategorized lockers:",i.length),c.push(...i));const l=t.length,d=c.length;if(l!==d){console.error("[Transform] Locker count mismatch!",{original:l,unfolded:d});const r=new Set(c.map(v=>v.id)),h=t.filter(v=>!r.has(v.id));console.log("[Missing] Lockers not included:",h.map(v=>`L${v.number}`)),c.push(...h)}Ht.value=c,console.log("[Front View] Transformation complete:",{totalLockers:c.length,sequence:c.map(r=>r.number||r.id).join(" -> ")})},Ge=t=>{let e=t%360;return e<0&&(e+=360),e},co=t=>wo(t),dt=t=>t.reduce((e,s)=>s.y<e.y||s.y===e.y&&s.x<e.x?s:e,t[0]),uo=t=>t.sort((e,s)=>{const o=dt(e),n=dt(s);return Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x}),St=t=>{const e=[],s=new Set;return t.forEach(o=>{if(s.has(o.id))return;const n=[],a=[o];for(;a.length>0;){const i=a.shift();s.has(i.id)||(s.add(i.id),n.push(i),t.forEach(c=>{s.has(c.id)||It(i,c)&&a.push(c)}))}n.length>0&&e.push(n)}),e.forEach((o,n)=>{console.log(`  Minor group ${n+1}: ${o.map(a=>a.number||a.id).join(", ")}`)}),e},hn=t=>{if(t.length<=1)return t[0]?t[0][0]:null;const e=new Map;for(const o of t){let n=0;for(const a of t){if(o===a)continue;let i=!1;for(const c of o){for(const l of a)if(Vt(c,l)){i=!0;break}if(i)break}i&&n++}e.set(o,n)}const s=t.filter(o=>e.get(o)===1);if(s.length===0){console.log("[Clockwise Start] Complete loop detected, finding leftmost group");let o=t[0];for(const n of t){const a=Ne(n),i=Ne(o);a.x<i.x&&(o=n)}return console.log("[Clockwise Start] Selected leftmost group:",o.map(n=>n.number||n.id).join(",")),o[0]}if(s.length>=2){console.log("[Clockwise Start] Broken chain detected with",s.length,"endpoints");let o=s[0];for(const n of s){const a=Ne(n),i=Ne(o);(a.y<i.y||Math.abs(a.y-i.y)<10&&a.x<i.x)&&(o=n)}return console.log("[Clockwise Start] Selected endpoint:",o.map(n=>n.number||n.id).join(",")),o[0]}return console.log("[Clockwise Start] Fallback to first group"),t[0][0]},fn=(t,e)=>{for(const s of e)if(s.some(o=>o.id===t.id))return s;return null},Ne=t=>{const e=t.reduce((o,n)=>o+n.x,0),s=t.reduce((o,n)=>o+n.y,0);return{x:e/t.length,y:s/t.length}},vn=(t,e,s)=>{const o=[],n=Ne(t);for(const a of s){if(e.has(a))continue;let i=!1;for(const c of t){for(const l of a)if(Vt(c,l)){i=!0;break}if(i)break}if(i){const c=Ne(a),l=c.x-n.x,d=c.y-n.y;let r=Math.atan2(d,l)*180/Math.PI;r<0&&(r+=360),o.push({group:a,angle:r})}}return o.length===0?null:(o.sort((a,i)=>a.angle-i.angle),o[0].group)},ho=t=>{if(t.length<=1)return t;const e=[],s=new Set,o=hn(t),n=fn(o,t);if(!n)return t.sort((i,c)=>{const l=dt(i),d=dt(c);return Math.abs(l.y-d.y)>1?l.y-d.y:l.x-d.x});let a=n;for(;a&&!s.has(a);)e.push(a),s.add(a),a=vn(a,s,t);for(const i of t)s.has(i)||e.push(i);return e},fo=t=>{if(t.length===0)return[];const e=Ge(t[0].rotation||0);let s=[...t];switch(console.log(`[Rotation] Processing minor group with rotation ${e}°:`,t.map(o=>`${o.number||o.id}`)),e){case 0:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 90:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:o.x-n.x);break;case 180:s.sort((o,n)=>Math.abs(o.y-n.y)>1?o.y-n.y:n.x-o.x);break;case 270:s.sort((o,n)=>Math.abs(o.x-n.x)>1?o.x-n.x:n.y-o.y);break}return console.log("[Rotation] After rotation, order:",s.map(o=>o.number||o.id)),s},gn=(t,e,s,o)=>{let n=null,a=null;s.forEach((v,x)=>{v.some(f=>f.id===t.id)&&(n=x),v.some(f=>f.id===e.id)&&(a=x)});const i=n!==null&&a!==null&&n===a;let c=!1;if(o){const v=o.get(t.id),x=o.get(e.id);c=v!==void 0&&x!==void 0&&v===x}const l=v=>{if(v.typeId==="custom-1755675491548")return"normal";if(v.typeId==="custom-1755675506519")return"tall";if(v.color==="#4A90E2")return"blue";if(v.color==="#BD10E0")return"purple";if(!v.typeId&&v.actualHeight){if(v.actualHeight===30)return"normal";if(v.actualHeight===90)return"tall"}return v.typeId||"default"},d=l(t),r=l(e),h=d===r;return i?{same:!0,sameType:h,sameMinorGroup:!0,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:a,prevType:d,currentType:r}:{same:!1,sameType:h,sameMinorGroup:!1,sameMajorGroup:c,prevMinorGroup:n,currentMinorGroup:a,prevType:d,currentType:r}},pn=(t,e,s,o)=>{const n=gn(t,e,s,o);return console.log(`  Group spacing between ${t.number} and ${e.number}:`,n),n.sameMinorGroup?(console.log("  → Same minor group: 0px gap"),0):n.sameMajorGroup?(console.log("  → Same major group, different minor group: 10px gap"),10):(console.log("  → Different major group: 20px gap"),20)},_e=()=>{console.trace("Called from:");const t=g.value.filter(p=>!p.parentLockrCd&&(!p.tierLevel||p.tierLevel===0));if(console.log(`[Transform] Processing ${t.length} parent lockers (${g.value.length-t.length} child lockers excluded from grouping)`),t.length===0)return;const e=co(t),s=uo(e),o=[],n=2;let a=0;const i=[],c=[],l=[],d=new Map;s.forEach((p,C)=>{console.log(`[Front View] Processing major group ${C+1}:`,p.map($=>`${$.number||$.id}(rot:${$.rotation||0})`)),p.forEach($=>{d.set($.id,C)});const A=St(p),S=ho(A);l.push(...S),console.log(`  Found ${S.length} minor groups:`),S.forEach(($,z)=>{console.log(`    Minor Group ${z+1}:`,$.map(E=>`${E.number}(rot:${E.rotation||0})`))}),S.forEach(($,z)=>{console.log(`  Processing minor group ${z+1}:`,$.map(k=>`${k.number||k.id}(rot:${k.rotation||0})`)),fo($).forEach(k=>{c.push(k)})})});let r=null;c.forEach((p,C)=>{if(o.push(p),r&&C>0){let $=0;!r.parentLockrCd&&!p.parentLockrCd&&($=pn(r,p,l,d)),a+=$}const A=(p.width||40)*n,S=(p.actualHeight||p.height||60)*n;if(i.push({...p,frontViewX:a,frontViewY:we-S,frontViewRotation:0}),p.parentLockrCd){const $=i.find(z=>z.lockrCd===p.parentLockrCd);if($){let z=30;if($.lockrTypeCd||$.typeId||$.type){const O=$.lockrTypeCd||$.typeId||$.type,B=me.value.find(j=>j.id===O||j.type===O||j.LOCKR_TYPE_CD===O);B&&B.height&&(z=B.height,console.log(`[TIER HEIGHT] Using type height: ${z} for parent type: ${O}`))}const E=z*n,k=p.tierLevel||1,R=$.frontViewX,I=$.frontViewY-E*k;i[i.length-1].frontViewX=R,i[i.length-1].frontViewY=I,i[i.length-1].frontViewRotation=0}else console.error(`[CHILD POSITION] Parent not found for ${p.number}, parentLockrCd: ${p.parentLockrCd}`),i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=we-S,i[i.length-1].frontViewRotation=0,a+=A}else i[i.length-1].frontViewX=a,i[i.length-1].frontViewY=we-S,i[i.length-1].frontViewRotation=0,a+=A;r=p});const h=a,v=(Q.value-h)/2;i.forEach(p=>{p.frontViewX+=v});const x=[],f=0;if(i.forEach(p=>{const C=(p.actualHeight||p.height||0)*2,A=p.frontViewY;if(A<f){console.warn(`[Boundary Check] 락커 ${p.number}이(가) 화면 위쪽 경계를 넘어갑니다:`,{lockerId:p.id,number:p.number,topEdge:A,height:C,canvasTop:f,isOverflowing:A<f});const S=g.value.find($=>$.id===p.id);S&&x.push(S)}}),x.length>0){console.log(`[Boundary Check] 화면을 넘어가는 ${x.length}개의 락커를 삭제합니다:`,x.map(C=>`${C.number}(${C.id})`)),x.forEach(C=>{const A=g.value.findIndex(S=>S.id===C.id);A!==-1&&g.value.splice(A,1)});const p=x.map(async C=>{try{const A=await fetch(`${U}/lockrs/${C.lockrCd}`,{method:"DELETE"});A.ok?console.log(`[Boundary Check] 백엔드에서 락커 ${C.number}(${C.lockrCd}) 삭제 완료`):console.error(`[Boundary Check] 백엔드에서 락커 ${C.number} 삭제 실패:`,await A.text())}catch(A){console.error(`[Boundary Check] 백엔드에서 락커 ${C.number} 삭제 중 오류:`,A)}});Promise.all(p).then(()=>{console.log("[Boundary Check] 모든 경계 초과 락커 삭제 완료, 락커 목록 다시 로드 및 위치 재계산"),ce().then(()=>{le(()=>{_e()})})})}console.log("[Batch Update] Starting batch update for all lockers...");const b=[];i.forEach(p=>{b.push({id:p.id,updates:{frontViewX:p.frontViewX,frontViewY:p.frontViewY,frontViewRotation:p.frontViewRotation||0}})}),console.log("[Transform] Child lockers excluded - preserving their existing FRONT_VIEW coordinates from DB"),D.batchUpdateLockers(b),console.log(`[Batch Update] Updated ${b.length} lockers simultaneously`),console.log("[DB Save] Saving front view coordinates to database...");const N=b.map(async p=>{try{const C=g.value.find(A=>A.id===p.id);if(C&&C.lockrCd){const A={};p.updates.frontViewX!==void 0&&(A.FRONT_VIEW_X=p.updates.frontViewX),p.updates.frontViewY!==void 0&&(A.FRONT_VIEW_Y=p.updates.frontViewY);const S=await fetch(`${U}/lockrs/${C.lockrCd}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(A)});S.ok?console.log(`[DB Save] Saved locker ${C.number} with FRONT_VIEW_X=${A.FRONT_VIEW_X}, FRONT_VIEW_Y=${A.FRONT_VIEW_Y}`):console.error(`[DB Save] Failed to save locker ${C.number}:`,await S.text())}}catch(C){console.error(`[DB Save] Failed to save locker ${p.id}:`,C)}});Promise.all(N).then(()=>{console.log("[DB Save] All front view coordinates saved to database")}).catch(p=>{console.error("[DB Save] Error saving some lockers:",p)}),Ht.value=o,console.log("[Front View] NEW Transformation complete:",{totalLockers:o.length,majorGroups:s.length,sequence:o.map(p=>p.number||p.id).join(" → "),deletedLockers:x.length})},vo=()=>{if(L.value!=="front"){go();return}const t=y.value.size>0?Array.from(y.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=t.map(a=>g.value.find(i=>i.id===a)).filter(Boolean);if(e.some(a=>!a.parentLockrCd||a.tierLevel===0)){alert("부모 락커는 삭제할 수 없습니다. 자식 락커(상단 락커)만 삭제 가능합니다.");return}const o=new Map;e.forEach(a=>{const i=a.parentLockrCd||"no-parent";o.has(i)||o.set(i,[]),o.get(i).push(a)}),console.log("[DELETE] Lockers grouped by parent:",Array.from(o.entries()).map(([a,i])=>({parent:a,lockers:i.map(c=>({id:c.id,number:c.number,tierLevel:c.tierLevel}))})));for(const[a,i]of o.entries()){const c=i.map(r=>r.tierLevel||0).filter((r,h,v)=>v.indexOf(r)===h).sort((r,h)=>h-r);console.log(`[DELETE] Parent ${a} tier levels:`,c);const l=Math.max(...c);if(!c.every((r,h)=>{const v=l-h,x=r===v;return console.log(`[DELETE] Parent ${a} tier validation:`,{tier:r,index:h,expected:v,isValid:x}),x})){alert(`삭제는 각 부모 그룹별로 가장 높은 tier부터 순서대로만 가능합니다. (부모: ${a})`);return}}const n=[];for(const[a,i]of o.entries()){const c=Math.max(...i.map(d=>d.tierLevel||0));console.log(`[DELETE] Parent ${a} selected max tier:`,c);const l=g.value.some(d=>d.parentLockrCd===a&&!i.find(r=>r.id===d.id)&&(d.tierLevel||0)>c);console.log(`[DELETE] Parent ${a} has upper tiers:`,l),l&&n.push({parentKey:a,selectedMaxTier:c,reason:"선택된 최상단 락커 위에 더 높은 tier 존재"})}if(n.length>0){console.log("[DELETE] Blocked groups:",n),alert("선택된 락커들 중 일부 그룹에서 최상단 락커 위에 더 높은 tier가 있습니다. 가장 높은 tier부터 삭제해주세요.");return}go(),w.value=null,console.log("[Delete] Deleted lockers:",t)},mn=t=>{const e=t.match(/locker-(\d+)/);return e?parseInt(e[1]):null},go=async()=>{const t=y.value.size>0?Array.from(y.value):w.value?[w.value.id]:[];if(t.length===0)return;const e=[];for(const s of t){const o=g.value.find(n=>n.id===s);if(o&&(o.tierLevel===0||!o.parentLockerId)){const n=mn(s);if(n)try{const a=await fetch(`${U}/lockrs/${n}/children`);if(a.ok){const i=await a.json(),c=i.children||i;c&&c.length>0&&e.push(o)}}catch(a){console.error("[DEBUG] Error checking children:",a)}}}if(e.length>0){alert("상단 락커가 존재합니다. 정면 배치모드에서 상단 락커를 먼저 삭제해주세요.");return}else{const s=t.length;if(!confirm(`삭제하시겠습니까? (${s}개 락커)`))return}t.forEach(s=>{D.deleteLocker(s)}),y.value.clear(),w.value=null,console.log("[Delete] Deleted lockers:",t)},yn=()=>{const e=(Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value).map(o=>parseInt(String(o.lockrNo||0))).filter(o=>o>0).sort((o,n)=>o-n);if(e.length===0)return[];const s=[];for(let o=1;o<e[e.length-1];o++)e.includes(o)||s.push(`L${o}`);return s},xn=t=>{y.value.size===0&&!w.value||(t.preventDefault(),wt.value=!0,Xe.value={x:t.clientX,y:t.clientY})},Se=()=>{wt.value=!1},wn=()=>{vo(),Se()},Ln=()=>{Se(),tt.value=!0,ve.value=1,le(()=>{const t=Bt.value;t&&(t.focus(),t.select())})},po=async()=>{const t=Number(ve.value);if(isNaN(t)||t<1||t>9){alert("단수는 1부터 9까지 숫자만 입력 가능합니다.");return}if(L.value!=="front"){alert("단수 추가는 정면배치모드(Front View)에서만 가능합니다.");return}console.log("[AddFloors] Loading latest locker data from database..."),await ce(),console.log("[AddFloors] Latest data loaded, processing tier addition...");const e=Array.from(y.value).map(o=>g.value.find(n=>n.id===o)).filter(Boolean),s=e.map(async o=>{let n=o,a=null;if(o.parentLockerId||o.parentLockrCd){if(a=g.value.find(d=>d.id===o.parentLockerId||d.lockrCd===o.parentLockrCd),!a){console.error(`[AddFloors] Parent not found for child locker ${o.number}`);return}n=a,console.log(`[AddFloors] Selected locker is CHILD (${o.number}), using parent (${n.number})`)}else console.log(`[AddFloors] Selected locker is PARENT (${n.number})`);console.log("[AddFloors] Finding existing children for parent:",{parentId:n.id,parentLockrCd:n.lockrCd,parentNumber:n.number});const i=g.value.filter(d=>{const r=d.parentLockrCd&&d.parentLockrCd===n.lockrCd||d.parentLockerId&&d.parentLockerId===n.id;return r&&console.log("[AddFloors] Found existing child:",{childId:d.id,childNumber:d.number,parentLockrCd:d.parentLockrCd,parentLockerId:d.parentLockerId,tierLevel:d.tierLevel||0}),r}),c=i.reduce((d,r)=>Math.max(d,r.tierLevel||0),0),l=c>0?c+1:1;console.log("[AddFloors] Tier level calculation:",{existingChildrenCount:i.length,maxExistingTier:c,startTierLevel:l,algorithm:c>0?`Children exist -> Start from tier ${l}`:"No children -> Start from tier 1"}),console.log(`[AddFloors] Adding ${t} tiers to parent locker:`,{number:n.number,parentLockrCd:n.lockrCd,existingChildren:i.length,existingChildrenDetails:i.map(d=>({number:d.number,tierLevel:d.tierLevel})),maxExistingTier:c,startTierLevel:l,frontViewX:n.frontViewX,frontViewY:n.frontViewY});try{const d={tierCount:t,startTierLevel:l,parentFrontViewX:n.frontViewX,parentFrontViewY:n.frontViewY};console.log("[AddFloors] Sending to backend:",d);const h=await(await fetch(`${U}/lockrs/${n.lockrCd}/tiers`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(d)})).json();if(h.success)console.log(`[AddFloors] Successfully added ${h.count} tiers starting from level ${l}`);else throw console.error("[AddFloors] Failed to add tiers:",h.error),new Error(h.error)}catch(d){throw console.error("[AddFloors] Error adding tiers:",d),d}});try{await Promise.all(s),console.log("[AddFloors] All tiers added successfully")}catch(o){console.error("[AddFloors] Some tiers failed to add:",o),alert("티어 추가 중 오류가 발생했습니다: "+o.message);return}tt.value=!1,console.log(`[Context Menu] Added ${t} tiers to ${e.length} lockers`),ce().then(()=>{le(()=>{console.log("[AddFloors] Applying front view transformation for new tiers...");try{_e(),console.log("[AddFloors] Front view transformation completed for new tiers")}catch(o){console.error("[AddFloors] Front view transformation failed:",o),ro()}})}),lo()},bn=t=>{const e=t.target,o=e.value.replace(/[^0-9]/g,"");if(o!==""){const n=parseInt(o);n>9?(e.value="9",ve.value=9):n<1?(e.value="1",ve.value=1):(e.value=o,ve.value=n)}else e.value="",ve.value=1},Cn=()=>{Se();const t=Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value,e=new Set(t.map(o=>o.lockrNo).filter(o=>o&&o>0));let s=1;for(;e.has(s);)s++;console.log("[Number Dialog] 기존 번호:",Array.from(e).sort((o,n)=>o-n)),console.log(`[Number Dialog] 첫 번째 빈 번호: ${s}`),nt.value=!0,st.value=s,ke.value="horizontal",Ae.value=!1,Te.value=!1,le(()=>{const o=jt.value;o&&(o.focus(),o.select())})},En=()=>{console.log("[Grouping Analysis] Starting analysis..."),console.log("[TEST] Running test with known data first..."),Dn();const t=g.value.filter(s=>!s.parentLockrCd);if(t.length===0){xt.value="분석할 락커가 없습니다.",Ve.value=!0;return}console.log("[REAL DATA] Now analyzing actual lockers...");let e=`세로배치 순서별 그룹 분석
`;e+=`━━━━━━━━━━━━━━━━━━━━━
`;try{const s=co(t),o=uo(s);if(o.forEach((n,a)=>{e+=`대그룹 ${a+1} (${n.length}개 락커):
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;const i=St(n),c=ho(i);if(c.forEach((l,d)=>{const h=fo(l).map(x=>{const f=t.find(b=>b.id===x.id);return`${(f==null?void 0:f.number)||x.id}(${(f==null?void 0:f.rotation)||0}°)`}).join(", ");let v="";if(l.length===1?v="단독":v="인접 (같은방향)",e+=`  소그룹 ${a+1}-${d+1}: ${h} - ${v}
`,l.length>1){e+=`    소그룹 내 거리:
`;for(let x=0;x<l.length-1;x++)for(let f=x+1;f<l.length;f++)if(It(l[x],l[f])){const b=Yt(l[x],l[f]),N=l[x].number||l[x].id,p=l[f].number||l[f].id;e+=`      ${N} ↔ ${p}: ${b.toFixed(2)}px
`}}}),c.length>1){e+=`  소그룹 간 거리:
`;for(let l=0;l<c.length-1;l++)for(let d=l+1;d<c.length;d++){let r=1/0,h={l1:"",l2:""};for(const v of c[l])for(const x of c[d]){const f=Yt(v,x);f<r&&(r=f,h.l1=v.number||v.id,h.l2=x.number||x.id)}e+=`    소그룹 ${a+1}-${l+1} ↔ 소그룹 ${a+1}-${d+1}: ${r.toFixed(2)}px (${h.l1} - ${h.l2})
`}}e+=`
`}),o.length>1){e+=`대그룹 간 거리:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`;for(let n=0;n<o.length-1;n++)for(let a=n+1;a<o.length;a++){let i=1/0,c={l1:"",l2:""};for(const l of o[n])for(const d of o[a]){const r=Yt(l,d);r<i&&(i=r,c.l1=l.number||l.id,c.l2=d.number||d.id)}e+=`  대그룹 ${n+1} ↔ 대그룹 ${a+1}: ${i.toFixed(2)}px (${c.l1} - ${c.l2})
`}e+=`
`}e+=`요약:
`,e+=`━━━━━━━━━━━━━━━━━━━━━
`,e+=`총 대그룹: ${s.length}개
`,e+=`총 소그룹: ${o.reduce((n,a)=>n+St(a).length,0)}개
`,e+=`
💡 이 순서는 세로배치 시 실제 표시 순서와 동일합니다.`}catch(s){console.error("[Grouping Analysis] Error:",s),e+=`분석 중 오류가 발생했습니다.
`,e+=s.message}xt.value=e,Ve.value=!0},Rt=()=>{const t=Y.value?D.lockers.filter(o=>o.zoneId===Y.value.id):g.value;console.log("[findNextAvailableLabel] Total lockers in zone:",t.length);const e=t.map(o=>{const n=o.number||o.lockrLabel||"",a=n.toString().match(/^L(\d+)$/),i=a?parseInt(a[1]):0;return i>0&&console.log(`[findNextAvailableLabel] Found label ${n} -> number ${i}`),i}).filter(o=>o>0).sort((o,n)=>o-n);if(console.log("[findNextAvailableLabel] Assigned numbers:",e),e.length===0)return console.log("[findNextAvailableLabel] No existing labels, returning L1"),"L1";for(let o=1;o<e[e.length-1];o++)if(!e.includes(o))return console.log(`[findNextAvailableLabel] Found gap at ${o}, returning L${o}`),`L${o}`;const s=e[e.length-1]+1;return console.log(`[findNextAvailableLabel] No gaps found, returning L${s}`),`L${s}`},Mn=(t,e)=>{if(t.length===0)return[];const s=20;if(e){const o=new Map;return t.forEach(n=>{const a=n.frontViewY||n.y;let i=null;for(let[c]of o)if(Math.abs(a-c)<=s){i=c;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewX||a.x)-(i.frontViewX||i.x)))}else{const o=new Map;return t.forEach(n=>{const a=n.frontViewX||n.x;let i=null;for(let[c]of o)if(Math.abs(a-c)<=s){i=c;break}i!==null?o.get(i).push(n):o.set(a,[n])}),Array.from(o.entries()).sort((n,a)=>n[0]-a[0]).map(([,n])=>n.sort((a,i)=>(a.frontViewY||a.y)-(i.frontViewY||i.y)))}},mo=async()=>{be.value=!0,ge.value="번호 할당을 준비중입니다...";try{const t=Y.value?D.lockers.filter(f=>f.zoneId===Y.value.id):g.value,e=new Set(t.map(f=>f.lockrNo).filter(f=>f&&f>0));console.log("[Number Assignment] Step 1 - 기존 번호들:",Array.from(e).sort((f,b)=>f-b));const s=Array.from(y.value).map(f=>g.value.find(b=>b.id===f)).filter(Boolean);s.length>0&&(console.log("[Number Assignment] 샘플 락커 전체 데이터:",s[0]),console.log("[Number Assignment] 샘플 락커 주요 필드:",{id:s[0].id,lockrNo:s[0].lockrNo,lockrNoType:typeof s[0].lockrNo,number:s[0].number,numberType:typeof s[0].number,lockrCd:s[0].lockrCd,LOCKR_NO:s[0].LOCKR_NO,LOCKR_NO_Type:typeof s[0].LOCKR_NO}));const o=[],n=[];if(s.forEach((f,b)=>{const N=f.lockrNo||f.LOCKR_NO||f.number,p=Number(N),C=!isNaN(p)&&p>0;b<3&&console.log(`[Number Assignment] 락커 ${b+1} 상세:`,{id:f.id.slice(-4),lockrNo:f.lockrNo,LOCKR_NO:f.LOCKR_NO,number:f.number,converted:p,hasNumber:C}),C?(f.lockrNo=p,o.push(f)):n.push(f)}),console.log(`[Number Assignment] Step 2 - 선택된 락커: 총 ${s.length}개`),console.log(`  - 번호 있음: ${o.length}개`,o.map(f=>`L${f.lockrNo}`)),console.log(`  - 번호 없음: ${n.length}개`),n.length===0){alert("선택한 모든 락커에 이미 번호가 부여되어 있습니다."),be.value=!1;return}const a=ke.value==="horizontal";let i=Mn(n,a);Te.value&&i.reverse(),Ae.value&&i.forEach(f=>f.reverse());const c=i.flat();console.log("[Number Assignment] Step 2 - 정렬 완료:",c.map((f,b)=>`${b+1}번째: ${f.id.slice(-4)}`));const l=st.value||1;let d=l;const r=[],h=[];J.value==="odd"&&d%2===0?(d++,console.log(`[Number Assignment] 홀수 모드: 시작번호를 ${l}에서 ${d}로 조정`)):J.value==="even"&&d%2===1&&(d++,console.log(`[Number Assignment] 짝수 모드: 시작번호를 ${l}에서 ${d}로 조정`)),console.log(`[Number Assignment] Step 3 - 시작번호: ${d}, 할당할 락커 수: ${c.length}, 모드: ${J.value}`),ge.value=`락커 번호를 할당중입니다... (0/${c.length})`;let v=0;for(const f of c){for(;e.has(d);)console.log(`  - ${d}번은 이미 사용중, 다음 번호 확인`),J.value==="all"?d++:d+=2;console.log(`  - ${f.id.slice(-4)} 락커에 ${d}번 할당`),D.updateLocker(f.id,{lockrNo:d}),f.lockrCd&&r.push({lockrCd:f.lockrCd,LOCKR_NO:d}),h.push(`${v+1}. ${f.id.slice(-4)} → L${d}`),e.add(d),J.value==="all"?d++:d+=2,v++,ge.value=`락커 번호를 할당중입니다... (${v}/${c.length})`}if(console.log("[Number Assignment] Step 3 완료 - 할당 내역:",h),r.length>0)try{ge.value=`데이터베이스에 ${r.length}개 락커 번호를 저장중입니다...`,console.log(`[Number Assignment] Step 4 - DB 배치 업데이트 시작: ${r.length}개`),await Oo(r),console.log("[Number Assignment] Step 4 완료 - DB 업데이트 성공"),ge.value="번호 할당이 완료되었습니다!"}catch(f){console.error("[Number Assignment] DB 업데이트 실패:",f),ge.value="데이터베이스 저장에 실패했습니다.",alert("데이터베이스 저장 중 오류가 발생했습니다. 다시 시도해주세요.");return}console.log("[Number Assignment] 전체 프로세스 완료"),console.log(`  - 총 ${n.length}개 락커에 번호 할당 완료`),console.log(`  - ${o.length}개 락커는 기존 번호 유지`);const x=yn();x.length>0&&console.log("[Number Assignment] 번호 갭 발견:",x),setTimeout(()=>{nt.value=!1},500)}catch(t){console.error("[Number Assignment] Assignment failed:",t),ge.value="번호 할당 중 오류가 발생했습니다.",alert("번호 할당 중 오류가 발생했습니다. 다시 시도해주세요.")}finally{be.value=!1}},kn=async()=>{if(Se(),confirm("선택된 락커의 번호를 삭제하시겠습니까?")){const t=Array.from(y.value).map(async e=>{try{D.updateLocker(e,{lockrNo:void 0});const s=g.value.find(o=>o.id===e);s&&s.lockrCd&&await qt(s.lockrCd,{LOCKR_NO:0})}catch(s){console.error(`[Number Deletion] Failed to delete number for locker ${e}:`,s)}});await Promise.all(t)}},An=()=>{console.log("[Overlap Fix] Starting overlap detection and fix...");let t=0;for(let e=0;e<g.value.length;e++){const s=g.value[e],o=ae(s);for(let n=e+1;n<g.value.length;n++){const a=g.value[n],i=ae(a),c=Math.min(o.x+o.width,i.x+i.width)-Math.max(o.x,i.x),l=Math.min(o.y+o.height,i.y+i.height)-Math.max(o.y,i.y),d=.5;if(c>d&&l>d){let r=a.x,h=a.y;if(Math.abs(c)<Math.abs(l))if(i.x<o.x+o.width/2){const b=Math.max(Math.abs(c)+4,4);r=a.x-b}else{const b=Math.max(Math.abs(c)+4,4);r=a.x+b}else if(i.y<o.y+o.height/2){const b=Math.max(Math.abs(l)+4,4);h=a.y-b}else{const b=Math.max(Math.abs(l)+4,4);h=a.y+b}r=ut(r),h=ut(h);const v=te(a);r=Math.max(0,Math.min(r,Q.value-v.width)),h=Math.max(0,Math.min(h,ee.value-v.height));const x=a.x,f=a.y;D.updateLocker(a.id,{x:r,y:h}),t++,console.log(`[Overlap Fix] Moved ${a.id} from (${x}, ${f}) to (${r}, ${h})`)}}}return t>0?console.log(`[Overlap Fix] Fixed ${t} overlapping lockers`):console.log("[Overlap Fix] No overlaps detected"),t},ae=t=>{let e,s;if(t.type||t.id){const f=te(t);e=f.width,s=f.height}else e=t.width,s=t.height;const o=(t.rotation||0)*Math.PI/180;if(o===0)return{x:t.x,y:t.y,width:e,height:s,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s};const n=e/2,a=s/2,i=Math.cos(o),c=Math.sin(o),d=[{x:0,y:0},{x:e,y:0},{x:e,y:s},{x:0,y:s}].map(f=>{const b=f.x-n,N=f.y-a,p=b*i-N*c,C=b*c+N*i;return{x:t.x+n+p,y:t.y+a+C}}),r=Math.min(...d.map(f=>f.x)),h=Math.max(...d.map(f=>f.x)),v=Math.min(...d.map(f=>f.y)),x=Math.max(...d.map(f=>f.y));return{x:r,y:v,width:h-r,height:x-v,originalX:t.x,originalY:t.y,originalWidth:e,originalHeight:s}},ut=(t,e=20)=>Math.round(t/e)*e,yo=(t,e,s,o,n,a=0)=>{const l=ae({x:t,y:e,width:s,height:o,rotation:a});let d=t,r=e,h=!1;console.log("=== SNAP PRIORITY DEBUG ==="),console.log("Checking corner snap first (priority 1)");for(const v of g.value){if(v.id===n)continue;const x=ae(v),f=x.x,b=x.y,N=x.width,p=x.height,C=[{existingX:f+N,existingY:b+p,dragX:l.x,dragY:l.y,type:"corner-bottom-right-to-top-left"},{existingX:f,existingY:b+p,dragX:l.x+l.width,dragY:l.y,type:"corner-bottom-left-to-top-right"},{existingX:f+N,existingY:b,dragX:l.x,dragY:l.y+l.height,type:"corner-top-right-to-bottom-left"},{existingX:f,existingY:b,dragX:l.x+l.width,dragY:l.y+l.height,type:"corner-top-left-to-bottom-right"}];for(const E of C){const k=Math.sqrt(Math.pow(E.existingX-E.dragX,2)+Math.pow(E.existingY-E.dragY,2));if(k<20){console.log(`[CORNER SNAP] ${E.type}, distance: ${k.toFixed(1)}`),d=t+(E.existingX-E.dragX),r=e+(E.existingY-E.dragY),h=!0;break}}if(h){console.log("Corner snap succeeded - skipping face-to-face snap");break}if(console.log("No corner snap - checking face-to-face snap (priority 2)"),Math.abs(f+N-l.x)<20&&!h){d=t+(f+N-l.x);const E=Math.abs(l.y-b),k=Math.abs(l.y+l.height-(b+p));E<20?r=e+(b-l.y):k<20&&(r=e+(b+p-(l.y+l.height))),h=!0,console.log("[FACE SNAP] Right snap applied");continue}if(Math.abs(f-(l.x+l.width))<20&&!h){d=t+(f-(l.x+l.width));const E=Math.abs(l.y-b),k=Math.abs(l.y+l.height-(b+p));E<20?r=e+(b-l.y):k<20&&(r=e+(b+p-(l.y+l.height))),h=!0,console.log("[FACE SNAP] Left snap applied");continue}if(Math.abs(b+p-l.y)<20&&!h){r=e+(b+p-l.y);const E=Math.abs(l.x-f),k=Math.abs(l.x+l.width-(f+N));E<20?d=t+(f-l.x):k<20&&(d=t+(f+N-(l.x+l.width))),h=!0,console.log("[FACE SNAP] Bottom snap applied");continue}if(Math.abs(b-(l.y+l.height))<20&&!h){r=e+(b-(l.y+l.height));const E=Math.abs(l.x-f),k=Math.abs(l.x+l.width-(f+N));E<20?d=t+(f-l.x):k<20&&(d=t+(f+N-(l.x+l.width))),h=!0,console.log("[FACE SNAP] Top snap applied");continue}}return console.log("Final result: snapped =",h),{x:d,y:r}},Ot=(t,e,s,o,n=null,a=0,i=!1)=>{const c=ae({x:t,y:e,width:s,height:o,rotation:a});return g.value.some(l=>{if(l.id===n||P.value&&y.value.has(l.id))return!1;const d=ae(l),r=Math.min(c.x+c.width,d.x+d.width)-Math.max(c.x,d.x),h=Math.min(c.y+c.height,d.y+d.height)-Math.max(c.y,d.y),v=.5,x=r>v&&h>v;return x&&console.log("[COLLISION] Detected with",l.id,"- overlap:",`(${r.toFixed(1)}, ${h.toFixed(1)})`,"tolerance:",v),x})},Tn=()=>{console.log("[TEST] Creating test locker data with Adjacent/Connected thresholds..."),console.log("[TEST] ADJACENT: ≤30px + same direction, CONNECTED: 40-43px (any direction)");const t=[{id:"test-L1",number:"L1",x:100,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L2",number:"L2",x:165,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L3",number:"L3",x:230,y:100,width:40,height:60,rotation:0,color:"#4A90E2"},{id:"test-L4",number:"L4",x:312,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L5",number:"L5",x:377,y:100,width:40,height:60,rotation:90,color:"#BD10E0"},{id:"test-L6",number:"L6",x:442,y:100,width:40,height:60,rotation:90,color:"#BD10E0"}];return console.log("[TEST] Expected result: ALL in 1 major group (connected through L3↔L4)"),console.log("[TEST] Expected minor groups: [L1,L2,L3] (adjacent, 0°), [L4,L5,L6] (adjacent, 90°)"),console.log("[TEST] Key distances:"),console.log("[TEST]   L1↔L2: 25px (adjacent, same dir)"),console.log("[TEST]   L2↔L3: 25px (adjacent, same dir)"),console.log("[TEST]   L3↔L4: 42px (connected, diff dir)"),console.log("[TEST]   L4↔L5: 25px (adjacent, same dir)"),console.log("[TEST]   L5↔L6: 25px (adjacent, same dir)"),t},Dn=()=>{console.log("=== TESTING WITH KNOWN DATA ===");const t=[...g.value];g.value=Tn();const e=wo();return g.value=t,console.log("=== TEST COMPLETE ==="),e},ht=t=>{const e=t.x||t.left||0,s=t.y||t.top||0,o=t.width||60,n=t.height||t.depth||40,a=(t.rotation||0)*Math.PI/180,i=e+o/2,c=s+n/2;return[{x:-o/2,y:-n/2},{x:o/2,y:-n/2},{x:o/2,y:n/2},{x:-o/2,y:n/2}].map(d=>({x:i+d.x*Math.cos(a)-d.y*Math.sin(a),y:c+d.x*Math.sin(a)+d.y*Math.cos(a)}))},Yt=(t,e)=>{const s=ht(t),o=ht(e);let n=1/0;for(const a of s)for(const i of o){const c=Math.sqrt(Math.pow(a.x-i.x,2)+Math.pow(a.y-i.y,2));n=Math.min(n,c)}return n},xo=(t,e,s)=>{const o=ht(t),n=ht(e);let a=0;for(const i of o)for(const c of n)Math.sqrt(Math.pow(i.x-c.x,2)+Math.pow(i.y-c.y,2))<s&&a++;return a},It=(t,e)=>{const s=xo(t,e,To),o=Ge(t.rotation||0),n=Ge(e.rotation||0),a=o===n;return s>=2&&a},Vt=(t,e)=>{const s=xo(t,e,To);if(s>=1)return!0;if(s>=2){const o=Ge(t.rotation||0),n=Ge(e.rotation||0);return o!==n}return!1},wo=t=>{const e=[],s=new Set,o=t||g.value;return o.forEach(n=>{if(s.has(n.id))return;const a=[n];s.add(n.id);const i=[n];for(;i.length>0;){const c=i.shift();o.forEach(l=>{if(s.has(l.id))return;const d=It(c,l),r=Vt(c,l);(d||r)&&(a.push(l),s.add(l.id),i.push(l))})}e.push(a)}),e.forEach((n,a)=>{console.log(`  Group ${a+1}: ${n.map(i=>i.number||i.id).join(", ")}`)}),e},$n=async t=>{try{const s={LOCKR_KND_CD:`zone-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,LOCKR_KND_NM:t.name,X:0,Y:0,WIDTH:Q.value,HEIGHT:ee.value,COLOR:t.color||"#f0f9ff"};await Ro(s);const o=Ce.value.find(n=>n.LOCKR_KND_NM===t.name);o&&Be(o),Ye.value=!1}catch(e){console.error("Failed to save zone:",e),alert("Failed to save zone. Please try again.")}},Nn=async t=>{var e;try{const s={id:`locker-${Date.now()}`,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:`custom-${Date.now()}`,zoneId:((e=Y.value)==null?void 0:e.id)||null,x:0,y:0,rotation:0};await kt(s);try{const n=await fetch(`${U}/types`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LOCKR_TYPE_CD:`custom-${Date.now()}`,LOCKR_TYPE_NM:t.name,WIDTH:t.width,HEIGHT:t.height,DEPTH:t.depth,COLOR:t.color||"#3b82f6"})});n.ok?console.log("[Locker Registration] Type saved to backend successfully"):console.error("Failed to save locker type to backend:",await n.text())}catch(n){console.error("Error saving locker type to backend:",n)}const o={id:s.id,name:t.name,width:t.width,depth:t.depth,height:t.height,description:t.description,color:t.color||"#3b82f6",type:s.type};me.value.push(o),Ie.value=!1,console.log("[Locker Registration] New locker saved:",{id:s.id,name:s.name,dimensions:{width:s.width,depth:s.depth,height:s.height},type:s.type})}catch(s){console.error("Failed to save locker:",s),alert("Failed to save locker. Please try again.")}},_n=()=>{console.log("[Debug] All locker dimensions:"),g.value.forEach(t=>{console.log(`${t.type||t.name}:`,{id:t.id,width:t.width,height:t.height,depth:t.depth,actualHeight:t.actualHeight,position:{x:t.x,y:t.y}})}),console.log("[Snap System] Configuration:",{threshold:20,lockerCount:g.value.length,viewMode:L.value})},ft=(t,e)=>{if(!w.value)return;const s=Math.max(0,Math.min(w.value.x+t,Q.value-w.value.width)),o=Math.max(0,Math.min(w.value.y+e,ee.value-w.value.height));D.updateLocker(w.value.id,{x:s,y:o})},Xt=t=>{(t.ctrlKey||t.metaKey)&&(yt.value=!0);const e=t.target;if(e.tagName==="INPUT"||e.tagName==="TEXTAREA"){console.log("[Keyboard] Ignored - typing in input field");return}if(Ie.value||Ye.value){console.log("[Keyboard] Ignored - modal is open");return}if((t.ctrlKey||t.metaKey)&&t.shiftKey&&t.key==="F"){t.preventDefault();const s=An();s>0?(console.log(`[Keyboard] Fixed ${s} overlapping lockers`),alert(`Fixed ${s} overlapping lockers`)):(console.log("[Keyboard] No overlaps detected"),alert("No overlapping lockers found"));return}if((t.ctrlKey||t.metaKey)&&t.key==="a"){t.preventDefault(),g.value.forEach(s=>{y.value.add(s.id)}),g.value.length>0&&(w.value=g.value[0]),console.log("[Multi-Select] Selected all lockers");return}if(t.key==="r"||t.key==="R"){t.preventDefault(),w.value;return}if((t.ctrlKey||t.metaKey)&&t.key==="c"){if(L.value==="front"){console.log("[Copy] Disabled in front view mode");return}t.preventDefault(),y.value.size>0?(Ee.value=Array.from(y.value).map(s=>{const o=g.value.find(n=>n.id===s);return o?{...o}:null}).filter(Boolean),console.log("[Multi-Select] Copied",Ee.value.length,"lockers")):w.value&&(Ee.value=[{...w.value}],console.log("[Copy] Locker copied:",w.value.id));return}if((t.ctrlKey||t.metaKey)&&t.key==="v"&&Ee.value&&Ee.value.length>0&&Y.value){if(L.value==="front"){console.log("[Paste] Disabled in front view mode");return}t.preventDefault(),y.value.clear(),Ee.value.forEach((s,o)=>{const n={...s,id:`locker-${Date.now()}-${Math.random()}`,number:Rt(),x:s.x+20,y:s.y+20,zoneId:Y.value.id},a=D.addLocker(n);y.value.add(a.id),o===0&&(w.value=a)}),console.log("[Multi-Select] Pasted",Ee.value.length,"lockers");return}if((t.key==="Delete"||t.key==="Backspace")&&(w.value||y.value.size>0)&&(t.preventDefault(),vo()),(t.key==="g"||t.key==="G")&&(t.preventDefault(),ze.value=!ze.value,console.log(`[Alignment] Guides ${ze.value?"ON":"OFF"}`)),t.ctrlKey&&t.key==="z"&&(t.preventDefault(),D.undo()),t.ctrlKey&&t.key==="y"&&(t.preventDefault(),D.redo()),t.key==="Escape"&&(y.value.clear(),w.value=null,D.selectLocker(null)),w.value){const s=t.shiftKey?20:1;t.key==="ArrowLeft"?(t.preventDefault(),ft(-s,0)):t.key==="ArrowRight"?(t.preventDefault(),ft(s,0)):t.key==="ArrowUp"?(t.preventDefault(),ft(0,-s)):t.key==="ArrowDown"&&(t.preventDefault(),ft(0,s))}};vt(()=>g.value,t=>{if(w.value){const e=t.find(s=>s.id===w.value.id);e&&(w.value=e)}},{deep:!0}),vt(()=>L.value,async(t,e)=>{if(e&&t!==e){if(console.log(`[ViewMode Change] ${e} → ${t}, reloading lockers...`),await ce(),t==="front"&&e==="floor")console.log("[ViewMode Change] Transitioning from floor to front - recalculating positions..."),le(()=>{try{_e(),console.log("[ViewMode Change] Front view transformation completed")}catch(s){console.error("[ViewMode Change] Front view transformation failed:",s),ro()}});else if(t==="front"&&e==="front"){console.log("[ViewMode Change] Zone change in front view - checking for missing coordinates...");const s=g.value.filter(o=>o.frontViewX===null||o.frontViewX===void 0||o.frontViewY===null||o.frontViewY===void 0);s.length>0?(console.log(`[ViewMode Change] Found ${s.length} lockers with missing front view coordinates`),console.log("[ViewMode Change] Missing coordinates for lockers:",s.map(o=>o.number).join(", ")),console.log("[ViewMode Change] Recalculating positions for ALL lockers in zone using grouping logic"),le(()=>{try{_e(),console.log("[ViewMode Change] Zone-wide recalculation completed")}catch(o){console.error("[ViewMode Change] Zone-wide recalculation failed:",o)}})):console.log("[ViewMode Change] All lockers have saved positions - using DB coordinates")}}else e||console.log("[ViewMode Watcher] Initial mount - skipping reload (onMounted will handle it)")});const Sn=ie(()=>Pe.value||P.value?"grabbing":xe.value?"crosshair":yt.value&&y.value.size>0?"copy":y.value.size>0?"move":"default"),Rn=ie(()=>{const t=fe/F.value,e=Le/F.value,s=W.value.x,o=W.value.y;return`${s} ${o} ${t} ${e}`});vt(y,t=>{},{immediate:!0,deep:!0}),vt(lt,t=>{},{deep:!0}),Vn(async()=>{console.log("Component mounted, loading data..."),L.value="floor",console.log("[onMounted] Initial view mode set to:",L.value),ye.value=!0,Fe.value=!0;try{if(await Promise.all([Mt(),Zt()]),console.log("[onMounted] About to load lockers with view mode:",L.value),await ce(),await le(),ye.value=!1,Fe.value=!1,console.log("All data loading completed"),L.value==="floor"&&g.value.length>0&&setTimeout(()=>{De()},100),L.value==="front"){const t=g.value.filter(e=>e.frontViewX===null||e.frontViewX===void 0||e.frontViewY===null||e.frontViewY===void 0);t.length>0&&(console.log(`[onMounted] Found ${t.length} lockers with missing front view coordinates`),console.log("[onMounted] Auto-calculating positions for lockers:",t.map(e=>e.number).join(", ")),le(()=>{try{_e(),console.log("[onMounted] Auto-calculation completed")}catch(e){console.error("[onMounted] Auto-calculation failed:",e)}}))}Ce.value.length>0&&!Y.value&&(Be(Ce.value[0]),console.log("[Data Loading] Auto-selected first zone:",Ce.value[0].name))}catch(t){console.error("Error loading data:",t),ye.value=!1,Fe.value=!1}window.addEventListener("resize",Ct),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt),document.addEventListener("click",Se),D.zones.length>0&&Be(D.zones[0]),document.addEventListener("keydown",Xt),document.addEventListener("keyup",Pt)});const Pt=t=>{!t.ctrlKey&&!t.metaKey&&(yt.value=!1)};return Xn(()=>{document.removeEventListener("keydown",Xt),document.removeEventListener("keyup",Pt),document.removeEventListener("click",Se),window.removeEventListener("resize",Ct)}),(t,e)=>{var s;return M(),T("div",Gn,[ye.value||Fe.value?(M(),T("div",Un,e[36]||(e[36]=[u("div",{class:"loading-spinner"},[u("div",{class:"spinner"}),u("p",null,"Loading locker data...")],-1)]))):(M(),T("div",Wn,[u("div",Zn,[u("aside",qn,[e[41]||(e[41]=u("h2",{class:"sidebar-title"},"락커 선택창",-1)),ye.value?(M(),T("div",Jn,e[37]||(e[37]=[u("p",null,"🔄 락커 타입을 불러오는 중...",-1)]))):Wt.value&&At.value.length===0?(M(),T("div",Qn,e[38]||(e[38]=[u("p",null,"📦 등록된 락커가 없습니다",-1),u("p",{class:"empty-hint"},"락커를 등록해주세요",-1)]))):At.value.length>0?(M(),T("div",es,[(M(!0),T(re,null,de(At.value,o=>{var n;return M(),T("div",{key:o.id,class:"locker-type-item-wrapper"},[u("div",{class:Re(["locker-type-item",{active:((n=Oe.value)==null?void 0:n.id)===o.id}]),onClick:a=>jo(o),onDblclick:a=>Uo(o),onContextmenu:se(a=>Bo(a,o),["prevent"]),style:{cursor:"pointer"}},[u("div",os,[(M(),T("svg",{width:(o.width||40)*2,height:(o.depth||o.width||40)*2,viewBox:`0 0 ${(o.width||40)*2} ${(o.depth||o.width||40)*2}`,class:"type-preview"},[u("rect",{x:"2",y:"2",width:Math.max((o.width||40)*2-4,1),height:Math.max((o.depth||o.width||40)*2-4,1),fill:o.color?`${o.color}20`:"#FFFFFF",stroke:"#9ca3af","stroke-width":.5*2,rx:2*2,ry:2*2,"shape-rendering":"crispEdges"},null,8,ss),u("line",{x1:10,y1:(o.depth||o.width||40)*2-5,x2:(o.width||40)*2-10,y2:(o.depth||o.width||40)*2-5,stroke:o.color||"#1e40af","stroke-width":"4",opacity:"0.9","stroke-linecap":"square",class:"front-indicator"},null,8,as)],8,ns))]),u("div",is,[u("span",ls,_(o.name||"Unknown"),1),u("span",rs,_(o.width)+"x"+_(o.depth||o.width)+"x"+_(o.height)+"cm ",1)])],42,ts),u("button",{class:"delete-type-button",onClick:se(a=>oo(o),["stop"]),title:"이 락커 타입 삭제"},e[39]||(e[39]=[u("svg",{width:"16",height:"16",viewBox:"0 0 16 16"},[u("path",{d:"M4 4 L12 12 M12 4 L4 12",stroke:"#ef4444","stroke-width":"2","stroke-linecap":"round"})],-1)]),8,cs)])}),128))])):V("",!0),Ke.value.length>0?(M(),T("div",ds,[e[40]||(e[40]=u("div",{class:"section-title"},"삭제된 타입",-1)),(M(!0),T(re,null,de(Ke.value,o=>(M(),T("div",{key:o,class:"deleted-type-item"},[u("span",null,_(Zo(o)),1),u("button",{onClick:n=>Wo(o),class:"restore-btn"},"복원",8,us)]))),128))])):V("",!0),u("button",{class:"register-locker-btn",onClick:e[0]||(e[0]=o=>Ie.value=!0)}," 락커 등록 ")]),u("main",hs,[u("div",fs,[u("div",vs,[(M(!0),T(re,null,de(Ce.value,o=>{var n,a;return M(),T("button",{key:o.id,class:Re(["zone-tab",{active:((n=Y.value)==null?void 0:n.id)===o.id}]),onClick:i=>Be(o),onContextmenu:i=>Ho(i,o)},[ue(_(o.name)+" ",1),((a=Y.value)==null?void 0:a.id)===o.id?(M(),T("span",ps)):V("",!0)],42,gs)}),128))]),u("div",ms,[u("button",{class:"zone-add-btn",onClick:e[1]||(e[1]=o=>Ye.value=!0)}," + 구역 추가 "),u("div",ys,[u("button",{class:Re(["mode-btn",{active:L.value==="floor"}]),onClick:e[2]||(e[2]=o=>io("floor")),title:"평면배치모드 (P)"},e[42]||(e[42]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-863facc3><rect x="3" y="3" width="18" height="18" rx="2" data-v-863facc3></rect><rect x="7" y="7" width="4" height="4" data-v-863facc3></rect><rect x="13" y="7" width="4" height="4" data-v-863facc3></rect><rect x="7" y="13" width="4" height="4" data-v-863facc3></rect><rect x="13" y="13" width="4" height="4" data-v-863facc3></rect></svg><span data-v-863facc3>평면배치</span>',2)]),2),u("button",{class:Re(["mode-btn",{active:L.value==="front"}]),onClick:e[3]||(e[3]=o=>io("front")),title:"정면배치모드 (F)"},e[43]||(e[43]=[Ft('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-v-863facc3><rect x="3" y="3" width="18" height="18" rx="2" data-v-863facc3></rect><line x1="3" y1="15" x2="21" y2="15" stroke-dasharray="2 2" data-v-863facc3></line><rect x="7" y="7" width="4" height="6" data-v-863facc3></rect><rect x="13" y="7" width="4" height="6" data-v-863facc3></rect></svg><span data-v-863facc3>정면배치</span>',2)]),2),u("button",{class:"mode-btn",onClick:En,title:"그룹핑 결과 확인"},e[44]||(e[44]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("circle",{cx:"12",cy:"12",r:"3"}),u("path",{d:"M12 1v6m0 6v6"}),u("path",{d:"m21 12-6-3-6 3-6-3"})],-1),u("span",null,"그룹핑 확인",-1)])),L.value==="floor"||L.value==="front"?(M(),T("div",xs,[u("button",{class:"zoom-btn",onClick:De,title:"모든 락커가 화면에 맞춤 (클릭)"},[e[45]||(e[45]=u("svg",{width:"16",height:"16",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("rect",{x:"3",y:"3",width:"18",height:"18",rx:"2"}),u("path",{d:"M7 7h.01M7 12h.01M7 17h.01M12 7h.01M12 12h.01M12 17h.01M17 7h.01M17 12h.01M17 17h.01"})],-1)),u("span",null,_(Math.round(F.value*100))+"%",1)]),e[46]||(e[46]=u("div",{class:"zoom-hints"},[u("span",{class:"hint"},"Ctrl+스크롤: 줌"),u("span",{class:"hint"},"휠클릭+드래그: 이동")],-1))])):V("",!0),u("button",{class:"mode-btn debug-btn",onClick:e[4]||(e[4]=o=>ot.value=!0),title:"락커 데이터 상세 확인"},e[47]||(e[47]=[u("svg",{width:"20",height:"20",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor","stroke-width":"2"},[u("path",{d:"m9 12 2 2 4-4"}),u("path",{d:"M21 12c.552 0 1.005-.449.95-.998a10 10 0 0 0-8.953-8.951c-.55-.055-.998.398-.998.95v8a1 1 0 0 0 1 1z"}),u("path",{d:"M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7"})],-1),u("span",null,"디버그 정보",-1)]))])])]),u("div",ws,[(M(),T("svg",{ref_key:"canvasRef",ref:mt,class:"canvas",width:"100%",height:"100%",viewBox:Rn.value,style:gt({cursor:Sn.value,margin:0,padding:0}),preserveAspectRatio:"none",onWheel:se(qo,["prevent"]),onMousedown:Jo,onMousemove:Qo,onMouseup:no,onMouseleave:no,onClick:en},[e[49]||(e[49]=Ft('<defs data-v-863facc3><pattern id="grid" width="30" height="30" patternUnits="userSpaceOnUse" data-v-863facc3><path d="M 30 0 L 0 0 0 30" fill="none" stroke="#e5e5e5" stroke-width="0.5" data-v-863facc3></path></pattern><filter id="buttonShadow" x="-50%" y="-50%" width="200%" height="200%" data-v-863facc3><feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.1" data-v-863facc3></feDropShadow></filter></defs><rect width="100%" height="100%" fill="url(#grid)" class="canvas-background" data-v-863facc3></rect>',2)),Y.value?(M(),T("rect",{key:0,x:"0",y:"0",width:Q.value,height:ee.value,fill:"none",stroke:"black","stroke-width":"1"},null,8,bs)):V("",!0),L.value==="front"?(M(),T("g",Cs,[u("line",{x1:0,y1:we,x2:qe,y2:we,stroke:"#94a3b8","stroke-width":"2","stroke-dasharray":"10,5"}),u("text",{x:W.value.x+20/F.value,y:we+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500"}," 바닥선 ",8,Es),u("text",{x:W.value.x+(fe-80)/F.value,y:we+20,fill:"#64748b","font-size":12/F.value,"font-weight":"500","text-anchor":"end"}," 바닥선 ",8,Ms)])):V("",!0),(M(!0),T(re,null,de(Fo.value,o=>{var n,a;return M(),We(Kn,{key:o.id,locker:o,"is-selected":((n=w.value)==null?void 0:n.id)===o.id,"is-multi-selected":y.value.has(o.id),"should-hide-individual-outline":Ko.value.has(o.id)&&!P.value,"is-dragging":P.value&&y.value.has(o.id),"adjacent-sides":Xo(o.id),"view-mode":L.value,"is-transitioning-to-floor":_t.value,"show-number":!0,"show-rotate-handle":((a=w.value)==null?void 0:a.id)===o.id,"zoom-level":F.value,onClick:(i,c)=>tn(i,c),onContextmenu:se(xn,["prevent"]),onSelect:e[5]||(e[5]=i=>w.value=g.value.find(c=>c.id===i)),onDragstart:nn,onRotatestart:sn,onRotate:an,onRotateend:ln},null,8,["locker","is-selected","is-multi-selected","should-hide-individual-outline","is-dragging","adjacent-sides","view-mode","is-transitioning-to-floor","show-rotate-handle","zoom-level","onClick"])}),128)),lt.value.length>0&&!P.value?(M(),T("g",ks,[(M(!0),T(re,null,de(lt.value.filter(o=>o.length>1),(o,n)=>{var a,i,c,l;return M(),T("rect",{key:`group-${n}`,x:(((a=it(o))==null?void 0:a.minX)||0)-5,y:(((i=it(o))==null?void 0:i.minY)||0)-5,width:(((c=it(o))==null?void 0:c.width)||0)+10,height:(((l=it(o))==null?void 0:l.height)||0)+10,fill:"none",stroke:"#0768AE","stroke-width":"2","stroke-dasharray":"5,5",class:"unified-selection-outline","pointer-events":"none"},e[48]||(e[48]=[u("animate",{attributeName:"stroke-dashoffset",values:"0;10",dur:"0.5s",repeatCount:"indefinite"},null,-1)]),8,As)}),128))])):V("",!0),w.value&&!P.value&&Z.value?(M(),T("g",Ts,[u("g",{transform:`translate(${Qt().x}, ${Qt().y}) rotate(${w.value.rotation||0}, ${w.value.width/2}, ${w.value.height/2})`},null,8,Ds)])):V("",!0),ze.value?(M(),T("g",$s,[(M(!0),T(re,null,de(eo.value,o=>(M(),T("line",{key:`h-${o.position}`,x1:0,y1:o.position,x2:Q.value,y2:o.position,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,Ns))),128)),(M(!0),T(re,null,de(to.value,o=>(M(),T("line",{key:`v-${o.position}`,x1:o.position,y1:0,x2:o.position,y2:ee.value,stroke:"#00ff00","stroke-width":"1","stroke-dasharray":"5,5",opacity:"0.6","pointer-events":"none"},null,8,_s))),128))])):V("",!0),xe.value&&X.value.x!=null&&X.value.y!=null&&H.value.x!=null&&H.value.y!=null&&Math.abs((H.value.x||0)-(X.value.x||0))>5?(M(),T("rect",{key:5,x:Math.min(X.value.x||0,H.value.x||0),y:Math.min(X.value.y||0,H.value.y||0),width:Math.abs((H.value.x||0)-(X.value.x||0)),height:Math.abs((H.value.y||0)-(X.value.y||0)),fill:"rgba(0, 122, 255, 0.1)",stroke:"#007AFF","stroke-width":"1","stroke-dasharray":"5 5","pointer-events":"none",class:"selection-box"},null,8,Ss)):V("",!0)],44,Ls))])])])])),Ye.value?(M(),We(Hn,{key:2,onClose:e[6]||(e[6]=o=>Ye.value=!1),onSave:$n})):V("",!0),Ie.value?(M(),We(zn,{key:3,onClose:e[7]||(e[7]=o=>Ie.value=!1),onSave:Nn})):V("",!0),wt.value?(M(),T("div",{key:4,style:gt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:1e3}),class:"context-menu",onClick:e[8]||(e[8]=se(()=>{},["stop"]))},[L.value==="front"?(M(),T(re,{key:0},[u("div",{class:"context-menu-item",onClick:Ln},e[50]||(e[50]=[u("i",{class:"fas fa-layer-group"},null,-1),ue(" 단수 입력 ",-1)])),u("div",{class:"context-menu-item",onClick:Cn},e[51]||(e[51]=[u("i",{class:"fas fa-sort-numeric-up"},null,-1),ue(" 번호 부여 ",-1)])),u("div",{class:"context-menu-item",onClick:kn},e[52]||(e[52]=[u("i",{class:"fas fa-eraser"},null,-1),ue(" 번호 삭제 ",-1)]))],64)):V("",!0),u("div",{class:"context-menu-item",onClick:wn},e[53]||(e[53]=[u("i",{class:"fas fa-trash"},null,-1),ue(" 락커 삭제 ",-1)]))],4)):V("",!0),tt.value?(M(),T("div",Rs,[u("div",{class:"modal-content",onClick:e[11]||(e[11]=se(()=>{},["stop"]))},[e[55]||(e[55]=u("h3",null,"단수 입력",-1)),u("div",Os,[e[54]||(e[54]=u("label",null,"단수:",-1)),he(u("input",{ref_key:"floorInputRef",ref:Bt,"onUpdate:modelValue":e[9]||(e[9]=o=>ve.value=o),type:"number",min:"1",max:"9",placeholder:"1-9 사이 입력",class:"form-control",onInput:bn,onKeyup:bo(po,["enter"])},null,544),[[Lo,ve.value,void 0,{number:!0}]])]),u("div",Ys,[u("button",{class:"btn btn-secondary",onClick:e[10]||(e[10]=o=>tt.value=!1)},"취소"),u("button",{class:"btn btn-primary",onClick:po},"확인")])])])):V("",!0),nt.value?(M(),T("div",Is,[u("div",{class:"modal-content number-assign-modal",onClick:e[23]||(e[23]=se(()=>{},["stop"]))},[e[68]||(e[68]=u("h3",null,"번호 부여",-1)),u("div",Vs,[e[59]||(e[59]=u("div",{style:{display:"flex","justify-content":"space-between","margin-bottom":"10px"}},[u("label",null,"시작번호:"),u("label",{style:{"margin-right":"100px"}},"번호생성옵션:")],-1)),u("div",Xs,[he(u("input",{ref_key:"startNumberInputRef",ref:jt,"onUpdate:modelValue":e[12]||(e[12]=o=>st.value=o),type:"number",min:1,placeholder:"시작 번호",class:"form-control number-input",style:{width:"120px"},onKeyup:bo(mo,["enter"])},null,544),[[Lo,st.value,void 0,{number:!0}]]),u("div",Ps,[u("label",Fs,[he(u("input",{type:"radio","onUpdate:modelValue":e[13]||(e[13]=o=>J.value=o),value:"all"},null,512),[[Ze,J.value]]),e[56]||(e[56]=u("span",null,"전체",-1))]),u("label",Ks,[he(u("input",{type:"radio","onUpdate:modelValue":e[14]||(e[14]=o=>J.value=o),value:"odd"},null,512),[[Ze,J.value]]),e[57]||(e[57]=u("span",null,"홀수",-1))]),u("label",Hs,[he(u("input",{type:"radio","onUpdate:modelValue":e[15]||(e[15]=o=>J.value=o),value:"even"},null,512),[[Ze,J.value]]),e[58]||(e[58]=u("span",null,"짝수",-1))])])])]),u("div",zs,[e[62]||(e[62]=u("div",{class:"form-labels-row"},[u("label",{class:"section-label"},"생성방향:")],-1)),u("div",Bs,[u("div",js,[u("label",Gs,[he(u("input",{type:"radio","onUpdate:modelValue":e[16]||(e[16]=o=>ke.value=o),value:"horizontal"},null,512),[[Ze,ke.value]]),e[60]||(e[60]=u("span",null,"가로",-1))]),u("label",Us,[he(u("input",{type:"radio","onUpdate:modelValue":e[17]||(e[17]=o=>ke.value=o),value:"vertical"},null,512),[[Ze,ke.value]]),e[61]||(e[61]=u("span",null,"세로",-1))])])])]),u("div",Ws,[e[65]||(e[65]=u("label",{class:"section-label"},"추가옵션:",-1)),u("div",Zs,[u("div",qs,[u("label",Js,[e[63]||(e[63]=u("span",{style:{"margin-right":"8px"}},"역방향",-1)),he(u("input",{type:"checkbox","onUpdate:modelValue":e[18]||(e[18]=o=>Ae.value=o),onChange:e[19]||(e[19]=o=>console.log("역방향:",Ae.value)),style:{"margin-right":"5px"}},null,544),[[Co,Ae.value]]),u("span",Qs,"("+_(Ae.value?"활성":"비활성")+")",1)])]),u("div",null,[u("label",ea,[e[64]||(e[64]=u("span",{style:{"margin-right":"8px"}},"아래에서부터",-1)),he(u("input",{type:"checkbox","onUpdate:modelValue":e[20]||(e[20]=o=>Te.value=o),onChange:e[21]||(e[21]=o=>console.log("아래에서부터:",Te.value)),style:{"margin-right":"5px"}},null,544),[[Co,Te.value]]),u("span",ta,"("+_(Te.value?"활성":"비활성")+")",1)])])])]),be.value?(M(),T("div",oa,[u("div",na,[e[66]||(e[66]=u("div",{class:"loading-spinner"},null,-1)),u("span",sa,_(ge.value),1)])])):V("",!0),u("div",aa,[u("button",{class:"btn btn-secondary",onClick:e[22]||(e[22]=o=>nt.value=!1),disabled:be.value}," 취소 ",8,ia),u("button",{class:"btn btn-primary",onClick:mo,disabled:be.value},[be.value?(M(),T("span",ra,e[67]||(e[67]=[u("i",{class:"fas fa-spinner fa-spin"},null,-1),ue(" 처리중... ",-1)]))):(M(),T("span",ca,"번호 부여"))],8,la)])])])):V("",!0),Ve.value?(M(),T("div",{key:7,class:"modal-overlay",onClick:e[26]||(e[26]=o=>Ve.value=!1)},[u("div",{class:"modal-content grouping-popup",onClick:e[25]||(e[25]=se(()=>{},["stop"]))},[e[69]||(e[69]=u("h3",null,"대그룹 분석 결과",-1)),u("div",da,[u("pre",null,_(xt.value),1)]),u("div",ua,[u("button",{class:"btn btn-primary",onClick:e[24]||(e[24]=o=>Ve.value=!1)},"확인")])])])):V("",!0),ot.value?(M(),T("div",{key:8,class:"modal-overlay",onClick:e[30]||(e[30]=o=>ot.value=!1)},[u("div",{class:"modal-content debug-popup",onClick:e[29]||(e[29]=se(()=>{},["stop"]))},[e[76]||(e[76]=u("h3",null,"🔍 락커 데이터 디버깅 정보",-1)),u("div",ha,[e[74]||(e[74]=u("h4",null,"📊 전체 통계",-1)),u("div",fa,[u("div",va,[e[70]||(e[70]=u("span",{class:"label"},"Store 전체:",-1)),u("span",ga,_(Kt(D).lockers.length)+"개",1)]),u("div",pa,[e[71]||(e[71]=u("span",{class:"label"},"현재 구역:",-1)),u("span",ma,_(g.value.length)+"개",1)]),u("div",ya,[e[72]||(e[72]=u("span",{class:"label"},"뷰모드:",-1)),u("span",xa,_(L.value),1)]),u("div",wa,[e[73]||(e[73]=u("span",{class:"label"},"선택 구역:",-1)),u("span",La,_(((s=Y.value)==null?void 0:s.name)||"None"),1)])])]),u("div",ba,[u("h4",null,"🏢 Store 전체 락커 ("+_(Kt(D).lockers.length)+"개)",1),u("div",Ca,[(M(!0),T(re,null,de(Kt(D).lockers,o=>(M(),T("div",{key:o.id,class:Re(["locker-item",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",Ea,[u("span",Ma,_(o.number),1),u("span",ka,_(o.parentLockrCd?"자식":"부모"),1)]),u("div",Aa,[u("span",null,"ID: "+_(o.id),1),u("span",null,"Zone: "+_(o.zoneId),1),u("span",null,"Parent: "+_(o.parentLockrCd||"None"),1),u("span",null,"Height: "+_(o.actualHeight||o.height)+"px",1)])],2))),128))])]),u("div",Ta,[u("h4",null,"👁️ 현재 표시 락커 ("+_(g.value.length)+"개)",1),u("div",Da,[(M(!0),T(re,null,de(g.value,o=>(M(),T("div",{key:o.id,class:Re(["locker-item current",{parent:!o.parentLockrCd,child:!!o.parentLockrCd}])},[u("div",$a,[u("span",Na,_(o.number),1),u("span",_a,_(o.parentLockrCd?"자식":"부모"),1),e[75]||(e[75]=u("span",{class:"render-status"},"표시중",-1))]),u("div",Sa,[u("span",null,"위치: ("+_(o.x)+", "+_(o.y)+")",1),u("span",null,"크기: "+_(o.width)+"x"+_(o.height),1),u("span",null,"실제높이: "+_(o.actualHeight)+"px",1),u("span",null,"회전: "+_(o.rotation)+"°",1)])],2))),128))])]),u("div",Ra,[u("button",{class:"btn btn-secondary",onClick:e[27]||(e[27]=o=>ce())},"🔄 새로고침"),u("button",{class:"btn btn-primary",onClick:e[28]||(e[28]=o=>ot.value=!1)},"닫기")])])])):V("",!0),(M(),We(Eo,{to:"body"},[Qe.value?(M(),T("div",{key:0,class:"zone-context-menu",style:gt({position:"fixed",left:Lt.value.x+"px",top:Lt.value.y+"px",zIndex:9999}),onClick:e[33]||(e[33]=se(()=>{},["stop"]))},[u("div",{class:"zone-context-menu-item",onClick:e[31]||(e[31]=o=>t.editZone(bt.value))},e[77]||(e[77]=[u("span",{class:"zone-context-menu-icon"},"✏️",-1),ue(" 구역 수정 ",-1)])),u("div",{class:"zone-context-menu-item",onClick:e[32]||(e[32]=o=>zo(bt.value))},e[78]||(e[78]=[u("span",{class:"zone-context-menu-icon"},"🗑️",-1),ue(" 구역 삭제 ",-1)]))],4)):V("",!0)])),(M(),We(Eo,{to:"body"},[et.value?(M(),T("div",{key:0,class:"context-menu",style:gt({position:"fixed",left:Xe.value.x+"px",top:Xe.value.y+"px",zIndex:9999}),onClick:e[35]||(e[35]=se(()=>{},["stop"]))},[u("div",{class:"context-menu-item",onClick:e[34]||(e[34]=o=>oo(zt.value))},e[79]||(e[79]=[u("span",{class:"context-menu-icon"},"🗑️",-1),ue(" 타입 삭제 ",-1)]))],4)):V("",!0)]))])}}}),Pa=Pn(Oa,[["__scopeId","data-v-863facc3"]]);export{Pa as default};
